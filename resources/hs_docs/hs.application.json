{"watcher":{"type":"Module","doc":"Watch for application launch/terminate events\n\nThis module is based primarily on code from the previous incarnation of Mjolnir by [Markus Engelbrecht](https://github.com/mgee) and [Steven Degutis](https://github.com/sdegutis/).","def":"-> hs.application.watcher"},"activate":{"def":"hs.application:activate([allWindows]) -> bool","desc":"Tries to activate the app (make its key window focused) and returns whether it succeeded; if allWindows is true, all windows of the application are brought forward as well.","doc":"Tries to activate the app (make its key window focused) and returns whether it succeeded; if allWindows is true, all windows of the application are brought forward as well.\n\nParameters:\n * allWindows - If true, all windows of the application will be brought to the front. Otherwise, only the application's key window will. Defaults to false.\n\nReturns:\n * A boolean value indicating whether or not the application could be activated","examples":[],"file":"extensions/application/application.lua","lineno":"62","name":"activate","notes":[],"parameters":[" * allWindows - If true, all windows of the application will be brought to the front. Otherwise, only the application's key window will. Defaults to false."],"returns":[" * A boolean value indicating whether or not the application could be activated"],"signature":"hs.application:activate([allWindows]) -> bool","stripped_doc":"","type":"Method"},"allWindows":{"def":"hs.application:allWindows() -> list of hs.window objects","desc":"Returns all open windows owned by the given app.","doc":"Returns all open windows owned by the given app.\n\nParameters:\n * None\n\nReturns:\n * A table of zero or more hs.window objects owned by the application\n\nNotes:\n * This function can only return windows in the current Mission Control Space; if you need to address windows across\n   different Spaces you can use the `hs.window.filter` module\n   - if `Displays have separate Spaces` is *on* (in System Preferences>Mission Control) the current Space is defined\n     as the union of all currently visible Spaces\n   - minimized windows and hidden windows (i.e. belonging to hidden apps, e.g. via cmd-h) are always considered\n     to be in the current Space","examples":[],"file":"extensions/application/libapplication.m","lineno":"182","name":"allWindows","notes":[" * This function can only return windows in the current Mission Control Space; if you need to address windows across","   different Spaces you can use the `hs.window.filter` module","   - if `Displays have separate Spaces` is *on* (in System Preferences>Mission Control) the current Space is defined","     as the union of all currently visible Spaces","   - minimized windows and hidden windows (i.e. belonging to hidden apps, e.g. via cmd-h) are always considered","     to be in the current Space"],"parameters":[" * None"],"returns":[" * A table of zero or more hs.window objects owned by the application"],"signature":"hs.application:allWindows() -> list of hs.window objects","stripped_doc":"","type":"Method"},"applicationForPID":{"def":"hs.application.applicationForPID(pid) -> hs.application object or nil","desc":"Returns the running app for the given pid, if it exists.","doc":"Returns the running app for the given pid, if it exists.\n\nParameters:\n * pid - a UNIX process id (i.e. a number)\n\nReturns:\n * An hs.application object if one can be found, otherwise nil","examples":[],"file":"extensions/application/libapplication.m","lineno":"54","name":"applicationForPID","notes":[],"parameters":[" * pid - a UNIX process id (i.e. a number)"],"returns":[" * An hs.application object if one can be found, otherwise nil"],"signature":"hs.application.applicationForPID(pid) -> hs.application object or nil","stripped_doc":"","type":"Function"},"applicationsForBundleID":{"def":"hs.application.applicationsForBundleID(bundleID) -> list of hs.application objects","desc":"Returns any running apps that have the given bundleID.","doc":"Returns any running apps that have the given bundleID.\n\nParameters:\n * bundleID - An OSX application bundle indentifier\n\nReturns:\n * A table of zero or more hs.application objects that match the given identifier","examples":[],"file":"extensions/application/libapplication.m","lineno":"71","name":"applicationsForBundleID","notes":[],"parameters":[" * bundleID - An OSX application bundle indentifier"],"returns":[" * A table of zero or more hs.application objects that match the given identifier"],"signature":"hs.application.applicationsForBundleID(bundleID) -> list of hs.application objects","stripped_doc":"","type":"Function"},"bundleID":{"def":"hs.application:bundleID() -> string","desc":"Returns the bundle identifier of the app.","doc":"Returns the bundle identifier of the app.\n\nParameters:\n * None\n\nReturns:\n * A string containing the bundle identifier of the application","examples":[],"file":"extensions/application/libapplication.m","lineno":"285","name":"bundleID","notes":[],"parameters":[" * None"],"returns":[" * A string containing the bundle identifier of the application"],"signature":"hs.application:bundleID() -> string","stripped_doc":"","type":"Method"},"defaultAppForUTI":{"def":"hs.application.defaultAppForUTI(uti) -> string or nil","desc":"Returns the bundle ID of the default application for a given UTI","doc":"Returns the bundle ID of the default application for a given UTI\n\nParameters:\n * uti - A string containing a UTI\n\nReturns:\n * A string containing a bundle ID, or nil if none could be found","examples":[],"file":"extensions/application/libapplication.m","lineno":"151","name":"defaultAppForUTI","notes":[],"parameters":[" * uti - A string containing a UTI"],"returns":[" * A string containing a bundle ID, or nil if none could be found"],"signature":"hs.application.defaultAppForUTI(uti) -> string or nil","stripped_doc":"","type":"Function"},"enableSpotlightForNameSearches":{"def":"hs.application.enableSpotlightForNameSearches([state]) -> boolean","desc":"Get or set whether Spotlight should be used to find alternate names for applications.","doc":"Get or set whether Spotlight should be used to find alternate names for applications.\n\nParameters:\n * `state` - an optional boolean specifying whether or not Spotlight should be used to try and determine alternate application names for `hs.application.find` and similar functions.\n\nReturns:\n * the current, possibly changed, state\n\nNotes:\n * This setting is persistent across reloading and restarting Hammerspoon.\n * If this was set to true and you set it to true again, it will purge the alternate name map and rebuild it from scratch.\n * You can disable Spotlight alternate name mapping by setting this value to false or nil. If you set this to false, then the notifications indicating that more results might be possible if Spotlight is enabled will be suppressed.","examples":[],"file":"extensions/application/application.lua","lineno":"427","name":"enableSpotlightForNameSearches","notes":[" * This setting is persistent across reloading and restarting Hammerspoon."," * If this was set to true and you set it to true again, it will purge the alternate name map and rebuild it from scratch."," * You can disable Spotlight alternate name mapping by setting this value to false or nil. If you set this to false, then the notifications indicating that more results might be possible if Spotlight is enabled will be suppressed."],"parameters":[" * `state` - an optional boolean specifying whether or not Spotlight should be used to try and determine alternate application names for `hs.application.find` and similar functions."],"returns":[" * the current, possibly changed, state"],"signature":"hs.application.enableSpotlightForNameSearches([state]) -> boolean","stripped_doc":"","type":"Function"},"find":{"def":"hs.application.find(hint) -> hs.application object(s)","desc":"Finds running applications","doc":"Finds running applications\n\nParameters:\n * hint - search criterion for the desired application(s); it can be:\n   - a pid number as per `hs.application:pid()`\n   - a bundle ID string as per `hs.application:bundleID()`\n   - a string pattern that matches (via `string.find`) the application name as per `hs.application:name()` (for convenience, the matching will be done on lowercased strings)\n   - a string pattern that matches (via `string.find`) the application's window title per `hs.window:title()` (for convenience, the matching will be done on lowercased strings)\n\nReturns:\n * one or more hs.application objects for running applications that match the supplied search criterion, or `nil` if none found\n\nNotes:\n * If multiple results are found, this function will return multiple values. See [https://www.lua.org/pil/5.1.html](https://www.lua.org/pil/5.1.html) for more information on how to work with this\n * for convenience you can call this as `hs.application(hint)`\n * use this function when you don't know the exact name of an application you're interested in, i.e.\n   from the console: `hs.application'term' --> hs.application: iTerm2 (0x61000025fb88)  hs.application: Terminal (0x618000447588)`.\n   But be careful when using it in your `init.lua`: `terminal=hs.application'term'` will assign either \"Terminal\" or \"iTerm2\" arbitrarily (or even,\n   if neither are running, any other app with a window that happens to have \"term\" in its title); to make sure you get the right app in your scripts,\n   use `hs.application.get` with the exact name: `terminal=hs.application.get'Terminal' --> \"Terminal\" app, or nil if it's not running`\n\nUsage:\n-- by pid\nhs.application(42):name() --> Finder\n-- by bundle id\nhs.application'com.apple.Safari':name() --> Safari\n-- by name\nhs.application'chrome':name() --> Google Chrome\n-- by window title\nhs.application'bash':name() --> Terminal","examples":[],"file":"extensions/application/application.lua","lineno":"106","name":"find","notes":[" * If multiple results are found, this function will return multiple values. See [https://www.lua.org/pil/5.1.html](https://www.lua.org/pil/5.1.html) for more information on how to work with this"," * for convenience you can call this as `hs.application(hint)`"," * use this function when you don't know the exact name of an application you're interested in, i.e.","   from the console: `hs.application'term' --> hs.application: iTerm2 (0x61000025fb88)  hs.application: Terminal (0x618000447588)`.","   But be careful when using it in your `init.lua`: `terminal=hs.application'term'` will assign either \"Terminal\" or \"iTerm2\" arbitrarily (or even,","   if neither are running, any other app with a window that happens to have \"term\" in its title); to make sure you get the right app in your scripts,","   use `hs.application.get` with the exact name: `terminal=hs.application.get'Terminal' --> \"Terminal\" app, or nil if it's not running`","","Usage:","-- by pid","hs.application(42):name() --> Finder","-- by bundle id","hs.application'com.apple.Safari':name() --> Safari","-- by name","hs.application'chrome':name() --> Google Chrome","-- by window title","hs.application'bash':name() --> Terminal"],"parameters":[" * hint - search criterion for the desired application(s); it can be: - a pid number as per `hs.application:pid()` - a bundle ID string as per `hs.application:bundleID()` - a string pattern that matches (via `string.find`) the application name as per `hs.application:name()` (for convenience, the matching will be done on lowercased strings) - a string pattern that matches (via `string.find`) the application's window title per `hs.window:title()` (for convenience, the matching will be done on lowercased strings)"],"returns":[" * one or more hs.application objects for running applications that match the supplied search criterion, or `nil` if none found"],"signature":"hs.application.find(hint) -> hs.application object(s)","stripped_doc":"Usage:\n-- by pid\nhs.application(42):name() --> Finder\n-- by bundle id\nhs.application'com.apple.Safari':name() --> Safari\n-- by name\nhs.application'chrome':name() --> Google Chrome\n-- by window title\nhs.application'bash':name() --> Terminal","type":"Constructor"},"findMenuItem":{"def":"hs.application:findMenuItem(menuItem[, isRegex]) -> table or nil","desc":"Searches the application for a menu item","doc":"Searches the application for a menu item\n\nParameters:\n * menuItem - This can either be a string containing the text of a menu item (e.g. `\"Messages\"`) or a table representing the hierarchical path of a menu item (e.g. `{\"File\", \"Share\", \"Messages\"}`). In the string case, all of the application's menus will be searched until a match is found (with no specified behaviour if multiple menu items exist with the same name). In the table case, the whole menu structure will not be searched, because a precise path has been specified.\n * isRegex - An optional boolean, defaulting to false, which is only used if `menuItem` is a string. If set to true, `menuItem` will be treated as a regular expression rather than a strict string to match against\n\nReturns:\n * Returns nil if the menu item cannot be found. If it does exist, returns a table with two keys:\n  * enabled - whether the menu item can be selected/ticked. This will always be false if the application is not currently focussed\n  * ticked - whether the menu item is ticked or not (obviously this value is meaningless for menu items that can't be ticked)\n\nNotes:\n * This can only search for menu items that don't have children - i.e. you can't search for the name of a submenu","examples":[],"file":"extensions/application/libapplication.m","lineno":"700","name":"findMenuItem","notes":[" * This can only search for menu items that don't have children - i.e. you can't search for the name of a submenu"],"parameters":[" * menuItem - This can either be a string containing the text of a menu item (e.g. `\"Messages\"`) or a table representing the hierarchical path of a menu item (e.g. `{\"File\", \"Share\", \"Messages\"}`). In the string case, all of the application's menus will be searched until a match is found (with no specified behaviour if multiple menu items exist with the same name). In the table case, the whole menu structure will not be searched, because a precise path has been specified."," * isRegex - An optional boolean, defaulting to false, which is only used if `menuItem` is a string. If set to true, `menuItem` will be treated as a regular expression rather than a strict string to match against"],"returns":[" * Returns nil if the menu item cannot be found. If it does exist, returns a table with two keys:","  * enabled - whether the menu item can be selected/ticked. This will always be false if the application is not currently focussed","  * ticked - whether the menu item is ticked or not (obviously this value is meaningless for menu items that can't be ticked)"],"signature":"hs.application:findMenuItem(menuItem[, isRegex]) -> table or nil","stripped_doc":"","type":"Method"},"findWindow":{"def":"hs.application:findWindow(titlePattern) -> hs.window object(s)","desc":"Finds windows from this application","doc":"Finds windows from this application\n\nParameters:\n * titlePattern - a string pattern that matches (via `string.find`) the window title(s) as per `hs.window:title()` (for convenience, the matching will be done on lowercased strings)\n\nReturns:\n * one or more hs.window objects belonging to this application that match the supplied search criterion, or `nil` if none found","examples":[],"file":"extensions/application/application.lua","lineno":"173","name":"findWindow","notes":[],"parameters":[" * titlePattern - a string pattern that matches (via `string.find`) the window title(s) as per `hs.window:title()` (for convenience, the matching will be done on lowercased strings)"],"returns":[" * one or more hs.window objects belonging to this application that match the supplied search criterion, or `nil` if none found"],"signature":"hs.application:findWindow(titlePattern) -> hs.window object(s)","stripped_doc":"","type":"Method"},"focusedWindow":{"def":"hs.application:focusedWindow() -> hs.window object or nil","desc":"Returns the currently focused window of the application, or nil","doc":"Returns the currently focused window of the application, or nil\n\nParameters:\n * None\n\nReturns:\n * An hs.window object representing the window of the application that currently has focus, or nil if there are none","examples":[],"file":"extensions/application/libapplication.m","lineno":"225","name":"focusedWindow","notes":[],"parameters":[" * None"],"returns":[" * An hs.window object representing the window of the application that currently has focus, or nil if there are none"],"signature":"hs.application:focusedWindow() -> hs.window object or nil","stripped_doc":"","type":"Method"},"frontmostApplication":{"def":"hs.application.frontmostApplication() -> hs.application object","desc":"Returns the application object for the frontmost (active) application.  This is the application which currently receives input events.","doc":"Returns the application object for the frontmost (active) application.  This is the application which currently receives input events.\n\nParameters:\n * None\n\nReturns:\n * An hs.application object","examples":[],"file":"extensions/application/libapplication.m","lineno":"21","name":"frontmostApplication","notes":[],"parameters":[" * None"],"returns":[" * An hs.application object"],"signature":"hs.application.frontmostApplication() -> hs.application object","stripped_doc":"","type":"Function"},"get":{"def":"hs.application.get(hint) -> hs.application object","desc":"Gets a running application","doc":"Gets a running application\n\nParameters:\n * hint - search criterion for the desired application; it can be:\n   - a pid number as per `hs.application:pid()`\n   - a bundle ID string as per `hs.application:bundleID()`\n   - an application name string as per `hs.application:name()`\n\nReturns:\n * an hs.application object for a running application that matches the supplied search criterion, or `nil` if not found\n\nNotes:\n * see also `hs.application.find`","examples":[],"file":"extensions/application/application.lua","lineno":"87","name":"get","notes":[" * see also `hs.application.find`"],"parameters":[" * hint - search criterion for the desired application; it can be: - a pid number as per `hs.application:pid()` - a bundle ID string as per `hs.application:bundleID()` - an application name string as per `hs.application:name()`"],"returns":[" * an hs.application object for a running application that matches the supplied search criterion, or `nil` if not found"],"signature":"hs.application.get(hint) -> hs.application object","stripped_doc":"","type":"Constructor"},"getMenuItems":{"def":"hs.application:getMenuItems([fn]) -> table or nil | hs.application object","desc":"Gets the menu structure of the application","doc":"Gets the menu structure of the application\n\nParameters:\n * fn - an optional callback function.  If provided, the function will receive a single argument and return none.\n\nReturns:\n * If no argument is provided, returns a table containing the menu structure of the application, or nil if an error occurred. If a callback function is provided, the callback function will receive this table (or nil) and this method will return the application object this method was invoked on.\n\nNotes:\n * In some applications, this can take a little while to complete, because quite a large number of round trips are required to the source application, to get the information. When this method is invoked without a callback function, Hammerspoon will block while creating the menu structure table.  When invoked with a callback function, the menu structure is built in a background thread.\n\n * The table is nested with the same structure as the menus of the application. Each item has several keys containing information about the menu item. Not all keys will appear for all items. The possible keys are:\n  * AXTitle - A string containing the text of the menu item (entries which have no title are menu separators)\n  * AXEnabled - A boolean, 1 if the menu item is clickable, 0 if not\n  * AXRole - A string containing the role of the menu item - this will be either AXMenuBarItem for a top level menu, or AXMenuItem for an item in a menu\n  * AXMenuItemMarkChar - A string containing the \"mark\" character for a menu item. This is for toggleable menu items and will usually be an empty string or a Unicode tick character (✓)\n  * AXMenuItemCmdModifiers - A table containing string representations of the keyboard modifiers for the menu item's keyboard shortcut, or nil if no modifiers are present\n  * AXMenuItemCmdChar - A string containing the key for the menu item's keyboard shortcut, or an empty string if no shortcut is present\n  * AXMenuItemCmdGlyph - An integer, corresponding to one of the defined glyphs in `hs.application.menuGlyphs` if the keyboard shortcut is a special character usually represented by a pictorial representation (think arrow keys, return, etc), or an empty string if no glyph is used in presenting the keyboard shortcut.\n * Using `hs.inspect()` on these tables, while useful for exploration, can be extremely slow, taking several minutes to correctly render very complex menus","examples":[],"file":"extensions/application/libapplication.m","lineno":"961","name":"getMenuItems","notes":[" * In some applications, this can take a little while to complete, because quite a large number of round trips are required to the source application, to get the information. When this method is invoked without a callback function, Hammerspoon will block while creating the menu structure table.  When invoked with a callback function, the menu structure is built in a background thread.",""," * The table is nested with the same structure as the menus of the application. Each item has several keys containing information about the menu item. Not all keys will appear for all items. The possible keys are:","  * AXTitle - A string containing the text of the menu item (entries which have no title are menu separators)","  * AXEnabled - A boolean, 1 if the menu item is clickable, 0 if not","  * AXRole - A string containing the role of the menu item - this will be either AXMenuBarItem for a top level menu, or AXMenuItem for an item in a menu","  * AXMenuItemMarkChar - A string containing the \"mark\" character for a menu item. This is for toggleable menu items and will usually be an empty string or a Unicode tick character (✓)","  * AXMenuItemCmdModifiers - A table containing string representations of the keyboard modifiers for the menu item's keyboard shortcut, or nil if no modifiers are present","  * AXMenuItemCmdChar - A string containing the key for the menu item's keyboard shortcut, or an empty string if no shortcut is present","  * AXMenuItemCmdGlyph - An integer, corresponding to one of the defined glyphs in `hs.application.menuGlyphs` if the keyboard shortcut is a special character usually represented by a pictorial representation (think arrow keys, return, etc), or an empty string if no glyph is used in presenting the keyboard shortcut."," * Using `hs.inspect()` on these tables, while useful for exploration, can be extremely slow, taking several minutes to correctly render very complex menus"],"parameters":[" * fn - an optional callback function.  If provided, the function will receive a single argument and return none."],"returns":[" * If no argument is provided, returns a table containing the menu structure of the application, or nil if an error occurred. If a callback function is provided, the callback function will receive this table (or nil) and this method will return the application object this method was invoked on."],"signature":"hs.application:getMenuItems([fn]) -> table or nil | hs.application object","stripped_doc":" * The table is nested with the same structure as the menus of the application. Each item has several keys containing information about the menu item. Not all keys will appear for all items. The possible keys are:\n  * AXTitle - A string containing the text of the menu item (entries which have no title are menu separators)\n  * AXEnabled - A boolean, 1 if the menu item is clickable, 0 if not\n  * AXRole - A string containing the role of the menu item - this will be either AXMenuBarItem for a top level menu, or AXMenuItem for an item in a menu\n  * AXMenuItemMarkChar - A string containing the \"mark\" character for a menu item. This is for toggleable menu items and will usually be an empty string or a Unicode tick character (✓)\n  * AXMenuItemCmdModifiers - A table containing string representations of the keyboard modifiers for the menu item's keyboard shortcut, or nil if no modifiers are present\n  * AXMenuItemCmdChar - A string containing the key for the menu item's keyboard shortcut, or an empty string if no shortcut is present\n  * AXMenuItemCmdGlyph - An integer, corresponding to one of the defined glyphs in `hs.application.menuGlyphs` if the keyboard shortcut is a special character usually represented by a pictorial representation (think arrow keys, return, etc), or an empty string if no glyph is used in presenting the keyboard shortcut.\n * Using `hs.inspect()` on these tables, while useful for exploration, can be extremely slow, taking several minutes to correctly render very complex menus","type":"Method"},"getWindow":{"def":"hs.application:getWindow(title) -> hs.window object","desc":"Gets a specific window from this application","doc":"Gets a specific window from this application\n\nParameters:\n * title - the desired window's title string as per `hs.window:title()`\n\nReturns:\n * the desired hs.window object belonging to this application, or `nil` if not found","examples":[],"file":"extensions/application/application.lua","lineno":"187","name":"getWindow","notes":[],"parameters":[" * title - the desired window's title string as per `hs.window:title()`"],"returns":[" * the desired hs.window object belonging to this application, or `nil` if not found"],"signature":"hs.application:getWindow(title) -> hs.window object","stripped_doc":"","type":"Method"},"hide":{"def":"hs.application:hide() -> boolean","desc":"Hides the app (and all its windows).","doc":"Hides the app (and all its windows).\n\nParameters:\n * None\n\nReturns:\n * A boolean indicating whether the application was successfully hidden","examples":[],"file":"extensions/application/libapplication.m","lineno":"357","name":"hide","notes":[],"parameters":[" * None"],"returns":[" * A boolean indicating whether the application was successfully hidden"],"signature":"hs.application:hide() -> boolean","stripped_doc":"","type":"Method"},"infoForBundleID":{"def":"hs.application.infoForBundleID(bundleID) -> table or nil","desc":"Gets the metadata of an application from its bundle identifier","doc":"Gets the metadata of an application from its bundle identifier\n\nParameters:\n * bundleID - A string containing an application bundle identifier (e.g. \"com.apple.Safari\")\n\nReturns:\n * A table containing information about the application, or nil if the bundle identifier could not be located","examples":[],"file":"extensions/application/libapplication.m","lineno":"119","name":"infoForBundleID","notes":[],"parameters":[" * bundleID - A string containing an application bundle identifier (e.g. \"com.apple.Safari\")"],"returns":[" * A table containing information about the application, or nil if the bundle identifier could not be located"],"signature":"hs.application.infoForBundleID(bundleID) -> table or nil","stripped_doc":"","type":"Function"},"infoForBundlePath":{"def":"hs.application.infoForBundlePath(bundlePath) -> table or nil","desc":"Gets the metadata of an application from its path on disk","doc":"Gets the metadata of an application from its path on disk\n\nParameters:\n * bundlePath - A string containing the path to an application bundle (e.g. \"/Applications/Safari.app\")\n\nReturns:\n * A table containing information about the application, or nil if the bundle could not be located","examples":[],"file":"extensions/application/libapplication.m","lineno":"135","name":"infoForBundlePath","notes":[],"parameters":[" * bundlePath - A string containing the path to an application bundle (e.g. \"/Applications/Safari.app\")"],"returns":[" * A table containing information about the application, or nil if the bundle could not be located"],"signature":"hs.application.infoForBundlePath(bundlePath) -> table or nil","stripped_doc":"","type":"Function"},"isFrontmost":{"def":"hs.application:isFrontmost() -> boolean","desc":"Returns whether the app is the frontmost (i.e. is the currently active application)","doc":"Returns whether the app is the frontmost (i.e. is the currently active application)\n\nParameters:\n * None\n\nReturns:\n * True if the application is the frontmost application, otherwise false","examples":[],"file":"extensions/application/libapplication.m","lineno":"426","name":"isFrontmost","notes":[],"parameters":[" * None"],"returns":[" * True if the application is the frontmost application, otherwise false"],"signature":"hs.application:isFrontmost() -> boolean","stripped_doc":"","type":"Method"},"isHidden":{"def":"hs.application:isHidden() -> boolean","desc":"Returns whether the app is currently hidden.","doc":"Returns whether the app is currently hidden.\n\nParameters:\n * None\n\nReturns:\n * A boolean indicating whether the application is hidden or not","examples":[],"file":"extensions/application/libapplication.m","lineno":"409","name":"isHidden","notes":[],"parameters":[" * None"],"returns":[" * A boolean indicating whether the application is hidden or not"],"signature":"hs.application:isHidden() -> boolean","stripped_doc":"","type":"Method"},"isRunning":{"def":"hs.application:isRunning() -> boolean","desc":"Checks if the application is still running","doc":"Checks if the application is still running\n\nParameters:\n * None\n\nReturns:\n * A boolean, true if the application is running, false if not\n\nNotes:\n * If an application is terminated and re-launched, this method will still return false, as `hs.application` objects are tied to a specific instance of an application (i.e. its PID)","examples":[],"file":"extensions/application/libapplication.m","lineno":"319","name":"isRunning","notes":[" * If an application is terminated and re-launched, this method will still return false, as `hs.application` objects are tied to a specific instance of an application (i.e. its PID)"],"parameters":[" * None"],"returns":[" * A boolean, true if the application is running, false if not"],"signature":"hs.application:isRunning() -> boolean","stripped_doc":"","type":"Method"},"kill":{"def":"hs.application:kill()","desc":"Tries to terminate the app gracefully.","doc":"Tries to terminate the app gracefully.\n\nParameters:\n * None\n\nReturns:\n * None","examples":[],"file":"extensions/application/libapplication.m","lineno":"375","name":"kill","notes":[],"parameters":[" * None"],"returns":[" * None"],"signature":"hs.application:kill()","stripped_doc":"","type":"Method"},"kill9":{"def":"hs.application:kill9()","desc":"Tries to terminate the app forcefully.","doc":"Tries to terminate the app forcefully.\n\nParameters:\n * None\n\nReturns:\n * None","examples":[],"file":"extensions/application/libapplication.m","lineno":"392","name":"kill9","notes":[],"parameters":[" * None"],"returns":[" * None"],"signature":"hs.application:kill9()","stripped_doc":"","type":"Method"},"kind":{"def":"hs.application:kind() -> number","desc":"Identify the application's GUI state","doc":"Identify the application's GUI state\n\nParameters:\n * None\n\nReturns:\n * A number that is either 1 if the app is in the dock, 0 if it is not, or -1 if the application is prohibited from having GUI elements","examples":[],"file":"extensions/application/libapplication.m","lineno":"483","name":"kind","notes":[],"parameters":[" * None"],"returns":[" * A number that is either 1 if the app is in the dock, 0 if it is not, or -1 if the application is prohibited from having GUI elements"],"signature":"hs.application:kind() -> number","stripped_doc":"","type":"Method"},"launchOrFocus":{"def":"hs.application.launchOrFocus(name) -> boolean","desc":"Launches the app with the given name, or activates it if it's already running","doc":"Launches the app with the given name, or activates it if it's already running\n\nParameters:\n * name - A string containing the name of the application to either launch or focus. This can also be the full path to an application (including the `.app` suffix) if you need to uniquely distinguish between applications in different locations that share the same name\n\nReturns:\n * True if the application was either launched or focused, otherwise false (e.g. if the application doesn't exist)\n\nNotes:\n * The name parameter should match the name of the application on disk, e.g. \"IntelliJ IDEA\", rather than \"IntelliJ\"","examples":[],"file":"extensions/application/libapplication.m","lineno":"1028","name":"launchOrFocus","notes":[" * The name parameter should match the name of the application on disk, e.g. \"IntelliJ IDEA\", rather than \"IntelliJ\""],"parameters":[" * name - A string containing the name of the application to either launch or focus. This can also be the full path to an application (including the `.app` suffix) if you need to uniquely distinguish between applications in different locations that share the same name"],"returns":[" * True if the application was either launched or focused, otherwise false (e.g. if the application doesn't exist)"],"signature":"hs.application.launchOrFocus(name) -> boolean","stripped_doc":"","type":"Function"},"launchOrFocusByBundleID":{"def":"hs.application.launchOrFocusByBundleID(bundleID) -> boolean","desc":"Launches the app with the given bundle ID, or activates it if it's already running","doc":"Launches the app with the given bundle ID, or activates it if it's already running\n\nParameters:\n * bundleID - A string containing the bundle ID of the application to either launch or focus.\n\nReturns:\n * True if the application was either launched or focused, otherwise false (e.g. if the application doesn't exist)\n\nNotes:\n * Bundle identifiers typically take the form of `com.company.ApplicationName`","examples":[],"file":"extensions/application/libapplication.m","lineno":"1047","name":"launchOrFocusByBundleID","notes":[" * Bundle identifiers typically take the form of `com.company.ApplicationName`"],"parameters":[" * bundleID - A string containing the bundle ID of the application to either launch or focus."],"returns":[" * True if the application was either launched or focused, otherwise false (e.g. if the application doesn't exist)"],"signature":"hs.application.launchOrFocusByBundleID(bundleID) -> boolean","stripped_doc":"","type":"Function"},"mainWindow":{"def":"hs.application:mainWindow() -> hs.window object or nil","desc":"Returns the main window of the given app, or nil.","doc":"Returns the main window of the given app, or nil.\n\nParameters:\n * None\n\nReturns:\n * An hs.window object representing the main window of the application, or nil if it has no windows","examples":[],"file":"extensions/application/libapplication.m","lineno":"208","name":"mainWindow","notes":[],"parameters":[" * None"],"returns":[" * An hs.window object representing the main window of the application, or nil if it has no windows"],"signature":"hs.application:mainWindow() -> hs.window object or nil","stripped_doc":"","type":"Method"},"menuGlyphs":{"def":"hs.application.menuGlyphs","desc":"A table containing UTF8 representations of the defined key glyphs used in Menus for keybaord shortcuts which are presented pictorially rather than as text (arrow keys, return key, etc.)","doc":"A table containing UTF8 representations of the defined key glyphs used in Menus for keybaord shortcuts which are presented pictorially rather than as text (arrow keys, return key, etc.)\n\nThese glyphs are indexed numerically where the numeric index matches a possible value for the AXMenuItemCmdGlyph key of an entry returned by `hs.application.getMenus`.  If the AXMenuItemCmdGlyph field is non-numeric, then no glyph is used in the presentation of the keyboard shortcut for a menu item.\n\nThe following glyphs are defined:\n * \"⇥\",  -- kMenuTabRightGlyph, 0x02, Tab to the right key (for left-to-right script systems)\n * \"⇤\",  -- kMenuTabLeftGlyph, 0x03, Tab to the left key (for right-to-left script systems)\n * \"⌤\",   -- kMenuEnterGlyph, 0x04, Enter key\n * \"⇧\",  -- kMenuShiftGlyph, 0x05, Shift key\n * \"⌃\",   -- kMenuControlGlyph, 0x06, Control key\n * \"⌥\",  -- kMenuOptionGlyph, 0x07, Option key\n * \"␣\",    -- kMenuSpaceGlyph, 0x09, Space (always glyph 3) key\n * \"⌦\",  -- kMenuDeleteRightGlyph, 0x0A, Delete to the right key (for right-to-left script systems)\n * \"↩\",  -- kMenuReturnGlyph, 0x0B, Return key (for left-to-right script systems)\n * \"↪\",  -- kMenuReturnR2LGlyph, 0x0C, Return key (for right-to-left script systems)\n * \"\",   -- kMenuPencilGlyph, 0x0F, Pencil key\n * \"↓\",   -- kMenuDownwardArrowDashedGlyph, 0x10, Downward dashed arrow key\n * \"⌘\",  -- kMenuCommandGlyph, 0x11, Command key\n * \"✓\",   -- kMenuCheckmarkGlyph, 0x12, Checkmark key\n * \"⃟\",   -- kMenuDiamondGlyph, 0x13, Diamond key\n * \"\",   -- kMenuAppleLogoFilledGlyph, 0x14, Apple logo key (filled)\n * \"⌫\",  -- kMenuDeleteLeftGlyph, 0x17, Delete to the left key (for left-to-right script systems)\n * \"←\",  -- kMenuLeftArrowDashedGlyph, 0x18, Leftward dashed arrow key\n * \"↑\",   -- kMenuUpArrowDashedGlyph, 0x19, Upward dashed arrow key\n * \"→\",   -- kMenuRightArrowDashedGlyph, 0x1A, Rightward dashed arrow key\n * \"⎋\",  -- kMenuEscapeGlyph, 0x1B, Escape key\n * \"⌧\",  -- kMenuClearGlyph, 0x1C, Clear key\n * \"『\",  -- kMenuLeftDoubleQuotesJapaneseGlyph, 0x1D, Unassigned (left double quotes in Japanese)\n * \"』\",  -- kMenuRightDoubleQuotesJapaneseGlyph, 0x1E, Unassigned (right double quotes in Japanese)\n * \"␢\",   -- kMenuBlankGlyph, 0x61, Blank key\n * \"⇞\",   -- kMenuPageUpGlyph, 0x62, Page up key\n * \"⇪\",  -- kMenuCapsLockGlyph, 0x63, Caps lock key\n * \"←\",  -- kMenuLeftArrowGlyph, 0x64, Left arrow key\n * \"→\",   -- kMenuRightArrowGlyph, 0x65, Right arrow key\n * \"↖\",  -- kMenuNorthwestArrowGlyph, 0x66, Northwest arrow key\n * \"﹖\",  -- kMenuHelpGlyph, 0x67, Help key\n * \"↑\",   -- kMenuUpArrowGlyph, 0x68, Up arrow key\n * \"↘\",  -- kMenuSoutheastArrowGlyph, 0x69, Southeast arrow key\n * \"↓\",   -- kMenuDownArrowGlyph, 0x6A, Down arrow key\n * \"⇟\",   -- kMenuPageDownGlyph, 0x6B, Page down key\n * \"\",  -- kMenuContextualMenuGlyph, 0x6D, Contextual menu key\n * \"⌽\",  -- kMenuPowerGlyph, 0x6E, Power key\n * \"F1\",  -- kMenuF1Glyph, 0x6F, F1 key\n * \"F2\",  -- kMenuF2Glyph, 0x70, F2 key\n * \"F3\",  -- kMenuF3Glyph, 0x71, F3 key\n * \"F4\",  -- kMenuF4Glyph, 0x72, F4 key\n * \"F5\",  -- kMenuF5Glyph, 0x73, F5 key\n * \"F6\",  -- kMenuF6Glyph, 0x74, F6 key\n * \"F7\",  -- kMenuF7Glyph, 0x75, F7 key\n * \"F8\",  -- kMenuF8Glyph, 0x76, F8 key\n * \"F9\",  -- kMenuF9Glyph, 0x77, F9 key\n * \"F10\", -- kMenuF10Glyph, 0x78, F10 key\n * \"F11\", -- kMenuF11Glyph, 0x79, F11 key\n * \"F12\", -- kMenuF12Glyph, 0x7A, F12 key\n * \"F13\", -- kMenuF13Glyph, 0x87, F13 key\n * \"F14\", -- kMenuF14Glyph, 0x88, F14 key\n * \"F15\", -- kMenuF15Glyph, 0x89, F15 key\n * \"⎈\",  -- kMenuControlISOGlyph, 0x8A, Control key (ISO standard)\n * \"⏏\",   -- kMenuEjectGlyph, 0x8C, Eject key (available on Mac OS X 10.2 and later)\n * \"英数\", -- kMenuEisuGlyph, 0x8D, Japanese eisu key (available in Mac OS X 10.4 and later)\n * \"かな\", -- kMenuKanaGlyph, 0x8E, Japanese kana key (available in Mac OS X 10.4 and later)\n * \"F16\", -- kMenuF16Glyph, 0x8F, F16 key (available in SnowLeopard and later)\n * \"F17\", -- kMenuF16Glyph, 0x90, F17 key (available in SnowLeopard and later)\n * \"F18\", -- kMenuF16Glyph, 0x91, F18 key (available in SnowLeopard and later)\n * \"F19\", -- kMenuF16Glyph, 0x92, F19 key (available in SnowLeopard and later)\n\nNotes:\n * a `__tostring` metamethod is provided for this table so you can view its current contents by typing `hs.application.menuGlyphs` into the Hammerspoon console.\n * This table is provided as a variable so that you can change any representation if you feel you know of a better or more appropriate one for you usage at runtime.\n\n * The glyphs provided are defined in the Carbon framework headers in the Menus.h file, located (as of 10.11) at /System/Library/Frameworks/Carbon.framework/Frameworks/HIToolbox.framework/Headers/Menus.h.\n * The following constants are defined in Menus.h, but do not seem to correspond to a visible UTF8 character or well defined representation that I could discover.  If you believe that you know of a (preferably sanctioned by Apple) proper visual representation, please submit an issue detailing it at the Hammerspoon repository on Github.\n   * kMenuNullGlyph, 0x00, Null (always glyph 1)\n   * kMenuNonmarkingReturnGlyph, 0x0D, Nonmarking return key\n   * kMenuParagraphKoreanGlyph, 0x15, Unassigned (paragraph in Korean)\n   * kMenuTrademarkJapaneseGlyph, 0x1F, Unassigned (trademark in Japanese)\n   * kMenuAppleLogoOutlineGlyph, 0x6C, Apple logo key (outline)","file":"extensions/application/application.lua","lineno":"237","name":"menuGlyphs","notes":[" * a `__tostring` metamethod is provided for this table so you can view its current contents by typing `hs.application.menuGlyphs` into the Hammerspoon console."," * This table is provided as a variable so that you can change any representation if you feel you know of a better or more appropriate one for you usage at runtime.",""," * The glyphs provided are defined in the Carbon framework headers in the Menus.h file, located (as of 10.11) at /System/Library/Frameworks/Carbon.framework/Frameworks/HIToolbox.framework/Headers/Menus.h."," * The following constants are defined in Menus.h, but do not seem to correspond to a visible UTF8 character or well defined representation that I could discover.  If you believe that you know of a (preferably sanctioned by Apple) proper visual representation, please submit an issue detailing it at the Hammerspoon repository on Github.","   * kMenuNullGlyph, 0x00, Null (always glyph 1)","   * kMenuNonmarkingReturnGlyph, 0x0D, Nonmarking return key","   * kMenuParagraphKoreanGlyph, 0x15, Unassigned (paragraph in Korean)","   * kMenuTrademarkJapaneseGlyph, 0x1F, Unassigned (trademark in Japanese)","   * kMenuAppleLogoOutlineGlyph, 0x6C, Apple logo key (outline)"],"signature":"hs.application.menuGlyphs","stripped_doc":"These glyphs are indexed numerically where the numeric index matches a possible value for the AXMenuItemCmdGlyph key of an entry returned by `hs.application.getMenus`.  If the AXMenuItemCmdGlyph field is non-numeric, then no glyph is used in the presentation of the keyboard shortcut for a menu item.\nThe following glyphs are defined:\n * \"⇥\",  -- kMenuTabRightGlyph, 0x02, Tab to the right key (for left-to-right script systems)\n * \"⇤\",  -- kMenuTabLeftGlyph, 0x03, Tab to the left key (for right-to-left script systems)\n * \"⌤\",   -- kMenuEnterGlyph, 0x04, Enter key\n * \"⇧\",  -- kMenuShiftGlyph, 0x05, Shift key\n * \"⌃\",   -- kMenuControlGlyph, 0x06, Control key\n * \"⌥\",  -- kMenuOptionGlyph, 0x07, Option key\n * \"␣\",    -- kMenuSpaceGlyph, 0x09, Space (always glyph 3) key\n * \"⌦\",  -- kMenuDeleteRightGlyph, 0x0A, Delete to the right key (for right-to-left script systems)\n * \"↩\",  -- kMenuReturnGlyph, 0x0B, Return key (for left-to-right script systems)\n * \"↪\",  -- kMenuReturnR2LGlyph, 0x0C, Return key (for right-to-left script systems)\n * \"\",   -- kMenuPencilGlyph, 0x0F, Pencil key\n * \"↓\",   -- kMenuDownwardArrowDashedGlyph, 0x10, Downward dashed arrow key\n * \"⌘\",  -- kMenuCommandGlyph, 0x11, Command key\n * \"✓\",   -- kMenuCheckmarkGlyph, 0x12, Checkmark key\n * \"⃟\",   -- kMenuDiamondGlyph, 0x13, Diamond key\n * \"\",   -- kMenuAppleLogoFilledGlyph, 0x14, Apple logo key (filled)\n * \"⌫\",  -- kMenuDeleteLeftGlyph, 0x17, Delete to the left key (for left-to-right script systems)\n * \"←\",  -- kMenuLeftArrowDashedGlyph, 0x18, Leftward dashed arrow key\n * \"↑\",   -- kMenuUpArrowDashedGlyph, 0x19, Upward dashed arrow key\n * \"→\",   -- kMenuRightArrowDashedGlyph, 0x1A, Rightward dashed arrow key\n * \"⎋\",  -- kMenuEscapeGlyph, 0x1B, Escape key\n * \"⌧\",  -- kMenuClearGlyph, 0x1C, Clear key\n * \"『\",  -- kMenuLeftDoubleQuotesJapaneseGlyph, 0x1D, Unassigned (left double quotes in Japanese)\n * \"』\",  -- kMenuRightDoubleQuotesJapaneseGlyph, 0x1E, Unassigned (right double quotes in Japanese)\n * \"␢\",   -- kMenuBlankGlyph, 0x61, Blank key\n * \"⇞\",   -- kMenuPageUpGlyph, 0x62, Page up key\n * \"⇪\",  -- kMenuCapsLockGlyph, 0x63, Caps lock key\n * \"←\",  -- kMenuLeftArrowGlyph, 0x64, Left arrow key\n * \"→\",   -- kMenuRightArrowGlyph, 0x65, Right arrow key\n * \"↖\",  -- kMenuNorthwestArrowGlyph, 0x66, Northwest arrow key\n * \"﹖\",  -- kMenuHelpGlyph, 0x67, Help key\n * \"↑\",   -- kMenuUpArrowGlyph, 0x68, Up arrow key\n * \"↘\",  -- kMenuSoutheastArrowGlyph, 0x69, Southeast arrow key\n * \"↓\",   -- kMenuDownArrowGlyph, 0x6A, Down arrow key\n * \"⇟\",   -- kMenuPageDownGlyph, 0x6B, Page down key\n * \"\",  -- kMenuContextualMenuGlyph, 0x6D, Contextual menu key\n * \"⌽\",  -- kMenuPowerGlyph, 0x6E, Power key\n * \"F1\",  -- kMenuF1Glyph, 0x6F, F1 key\n * \"F2\",  -- kMenuF2Glyph, 0x70, F2 key\n * \"F3\",  -- kMenuF3Glyph, 0x71, F3 key\n * \"F4\",  -- kMenuF4Glyph, 0x72, F4 key\n * \"F5\",  -- kMenuF5Glyph, 0x73, F5 key\n * \"F6\",  -- kMenuF6Glyph, 0x74, F6 key\n * \"F7\",  -- kMenuF7Glyph, 0x75, F7 key\n * \"F8\",  -- kMenuF8Glyph, 0x76, F8 key\n * \"F9\",  -- kMenuF9Glyph, 0x77, F9 key\n * \"F10\", -- kMenuF10Glyph, 0x78, F10 key\n * \"F11\", -- kMenuF11Glyph, 0x79, F11 key\n * \"F12\", -- kMenuF12Glyph, 0x7A, F12 key\n * \"F13\", -- kMenuF13Glyph, 0x87, F13 key\n * \"F14\", -- kMenuF14Glyph, 0x88, F14 key\n * \"F15\", -- kMenuF15Glyph, 0x89, F15 key\n * \"⎈\",  -- kMenuControlISOGlyph, 0x8A, Control key (ISO standard)\n * \"⏏\",   -- kMenuEjectGlyph, 0x8C, Eject key (available on Mac OS X 10.2 and later)\n * \"英数\", -- kMenuEisuGlyph, 0x8D, Japanese eisu key (available in Mac OS X 10.4 and later)\n * \"かな\", -- kMenuKanaGlyph, 0x8E, Japanese kana key (available in Mac OS X 10.4 and later)\n * \"F16\", -- kMenuF16Glyph, 0x8F, F16 key (available in SnowLeopard and later)\n * \"F17\", -- kMenuF16Glyph, 0x90, F17 key (available in SnowLeopard and later)\n * \"F18\", -- kMenuF16Glyph, 0x91, F18 key (available in SnowLeopard and later)\n * \"F19\", -- kMenuF16Glyph, 0x92, F19 key (available in SnowLeopard and later)\n * The glyphs provided are defined in the Carbon framework headers in the Menus.h file, located (as of 10.11) at /System/Library/Frameworks/Carbon.framework/Frameworks/HIToolbox.framework/Headers/Menus.h.\n * The following constants are defined in Menus.h, but do not seem to correspond to a visible UTF8 character or well defined representation that I could discover.  If you believe that you know of a (preferably sanctioned by Apple) proper visual representation, please submit an issue detailing it at the Hammerspoon repository on Github.\n   * kMenuNullGlyph, 0x00, Null (always glyph 1)\n   * kMenuNonmarkingReturnGlyph, 0x0D, Nonmarking return key\n   * kMenuParagraphKoreanGlyph, 0x15, Unassigned (paragraph in Korean)\n   * kMenuTrademarkJapaneseGlyph, 0x1F, Unassigned (trademark in Japanese)\n   * kMenuAppleLogoOutlineGlyph, 0x6C, Apple logo key (outline)","type":"Variable"},"name":{"def":"hs.application:name()","desc":"Alias for [`hs.application:title()`](#title)","doc":"Alias for [`hs.application:title()`](#title)","file":"extensions/application/application.lua","lineno":"82","name":"name","notes":[],"parameters":[],"returns":[],"signature":"hs.application:name()","stripped_doc":"","type":"Method"},"nameForBundleID":{"def":"hs.application.nameForBundleID(bundleID) -> string or nil","desc":"Gets the name of an application from its bundle identifier","doc":"Gets the name of an application from its bundle identifier\n\nParameters:\n * bundleID - A string containing an application bundle identifier (e.g. \"com.apple.Safari\")\n\nReturns:\n * A string containing the application name, or nil if the bundle identifier could not be located","examples":[],"file":"extensions/application/libapplication.m","lineno":"87","name":"nameForBundleID","notes":[],"parameters":[" * bundleID - A string containing an application bundle identifier (e.g. \"com.apple.Safari\")"],"returns":[" * A string containing the application name, or nil if the bundle identifier could not be located"],"signature":"hs.application.nameForBundleID(bundleID) -> string or nil","stripped_doc":"","type":"Function"},"open":{"def":"hs.application.open(app[, wait, [waitForFirstWindow]]) -> hs.application object","desc":"Launches an application, or activates it if it's already running","doc":"Launches an application, or activates it if it's already running\n\nParameters:\n * app - a string describing the application to open; it can be:\n   - the application's name as per `hs.application:name()`\n   - the full path to an application on disk (including the `.app` suffix)\n   - the application's bundle ID as per `hs.application:bundleID()`\n * wait - (optional) the maximum number of seconds to wait for the app to be launched, if not already running; if omitted, defaults to 0;\n  if the app takes longer than this to launch, this function will return `nil`, but the app will still launch\n * waitForFirstWindow - (optional) if `true`, additionally wait until the app has spawned its first window (which usually takes a bit longer)\n\nReturns:\n * the `hs.application` object for the launched or activated application; `nil` if not found\n\nNotes:\n * the `wait` parameter will *block all Hammerspoon activity* in order to return the application object \"synchronously\"; only use it if you\n   a) have no time-critical event processing happening elsewhere in your `init.lua` and b) need to act on the application object, or on\n   its window(s), right away\n * when launching a \"windowless\" app (background daemon, menulet, etc.) make sure to omit `waitForFirstWindow`","examples":[],"file":"extensions/application/application.lua","lineno":"200","name":"open","notes":[" * the `wait` parameter will *block all Hammerspoon activity* in order to return the application object \"synchronously\"; only use it if you","   a) have no time-critical event processing happening elsewhere in your `init.lua` and b) need to act on the application object, or on","   its window(s), right away"," * when launching a \"windowless\" app (background daemon, menulet, etc.) make sure to omit `waitForFirstWindow`"],"parameters":[" * app - a string describing the application to open; it can be: - the application's name as per `hs.application:name()` - the full path to an application on disk (including the `.app` suffix) - the application's bundle ID as per `hs.application:bundleID()`"," * wait - (optional) the maximum number of seconds to wait for the app to be launched, if not already running; if omitted, defaults to 0; if the app takes longer than this to launch, this function will return `nil`, but the app will still launch"," * waitForFirstWindow - (optional) if `true`, additionally wait until the app has spawned its first window (which usually takes a bit longer)"],"returns":[" * the `hs.application` object for the launched or activated application; `nil` if not found"],"signature":"hs.application.open(app[, wait, [waitForFirstWindow]]) -> hs.application object","stripped_doc":"","type":"Constructor"},"path":{"def":"hs.application:path() -> string","desc":"Returns the filesystem path of the app.","doc":"Returns the filesystem path of the app.\n\nParameters:\n * None\n\nReturns:\n * A string containing the filesystem path of the application or nil if the path could not be determined (e.g. if the application has terminated).","examples":[],"file":"extensions/application/libapplication.m","lineno":"302","name":"path","notes":[],"parameters":[" * None"],"returns":[" * A string containing the filesystem path of the application or nil if the path could not be determined (e.g. if the application has terminated)."],"signature":"hs.application:path() -> string","stripped_doc":"","type":"Method"},"pathForBundleID":{"def":"hs.application.pathForBundleID(bundleID) -> string or nil","desc":"Gets the filesystem path of an application from its bundle identifier","doc":"Gets the filesystem path of an application from its bundle identifier\n\nParameters:\n * bundleID - A string containing an application bundle identifier (e.g. \"com.apple.Safari\")\n\nReturns:\n * A string containing the app bundle's filesystem path, or nil if the bundle identifier could not be located","examples":[],"file":"extensions/application/libapplication.m","lineno":"103","name":"pathForBundleID","notes":[],"parameters":[" * bundleID - A string containing an application bundle identifier (e.g. \"com.apple.Safari\")"],"returns":[" * A string containing the app bundle's filesystem path, or nil if the bundle identifier could not be located"],"signature":"hs.application.pathForBundleID(bundleID) -> string or nil","stripped_doc":"","type":"Function"},"pid":{"def":"hs.application:pid() -> number","desc":"Returns the app's process identifier.","doc":"Returns the app's process identifier.\n\nParameters:\n * None\n\nReturns:\n * The UNIX process identifier of the application (i.e. a number)","examples":[],"file":"extensions/application/libapplication.m","lineno":"466","name":"pid","notes":[],"parameters":[" * None"],"returns":[" * The UNIX process identifier of the application (i.e. a number)"],"signature":"hs.application:pid() -> number","stripped_doc":"","type":"Method"},"runningApplications":{"def":"hs.application.runningApplications() -> list of hs.application objects","desc":"Returns all running apps.","doc":"Returns all running apps.\n\nParameters:\n * None\n\nReturns:\n * A table containing zero or more hs.application objects currently running on the system","examples":[],"file":"extensions/application/libapplication.m","lineno":"37","name":"runningApplications","notes":[],"parameters":[" * None"],"returns":[" * A table containing zero or more hs.application objects currently running on the system"],"signature":"hs.application.runningApplications() -> list of hs.application objects","stripped_doc":"","type":"Function"},"selectMenuItem":{"def":"hs.application:selectMenuItem(menuitem[, isRegex]) -> true or nil","desc":"Selects a menu item (i.e. simulates clicking on the menu item)","doc":"Selects a menu item (i.e. simulates clicking on the menu item)\n\nParameters:\n * menuitem - The menu item to select, specified as either a string or a table. See the `menuitem` parameter of `hs.application:findMenuItem()` for more information.\n * isRegex - An optional boolean, defaulting to false, which is only used if `menuItem` is a string. If set to true, `menuItem` will be treated as a regular expression rather than a strict string to match against\n\nReturns:\n * True if the menu item was found and selected, or nil if it wasn't (e.g. because the menu item couldn't be found)\n\nNotes:\n * Depending on the type of menu item involved, this will either activate or tick/untick the menu item","examples":[],"file":"extensions/application/libapplication.m","lineno":"791","name":"selectMenuItem","notes":[" * Depending on the type of menu item involved, this will either activate or tick/untick the menu item"],"parameters":[" * menuitem - The menu item to select, specified as either a string or a table. See the `menuitem` parameter of `hs.application:findMenuItem()` for more information."," * isRegex - An optional boolean, defaulting to false, which is only used if `menuItem` is a string. If set to true, `menuItem` will be treated as a regular expression rather than a strict string to match against"],"returns":[" * True if the menu item was found and selected, or nil if it wasn't (e.g. because the menu item couldn't be found)"],"signature":"hs.application:selectMenuItem(menuitem[, isRegex]) -> true or nil","stripped_doc":"","type":"Method"},"setFrontmost":{"def":"hs.application:setFrontmost([allWindows]) -> boolean","desc":"Sets the app to the frontmost (i.e. currently active) application","doc":"Sets the app to the frontmost (i.e. currently active) application\n\nParameters:\n * allWindows - An optional boolean, true to bring all windows of the application to the front. Defaults to false\n\nReturns:\n * A boolean, true if the operation was successful, otherwise false","examples":[],"file":"extensions/application/libapplication.m","lineno":"443","name":"setFrontmost","notes":[],"parameters":[" * allWindows - An optional boolean, true to bring all windows of the application to the front. Defaults to false"],"returns":[" * A boolean, true if the operation was successful, otherwise false"],"signature":"hs.application:setFrontmost([allWindows]) -> boolean","stripped_doc":"","type":"Method"},"title":{"def":"hs.application:title() -> string","desc":"Returns the localized name of the app (in UTF8).","doc":"Returns the localized name of the app (in UTF8).\n\nParameters:\n * None\n\nReturns:\n * A string containing the name of the application","examples":[],"file":"extensions/application/libapplication.m","lineno":"268","name":"title","notes":[],"parameters":[" * None"],"returns":[" * A string containing the name of the application"],"signature":"hs.application:title() -> string","stripped_doc":"","type":"Method"},"unhide":{"def":"hs.application:unhide() -> boolean","desc":"Unhides the app (and all its windows) if it's hidden.","doc":"Unhides the app (and all its windows) if it's hidden.\n\nParameters:\n * None\n\nReturns:\n * A boolean indicating whether the application was successfully unhidden","examples":[],"file":"extensions/application/libapplication.m","lineno":"339","name":"unhide","notes":[],"parameters":[" * None"],"returns":[" * A boolean indicating whether the application was successfully unhidden"],"signature":"hs.application:unhide() -> boolean","stripped_doc":"","type":"Method"},"visibleWindows":{"def":"hs.application:visibleWindows() -> win[]","desc":"Returns only the app's windows that are visible.","doc":"Returns only the app's windows that are visible.\n\nParameters:\n * None\n\nReturns:\n * A table containing zero or more hs.window objects","examples":[],"file":"extensions/application/application.lua","lineno":"46","name":"visibleWindows","notes":[],"parameters":[" * None"],"returns":[" * A table containing zero or more hs.window objects"],"signature":"hs.application:visibleWindows() -> win[]","stripped_doc":"","type":"Method"}}