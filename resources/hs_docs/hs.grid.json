{"adjustWindow":{"def":"hs.grid.adjustWindow(fn, window) -> hs.grid","desc":"Calls a user specified function to adjust a window's cell","doc":"Calls a user specified function to adjust a window's cell\n\nParameters:\n * fn - a function that accepts a cell object as its only argument. The function should modify it as needed and return nothing\n * window - an `hs.window` object to act on; if omitted, the focused or frontmost window will be used\n\nReturns:\n * the `hs.grid` module for method chaining","examples":[],"file":"extensions/grid/grid.lua","lineno":"372","name":"adjustWindow","notes":[],"parameters":[" * fn - a function that accepts a cell object as its only argument. The function should modify it as needed and return nothing"," * window - an `hs.window` object to act on; if omitted, the focused or frontmost window will be used"],"returns":[" * the `hs.grid` module for method chaining"],"signature":"hs.grid.adjustWindow(fn, window) -> hs.grid","stripped_doc":"","type":"Function"},"get":{"def":"hs.grid.get(win) -> cell","desc":"Gets the cell describing a window","doc":"Gets the cell describing a window\n\nParameters:\n * an `hs.window` object to get the cell of\n\nReturns:\n * a cell object (i.e. an `hs.geometry` rect), or nil if an error occurred","examples":[],"file":"extensions/grid/grid.lua","lineno":"243","name":"get","notes":[],"parameters":[" * an `hs.window` object to get the cell of"],"returns":[" * a cell object (i.e. an `hs.geometry` rect), or nil if an error occurred"],"signature":"hs.grid.get(win) -> cell","stripped_doc":"","type":"Function"},"getCell":{"def":"hs.grid.getCell(cell, screen) -> hs.geometry","desc":"Gets the `hs.geometry` rect for a cell on a particular screen","doc":"Gets the `hs.geometry` rect for a cell on a particular screen\n\nParameters:\n * cell - a cell object, i.e. an `hs.geometry` rect or argument to construct one\n * screen - an `hs.screen` object or argument to `hs.screen.find()` where the cell is located\n\nReturns:\n * the `hs.geometry` rect for a cell on a particular screen or nil if the screen isn't found","examples":[],"file":"extensions/grid/grid.lua","lineno":"266","name":"getCell","notes":[],"parameters":[" * cell - a cell object, i.e. an `hs.geometry` rect or argument to construct one"," * screen - an `hs.screen` object or argument to `hs.screen.find()` where the cell is located"],"returns":[" * the `hs.geometry` rect for a cell on a particular screen or nil if the screen isn't found"],"signature":"hs.grid.getCell(cell, screen) -> hs.geometry","stripped_doc":"","type":"Function"},"getGrid":{"def":"hs.grid.getGrid(screen) -> hs.geometry size","desc":"Gets the defined grid size for a given screen or screen resolution","doc":"Gets the defined grid size for a given screen or screen resolution\n\nParameters:\n * screen - an `hs.screen` object, or a valid argument to `hs.screen.find()`, indicating the screen to get the grid of;\n   if omitted or nil, gets the default grid, which is used when no specific grid is found for any given screen/resolution\n\nReturns:\n  * an `hs.geometry` size object indicating the number of columns and rows in the grid\n\nNotes:\n  * if a grid was not set for the specified screen or geometry, the default grid will be returned\n\nUsage:\nlocal mygrid = hs.grid.getGrid('1920x1080') -- gets the defined grid for all screens with a 1920x1080 resolution\nlocal defgrid=hs.grid.getGrid() defgrid.w=defgrid.w+2 -- increases the number of columns in the default grid by 2","examples":[],"file":"extensions/grid/grid.lua","lineno":"117","name":"getGrid","notes":["  * if a grid was not set for the specified screen or geometry, the default grid will be returned","","Usage:","local mygrid = hs.grid.getGrid('1920x1080') -- gets the defined grid for all screens with a 1920x1080 resolution","local defgrid=hs.grid.getGrid() defgrid.w=defgrid.w+2 -- increases the number of columns in the default grid by 2"],"parameters":[" * screen - an `hs.screen` object, or a valid argument to `hs.screen.find()`, indicating the screen to get the grid of; if omitted or nil, gets the default grid, which is used when no specific grid is found for any given screen/resolution"],"returns":["  * an `hs.geometry` size object indicating the number of columns and rows in the grid"],"signature":"hs.grid.getGrid(screen) -> hs.geometry size","stripped_doc":"Usage:\nlocal mygrid = hs.grid.getGrid('1920x1080') -- gets the defined grid for all screens with a 1920x1080 resolution\nlocal defgrid=hs.grid.getGrid() defgrid.w=defgrid.w+2 -- increases the number of columns in the default grid by 2","type":"Function"},"getGridFrame":{"def":"hs.grid.getGridFrame(screen) -> hs.geometry rect","desc":"Gets the defined grid frame for a given screen or screen resolution.","doc":"Gets the defined grid frame for a given screen or screen resolution.\n\nParameters:\n * screen - an `hs.screen` object, or a valid argument to `hs.screen.find()`, indicating the screen to get the grid frame of\n\nReturns:\n  * an `hs.geometry` rect object indicating the frame used by the grid for the given screen; if no custom frame\n    was given via `hs.grid.setGrid()`, returns the screen's frame","examples":[],"file":"extensions/grid/grid.lua","lineno":"154","name":"getGridFrame","notes":[],"parameters":[" * screen - an `hs.screen` object, or a valid argument to `hs.screen.find()`, indicating the screen to get the grid frame of"],"returns":["  * an `hs.geometry` rect object indicating the frame used by the grid for the given screen; if no custom frame","    was given via `hs.grid.setGrid()`, returns the screen's frame"],"signature":"hs.grid.getGridFrame(screen) -> hs.geometry rect","stripped_doc":"","type":"Function"},"hide":{"def":"hs.grid.hide()","desc":"Hides the grid, if visible, and exits the modal resizing mode.","doc":"Hides the grid, if visible, and exits the modal resizing mode.\n\nParameters:\n * None\n\nReturns:\n * None\n\nNotes:\n * Call this function if you need to make sure the modal is exited without waiting for the user to press `esc`.\n * If an exit callback was provided when invoking the modal interface, calling `.hide()` will call it","examples":[],"file":"extensions/grid/grid.lua","lineno":"207","name":"hide","notes":[" * Call this function if you need to make sure the modal is exited without waiting for the user to press `esc`."," * If an exit callback was provided when invoking the modal interface, calling `.hide()` will call it"],"parameters":[" * None"],"returns":[" * None"],"signature":"hs.grid.hide()","stripped_doc":"","type":"Function"},"HINTS":{"def":"hs.grid.HINTS","desc":"A bidimensional array (table of tables of strings) holding the keyboard hints (as per `hs.keycodes.map`) to be used for the interactive resizing interface.","doc":"A bidimensional array (table of tables of strings) holding the keyboard hints (as per `hs.keycodes.map`) to be used for the interactive resizing interface.\nChange this if you don't use a QWERTY layout; you need to provide 5 valid rows of hints (even if you're not going to use all 5 rows)\n\nDefault `HINTS` is an array to 5 rows and 10 columns.\n\nNotes:\n * `hs.inspect(hs.grid.HINTS)` from the console will show you how the table is built\n * `hs.grid.show()`\n    When displaying interactive grid, if gird dimensions (`hs.grid.setGrid()`) are greater than `HINTS` dimensions,\n    then Hammerspoon merges few cells such that interactive grid dimensions do not exceed `HINTS` dimensions.\n    This is done to make sure interactive grid cells do not run out of hints. The interactive grid ends up with\n    cells of varying height and width.\n    The actual grid is not affected. If you use API methods like `hs.grid.pushWindowDown()`, you will not face this\n    issue at all.\n    If you have a grid of higher dimensions and require an interactive gird that accurately models underlying grid\n    then set `HINTS` variable to a table that has same dimensions as your grid.\n    Following is an example of grid that has 16 columns\n\n```\nhs.grid.setGrid('16x4')\nhs.grid.HINTS={\n    {'f1', 'f2' , 'f3' , 'f4' , 'f5', 'f6', 'f7', 'f8', 'f9', 'f10', 'f11', 'f12', 'f13', 'f14', 'f15', 'f16'},\n    {'1' , 'f11', 'f15', 'f19', 'f3', '=' , ']' , '2' , '3' , '4'  , '5'  , '6'  , '7'  , '8'  , '9'  , '0'  },\n    {'Q' , 'f12', 'f16', 'f20', 'f4', '-' , '[' , 'W' , 'E' , 'R'  , 'T'  , 'Y'  , 'U'  , 'I'  , 'O'  , 'P'  },\n    {'A' , 'f13', 'f17', 'f1' , 'f5', 'f7', '\\\\', 'S' , 'D' , 'F'  , 'G'  , 'H'  , 'J'  , 'K'  , 'L'  , ','  },\n    {'X' , 'f14', 'f18', 'f2' , 'f6', 'f8', ';' , '/' , '.' , 'Z'  , 'X'  , 'C'  , 'V'  , 'B'  , 'N'  , 'M'  }\n}\n```\n","file":"extensions/grid/grid.lua","lineno":"601","name":"HINTS","notes":[" * `hs.inspect(hs.grid.HINTS)` from the console will show you how the table is built"," * `hs.grid.show()`","    When displaying interactive grid, if gird dimensions (`hs.grid.setGrid()`) are greater than `HINTS` dimensions,","    then Hammerspoon merges few cells such that interactive grid dimensions do not exceed `HINTS` dimensions.","    This is done to make sure interactive grid cells do not run out of hints. The interactive grid ends up with","    cells of varying height and width.","    The actual grid is not affected. If you use API methods like `hs.grid.pushWindowDown()`, you will not face this","    issue at all.","    If you have a grid of higher dimensions and require an interactive gird that accurately models underlying grid","    then set `HINTS` variable to a table that has same dimensions as your grid.","    Following is an example of grid that has 16 columns","","```","hs.grid.setGrid('16x4')","hs.grid.HINTS={","    {'f1', 'f2' , 'f3' , 'f4' , 'f5', 'f6', 'f7', 'f8', 'f9', 'f10', 'f11', 'f12', 'f13', 'f14', 'f15', 'f16'},","    {'1' , 'f11', 'f15', 'f19', 'f3', '=' , ']' , '2' , '3' , '4'  , '5'  , '6'  , '7'  , '8'  , '9'  , '0'  },","    {'Q' , 'f12', 'f16', 'f20', 'f4', '-' , '[' , 'W' , 'E' , 'R'  , 'T'  , 'Y'  , 'U'  , 'I'  , 'O'  , 'P'  },","    {'A' , 'f13', 'f17', 'f1' , 'f5', 'f7', '\\\\', 'S' , 'D' , 'F'  , 'G'  , 'H'  , 'J'  , 'K'  , 'L'  , ','  },","    {'X' , 'f14', 'f18', 'f2' , 'f6', 'f8', ';' , '/' , '.' , 'Z'  , 'X'  , 'C'  , 'V'  , 'B'  , 'N'  , 'M'  }","}","```"],"signature":"hs.grid.HINTS","stripped_doc":"Change this if you don't use a QWERTY layout; you need to provide 5 valid rows of hints (even if you're not going to use all 5 rows)\nDefault `HINTS` is an array to 5 rows and 10 columns.\n```\nhs.grid.setGrid('16x4')\nhs.grid.HINTS={\n    {'f1', 'f2' , 'f3' , 'f4' , 'f5', 'f6', 'f7', 'f8', 'f9', 'f10', 'f11', 'f12', 'f13', 'f14', 'f15', 'f16'},\n    {'1' , 'f11', 'f15', 'f19', 'f3', '=' , ']' , '2' , '3' , '4'  , '5'  , '6'  , '7'  , '8'  , '9'  , '0'  },\n    {'Q' , 'f12', 'f16', 'f20', 'f4', '-' , '[' , 'W' , 'E' , 'R'  , 'T'  , 'Y'  , 'U'  , 'I'  , 'O'  , 'P'  },\n    {'A' , 'f13', 'f17', 'f1' , 'f5', 'f7', '\\\\', 'S' , 'D' , 'F'  , 'G'  , 'H'  , 'J'  , 'K'  , 'L'  , ','  },\n    {'X' , 'f14', 'f18', 'f2' , 'f6', 'f8', ';' , '/' , '.' , 'Z'  , 'X'  , 'C'  , 'V'  , 'B'  , 'N'  , 'M'  }\n}\n```","type":"Variable"},"maximizeWindow":{"def":"hs.grid.maximizeWindow(window) -> hs.grid","desc":"Moves and resizes a window to fill the entire grid","doc":"Moves and resizes a window to fill the entire grid\n\nParameters:\n * window - an `hs.window` object to act on; if omitted, the focused or frontmost window will be used\n\nReturns:\n * the `hs.grid` module for method chaining","examples":[],"file":"extensions/grid/grid.lua","lineno":"400","name":"maximizeWindow","notes":[],"parameters":[" * window - an `hs.window` object to act on; if omitted, the focused or frontmost window will be used"],"returns":[" * the `hs.grid` module for method chaining"],"signature":"hs.grid.maximizeWindow(window) -> hs.grid","stripped_doc":"","type":"Function"},"pushWindowDown":{"def":"hs.grid.pushWindowDown(window) -> hs.grid","desc":"Moves a window one grid cell down the screen, or onto the adjacent screen's grid when necessary","doc":"Moves a window one grid cell down the screen, or onto the adjacent screen's grid when necessary\n\nParameters:\n * window - an `hs.window` object to act on; if omitted, the focused or frontmost window will be used\n\nReturns:\n * the `hs.grid` module for method chaining","examples":[],"file":"extensions/grid/grid.lua","lineno":"515","name":"pushWindowDown","notes":[],"parameters":[" * window - an `hs.window` object to act on; if omitted, the focused or frontmost window will be used"],"returns":[" * the `hs.grid` module for method chaining"],"signature":"hs.grid.pushWindowDown(window) -> hs.grid","stripped_doc":"","type":"Function"},"pushWindowLeft":{"def":"hs.grid.pushWindowLeft(window) -> hs.grid","desc":"Moves a window one grid cell to the left, or onto the adjacent screen's grid when necessary","doc":"Moves a window one grid cell to the left, or onto the adjacent screen's grid when necessary\n\nParameters:\n * window - an `hs.window` object to act on; if omitted, the focused or frontmost window will be used\n\nReturns:\n * the `hs.grid` module for method chaining","examples":[],"file":"extensions/grid/grid.lua","lineno":"430","name":"pushWindowLeft","notes":[],"parameters":[" * window - an `hs.window` object to act on; if omitted, the focused or frontmost window will be used"],"returns":[" * the `hs.grid` module for method chaining"],"signature":"hs.grid.pushWindowLeft(window) -> hs.grid","stripped_doc":"","type":"Function"},"pushWindowRight":{"def":"hs.grid.pushWindowRight(window) -> hs.grid","desc":"Moves a window one cell to the right, or onto the adjacent screen's grid when necessary","doc":"Moves a window one cell to the right, or onto the adjacent screen's grid when necessary\n\nParameters:\n * window - an `hs.window` object to act on; if omitted, the focused or frontmost window will be used\n\nReturns:\n * the `hs.grid` module for method chaining","examples":[],"file":"extensions/grid/grid.lua","lineno":"454","name":"pushWindowRight","notes":[],"parameters":[" * window - an `hs.window` object to act on; if omitted, the focused or frontmost window will be used"],"returns":[" * the `hs.grid` module for method chaining"],"signature":"hs.grid.pushWindowRight(window) -> hs.grid","stripped_doc":"","type":"Function"},"pushWindowUp":{"def":"hs.grid.pushWindowUp(window) -> hs.grid","desc":"Moves a window one grid cell up the screen, or onto the adjacent screen's grid when necessary","doc":"Moves a window one grid cell up the screen, or onto the adjacent screen's grid when necessary\n\nParameters:\n * window - an `hs.window` object to act on; if omitted, the focused or frontmost window will be used\n\nReturns:\n * the `hs.grid` module for method chaining","examples":[],"file":"extensions/grid/grid.lua","lineno":"540","name":"pushWindowUp","notes":[],"parameters":[" * window - an `hs.window` object to act on; if omitted, the focused or frontmost window will be used"],"returns":[" * the `hs.grid` module for method chaining"],"signature":"hs.grid.pushWindowUp(window) -> hs.grid","stripped_doc":"","type":"Function"},"resizeWindowShorter":{"def":"hs.grid.resizeWindowShorter(window) -> hs.grid","desc":"Resizes a window so its bottom edge moves one grid cell higher","doc":"Resizes a window so its bottom edge moves one grid cell higher\n\nParameters:\n * window - an `hs.window` object to act on; if omitted, the focused or frontmost window will be used\n\nReturns:\n * the `hs.grid` module for method chaining","examples":[],"file":"extensions/grid/grid.lua","lineno":"564","name":"resizeWindowShorter","notes":[],"parameters":[" * window - an `hs.window` object to act on; if omitted, the focused or frontmost window will be used"],"returns":[" * the `hs.grid` module for method chaining"],"signature":"hs.grid.resizeWindowShorter(window) -> hs.grid","stripped_doc":"","type":"Function"},"resizeWindowTaller":{"def":"hs.grid.resizeWindowTaller(window) -> hs.grid","desc":"Resizes a window so its bottom edge moves one grid cell lower","doc":"Resizes a window so its bottom edge moves one grid cell lower\n\nParameters:\n * window - an `hs.window` object to act on; if omitted, the focused or frontmost window will be used\n\nReturns:\n * the `hs.grid` module for method chaining\n\nNotes:\n * if the window hits the bottom edge of the screen and is asked to become taller, its top edge will shift further up","examples":[],"file":"extensions/grid/grid.lua","lineno":"577","name":"resizeWindowTaller","notes":[" * if the window hits the bottom edge of the screen and is asked to become taller, its top edge will shift further up"],"parameters":[" * window - an `hs.window` object to act on; if omitted, the focused or frontmost window will be used"],"returns":[" * the `hs.grid` module for method chaining"],"signature":"hs.grid.resizeWindowTaller(window) -> hs.grid","stripped_doc":"","type":"Function"},"resizeWindowThinner":{"def":"hs.grid.resizeWindowThinner(window) -> hs.grid","desc":"Resizes a window to be one cell thinner","doc":"Resizes a window to be one cell thinner\n\nParameters:\n * window - an `hs.window` object to act on; if omitted, the focused or frontmost window will be used\n\nReturns:\n * the `hs.grid` module for method chaining","examples":[],"file":"extensions/grid/grid.lua","lineno":"502","name":"resizeWindowThinner","notes":[],"parameters":[" * window - an `hs.window` object to act on; if omitted, the focused or frontmost window will be used"],"returns":[" * the `hs.grid` module for method chaining"],"signature":"hs.grid.resizeWindowThinner(window) -> hs.grid","stripped_doc":"","type":"Function"},"resizeWindowWider":{"def":"hs.grid.resizeWindowWider(window) -> hs.grid","desc":"Resizes a window to be one cell wider","doc":"Resizes a window to be one cell wider\n\nParameters:\n * window - an `hs.window` object to act on; if omitted, the focused or frontmost window will be used\n\nReturns:\n * the `hs.grid` module for method chaining\n\nNotes:\n * if the window hits the right edge of the screen and is asked to become wider, its left edge will shift further left","examples":[],"file":"extensions/grid/grid.lua","lineno":"479","name":"resizeWindowWider","notes":[" * if the window hits the right edge of the screen and is asked to become wider, its left edge will shift further left"],"parameters":[" * window - an `hs.window` object to act on; if omitted, the focused or frontmost window will be used"],"returns":[" * the `hs.grid` module for method chaining"],"signature":"hs.grid.resizeWindowWider(window) -> hs.grid","stripped_doc":"","type":"Function"},"set":{"def":"hs.grid.set(win, cell, screen) -> hs.grid","desc":"Sets the cell for a window on a particular screen","doc":"Sets the cell for a window on a particular screen\n\nParameters:\n * win - an `hs.window` object representing the window to operate on\n * cell - a cell object, i.e. an `hs.geometry` rect or argument to construct one, to apply to the window\n * screen - (optional) an `hs.screen` object or argument to `hs.screen.find()` representing the screen to place the window on; if omitted\n   the window's current screen will be used\n\nReturns:\n * the `hs.grid` module for method chaining","examples":[],"file":"extensions/grid/grid.lua","lineno":"295","name":"set","notes":[],"parameters":[" * win - an `hs.window` object representing the window to operate on"," * cell - a cell object, i.e. an `hs.geometry` rect or argument to construct one, to apply to the window"," * screen - (optional) an `hs.screen` object or argument to `hs.screen.find()` representing the screen to place the window on; if omitted the window's current screen will be used"],"returns":[" * the `hs.grid` module for method chaining"],"signature":"hs.grid.set(win, cell, screen) -> hs.grid","stripped_doc":"","type":"Function"},"setGrid":{"def":"hs.grid.setGrid(grid,screen,frame) -> hs.grid","desc":"Sets the grid size for a given screen or screen resolution","doc":"Sets the grid size for a given screen or screen resolution\n\nParameters:\n * grid - an `hs.geometry` size, or argument to construct one, indicating the number of columns and rows for the grid\n * screen - an `hs.screen` object, or a valid argument to `hs.screen.find()`, indicating the screen(s) to apply the grid to;\n   if omitted or nil, sets the default grid, which is used when no specific grid is found for any given screen/resolution\n * frame - an `hs.geometry` rect object indicating the frame that the grid will occupy for the given screen;\n   if omitted or nil, the screen's `:frame()` will be used; use this argument if you want e.g. to leave\n   a strip of the desktop unoccluded when using GeekTool or similar. The `screen` argument *must* be non-nil when setting a\n   custom grid frame.\n\nReturns:\n * the `hs.grid` module for method chaining\n\nExamples:\n * hs.grid.setGrid('5x3','Color LCD') -- sets the grid to 5x3 for any screen named \"Color LCD\"\n * hs.grid.setGrid('8x5','1920x1080') -- sets the grid to 8x5 for all screens with a 1920x1080 resolution\n * hs.grid.setGrid'4x4' -- sets the default grid to 4x4","examples":[" * hs.grid.setGrid('5x3','Color LCD') -- sets the grid to 5x3 for any screen named \"Color LCD\""," * hs.grid.setGrid('8x5','1920x1080') -- sets the grid to 8x5 for all screens with a 1920x1080 resolution"," * hs.grid.setGrid'4x4' -- sets the default grid to 4x4"],"file":"extensions/grid/grid.lua","lineno":"48","name":"setGrid","notes":[],"parameters":[" * grid - an `hs.geometry` size, or argument to construct one, indicating the number of columns and rows for the grid"," * screen - an `hs.screen` object, or a valid argument to `hs.screen.find()`, indicating the screen(s) to apply the grid to; if omitted or nil, sets the default grid, which is used when no specific grid is found for any given screen/resolution"," * frame - an `hs.geometry` rect object indicating the frame that the grid will occupy for the given screen; if omitted or nil, the screen's `:frame()` will be used; use this argument if you want e.g. to leave a strip of the desktop unoccluded when using GeekTool or similar. The `screen` argument *must* be non-nil when setting a custom grid frame."],"returns":[" * the `hs.grid` module for method chaining"],"signature":"hs.grid.setGrid(grid,screen,frame) -> hs.grid","stripped_doc":"","type":"Function"},"setMargins":{"def":"hs.grid.setMargins(margins) -> hs.grid","desc":"Sets the margins between windows","doc":"Sets the margins between windows\n\nParameters:\n * margins - an `hs.geometry` point or size, or argument to construct one, indicating the desired margins between windows in screen points\n\nReturns:\n  * the `hs.grid` module for method chaining","examples":[],"file":"extensions/grid/grid.lua","lineno":"98","name":"setMargins","notes":[],"parameters":[" * margins - an `hs.geometry` point or size, or argument to construct one, indicating the desired margins between windows in screen points"],"returns":["  * the `hs.grid` module for method chaining"],"signature":"hs.grid.setMargins(margins) -> hs.grid","stripped_doc":"","type":"Function"},"show":{"def":"hs.grid.show([exitedCallback][, multipleWindows])","desc":"Shows the grid and starts the modal interactive resizing process for the focused or frontmost window.","doc":"Shows the grid and starts the modal interactive resizing process for the focused or frontmost window.\n\nParameters:\n * exitedCallback - (optional) a function that will be called after the user dismisses the modal interface\n * multipleWindows - (optional) if `true`, the resizing grid won't automatically go away after selecting the desired cells for the frontmost window; instead, it'll switch to the next window\n\nReturns:\n * None\n\nNotes:\n * In most cases this function should be invoked via `hs.hotkey.bind` with some keyboard shortcut.\n * In the modal interface, press the arrow keys to jump to adjacent screens; spacebar to maximize/unmaximize; esc to quit without any effect\n * Pressing `tab` or `shift-tab` in the modal interface will cycle to the next or previous window; if `multipleWindows`\n   is false or omitted, the first press will just enable the multiple windows behaviour\n * The keyboard hints assume a QWERTY layout; if you use a different layout, change `hs.grid.HINTS` accordingly\n * If grid dimensions are greater than 10x10 then you may have to change `hs.grid.HINTS` depending on your\n   requirements. See note in `HINTS`.","examples":[],"file":"extensions/grid/grid.lua","lineno":"187","name":"show","notes":[" * In most cases this function should be invoked via `hs.hotkey.bind` with some keyboard shortcut."," * In the modal interface, press the arrow keys to jump to adjacent screens; spacebar to maximize/unmaximize; esc to quit without any effect"," * Pressing `tab` or `shift-tab` in the modal interface will cycle to the next or previous window; if `multipleWindows`","   is false or omitted, the first press will just enable the multiple windows behaviour"," * The keyboard hints assume a QWERTY layout; if you use a different layout, change `hs.grid.HINTS` accordingly"," * If grid dimensions are greater than 10x10 then you may have to change `hs.grid.HINTS` depending on your","   requirements. See note in `HINTS`."],"parameters":[" * exitedCallback - (optional) a function that will be called after the user dismisses the modal interface"," * multipleWindows - (optional) if `true`, the resizing grid won't automatically go away after selecting the desired cells for the frontmost window; instead, it'll switch to the next window"],"returns":[" * None"],"signature":"hs.grid.show([exitedCallback][, multipleWindows])","stripped_doc":"","type":"Function"},"snap":{"def":"hs.grid.snap(win) -> hs.grid","desc":"Snaps a window into alignment with the nearest grid lines","doc":"Snaps a window into alignment with the nearest grid lines\n\nParameters:\n * win - an `hs.window` object to snap\n\nReturns:\n * the `hs.grid` module for method chaining","examples":[],"file":"extensions/grid/grid.lua","lineno":"353","name":"snap","notes":[],"parameters":[" * win - an `hs.window` object to snap"],"returns":[" * the `hs.grid` module for method chaining"],"signature":"hs.grid.snap(win) -> hs.grid","stripped_doc":"","type":"Function"},"toggleShow":{"def":"hs.grid.toggleShow([exitedCallback][, multipleWindows])","desc":"Toggles the grid and modal resizing mode - see `hs.grid.show()` and `hs.grid.hide()`","doc":"Toggles the grid and modal resizing mode - see `hs.grid.show()` and `hs.grid.hide()`\n\nParameters:\n * exitedCallback - (optional) a function that will be called after the user dismisses the modal interface\n * multipleWindows - (optional) if `true`, the resizing grid won't automatically go away after selecting the desired cells for the frontmost window; instead, it'll switch to the next window\n\nReturns:\n * None","examples":[],"file":"extensions/grid/grid.lua","lineno":"221","name":"toggleShow","notes":[],"parameters":[" * exitedCallback - (optional) a function that will be called after the user dismisses the modal interface"," * multipleWindows - (optional) if `true`, the resizing grid won't automatically go away after selecting the desired cells for the frontmost window; instead, it'll switch to the next window"],"returns":[" * None"],"signature":"hs.grid.toggleShow([exitedCallback][, multipleWindows])","stripped_doc":"","type":"Function"},"ui":{"def":"hs.grid.ui","desc":"Allows customization of the modal resizing grid user interface","doc":"Allows customization of the modal resizing grid user interface\n\nThis table contains variables that you can change to customize the look of the modal resizing grid.\nThe default values are shown in the right hand side of the assignements below.\n\nTo represent color values, you can use:\n * a table {red=redN, green=greenN, blue=blueN, alpha=alphaN}\n * a table {redN,greenN,blueN[,alphaN]} - if omitted alphaN defaults to 1.0\nwhere redN, greenN etc. are the desired value for the color component between 0.0 and 1.0\n\nThe following variables must be color values:\n * `hs.grid.ui.textColor = {1,1,1}`\n * `hs.grid.ui.cellColor = {0,0,0,0.25}`\n * `hs.grid.ui.cellStrokeColor = {0,0,0}`\n * `hs.grid.ui.selectedColor = {0.2,0.7,0,0.4}` -- for the first selected cell during a modal resize\n * `hs.grid.ui.highlightColor = {0.8,0.8,0,0.5}` -- to highlight the frontmost window behind the grid\n * `hs.grid.ui.highlightStrokeColor = {0.8,0.8,0,1}`\n * `hs.grid.ui.cyclingHighlightColor = {0,0.8,0.8,0.5}` -- to highlight the window to be resized, when cycling among windows\n * `hs.grid.ui.cyclingHighlightStrokeColor = {0,0.8,0.8,1}`\n\nThe following variables must be numbers (in screen points):\n * `hs.grid.ui.textSize = 200`\n * `hs.grid.ui.cellStrokeWidth = 5`\n * `hs.grid.ui.highlightStrokeWidth = 30`\n\nThe following variables must be strings:\n * `hs.grid.ui.fontName = 'Lucida Grande'`\n\nThe following variables must be booleans:\n * `hs.grid.ui.showExtraKeys = true` -- show non-grid keybindings in the center of the grid","file":"extensions/grid/grid.lua","lineno":"650","name":"ui","signature":"hs.grid.ui","stripped_doc":"This table contains variables that you can change to customize the look of the modal resizing grid.\nThe default values are shown in the right hand side of the assignements below.\nTo represent color values, you can use:\n * a table {red=redN, green=greenN, blue=blueN, alpha=alphaN}\n * a table {redN,greenN,blueN[,alphaN]} - if omitted alphaN defaults to 1.0\nwhere redN, greenN etc. are the desired value for the color component between 0.0 and 1.0\nThe following variables must be color values:\n * `hs.grid.ui.textColor = {1,1,1}`\n * `hs.grid.ui.cellColor = {0,0,0,0.25}`\n * `hs.grid.ui.cellStrokeColor = {0,0,0}`\n * `hs.grid.ui.selectedColor = {0.2,0.7,0,0.4}` -- for the first selected cell during a modal resize\n * `hs.grid.ui.highlightColor = {0.8,0.8,0,0.5}` -- to highlight the frontmost window behind the grid\n * `hs.grid.ui.highlightStrokeColor = {0.8,0.8,0,1}`\n * `hs.grid.ui.cyclingHighlightColor = {0,0.8,0.8,0.5}` -- to highlight the window to be resized, when cycling among windows\n * `hs.grid.ui.cyclingHighlightStrokeColor = {0,0.8,0.8,1}`\nThe following variables must be numbers (in screen points):\n * `hs.grid.ui.textSize = 200`\n * `hs.grid.ui.cellStrokeWidth = 5`\n * `hs.grid.ui.highlightStrokeWidth = 30`\nThe following variables must be strings:\n * `hs.grid.ui.fontName = 'Lucida Grande'`\nThe following variables must be booleans:\n * `hs.grid.ui.showExtraKeys = true` -- show non-grid keybindings in the center of the grid","type":"Variable"}}