{"filter":{"type":"Module","doc":"Filter windows by application, title, location on screen and more, and easily subscribe to events on these windows\n\nWarning: this module is still somewhat experimental.\nShould you encounter any issues, please feel free to report them on https://github.com/Hammerspoon/hammerspoon/issues\nor #hammerspoon on irc.libera.chat.\n\nWindowfilters monitor all windows as they're created, closed, moved etc., and select some (or none) among these windows\naccording to specific filtering rules. These filtering rules are app-specific, i.e. they start off by selecting all windows\nbelonging to a certain application (but you can also define *default* and *override* filters - see `:setAppFilter()`,\n`:setDefaultFilter()`, `:setOverrideFilter()`) and they can allow or reject windows based on:\n  * visibility, focused and/or fullscreen status\n  * title length or patterns in the title\n  * position on screen (inside or outside a certain region or screen)\n  * accessibility role (standard window, dialog, etc.)\n  * whether they're in the current Mission Control Space or not\n\nThe filtering happens automatically in the background; windowfilters then:\n  * generate a dynamic list of the windows that currently satisfy the filtering rules (see `:getWindows()`)\n  * sanitize and expose all pertinent events on these windows (see `:subscribe()` and the module constants with all the events)\n\nA *default windowfilter* (not to be confused with the default filter *within* a windowfilter) is provided as convenience;\nit excludes some known apps and windows that are transient in nature, therefore unlikely to be \"interesting\" for e.g. window management.\n`hs.window.filter.new()` (with no arguments) returns a copy of the default windowfilter that you can further tailor\nto your needs - see `hs.window.filter.default` and `hs.window.filter.new()` for more information.\n\nUsage examples:\n```\nlocal wf=hs.window.filter\n\n-- alter the default windowfilter\nwf.default:setAppFilter('My IDE',{allowTitles=1}) -- ignore no-title windows (e.g. transient autocomplete suggestions) in My IDE\n\n-- set the exact scope of what you're interested in - see hs.window.filter:setAppFilter()\nwf_terminal = wf.new{'Terminal','iTerm2'} -- all visible terminal windows\nwf_timewaster = wf.new(false):setAppFilter('Safari',{allowTitles='reddit'}) -- any Safari windows with \"reddit\" anywhere in the title\nwf_leftscreen = wf.new{override={visible=true,fullscreen=false,allowScreens='-1,0',currentSpace=true}}\n-- all visible and non-fullscreen windows that are on the screen to the left of the primary screen in the current Space\nwf_editors_righthalf = wf.new{'TextEdit','Sublime Text','BBEdit'}:setRegions(hs.screen.primaryScreen():fromUnitRect'0.5,0/1,1')\n-- text editor windows that are on the right half of the primary screen\nwf_bigwindows = wf.new(function(w)return w:frame().area>3000000 end) -- only very large windows\nwf_notif = wf.new{['Notification Center']={allowRoles='AXNotificationCenterAlert'}} -- notification center alerts\n\n-- subscribe to events\nwf_terminal:subscribe(wf.windowFocused,some_fn) -- run a function whenever a terminal window is focused\nwf_timewaster:subscribe(wf.hasWindow,startAnnoyingMe):subscribe(wf.hasNoWindows,stopAnnoyingMe) -- fight procrastination :)\n```","def":"-> hs.window.filter"},"highlight":{"type":"Module","doc":"Highlight the focused window\n\nThis module can be useful to spatially keep track of windows if you have large and/or multiple screens, and are\ntherefore likely to have several windows visible at any given time.\nIt highlights the currently focused window by covering other windows and the desktop with either a subtle\n(\"overlay\" mode) or opaque (\"isolate\" mode) overlay; additionally it can highlight windows as they're shown\nor hidden via a brief flash, to help determine their location intuitively (to avoid having to studiously scan\nall your screens when, for example, you know you triggered a dialog but it didn't show up where you expected it).\n\nBy default, overlay mode is disabled - you can enable it with `hs.window.highlight.ui.overlay=true` - and so are\nthe window shown/hidden flashes - enable those with `hs.window.highlight.ui.flashDuration=0.3` (or whatever duration\nyou prefer). Isolate mode is always available and can be toggled manually via `hs.window.highlight.toggleIsolate()`\nor automatically by passing an appropriate windowfilter (or a list of apps) to `hs.window.highlight.start()`.","def":"-> hs.window.highlight"},"layout":{"type":"Module","doc":"**WARNING**: EXPERIMENTAL MODULE. DO **NOT** USE IN PRODUCTION.\nThis module is *for testing purposes only*. It can undergo breaking API changes or *go away entirely* **at any point and without notice**.\n(Should you encounter any issues, please feel free to report them on https://github.com/Hammerspoon/hammerspoon/issues\nor #hammerspoon on irc.libera.chat)\n\nWindow management\n\nWindowlayouts work by selecting certain windows via windowfilters and arranging them onscreen according to specific rules.\n\nA **layout** is composed of a list of rules and, optionally, a screen arrangement definition.\nRules within a layout are evaluated in order; once a window is acted upon by a rule, subsequent rules will not affect it further.\nA **rule** needs a **windowfilter**, producing a dynamic list of windows (the \"window pool\") to which the rule is applied,\nand a list of commands, evaluated in order.\nA **command** acts on one or more of the windows, and is composed of:\n* an **action**, it can be\n  - `move`: moves the window(s) to a specified onscreen rect (if the action is omitted, `move` is assumed)\n  - `minimize`, `maximize`, `fullscreen`\n  - `tile`, `fit`: tiles the windows onto a specified rect, using `hs.window.tiling.tileWindows()`; for `fit`, the\n    `preserveRelativeArea` parameter will be set to true\n  - `hide`, `unhide`: hides or unhides the window's application (like when using cmd-h)\n  - `noaction`: skip action on the window(s)\n* a **maxn** number, indicating how many windows from this rule's window pool will be affected (at most) by this command;\n  if omitted (or if explicitly the string `all`) all the remaining windows will be processed by this command; processed\n  windows are \"consumed\" and are excluded from the window pool for subsequent commands in this rule, and from subsequent rules\n* a **selector**, describing the sort order used to pick the first *maxn* windows from the window pool for this command;\n  it can be one of `focused` (pick *maxn* most recently focused windows), `frontmost` (pick the recent focused window if its\n  application is frontmost applicaion, otherwise the command will be skipped), `newest` (most recently created), `oldest`\n  (least recently created), or `closest` (pick the *maxn* windows that are closest to the destination rect); if omitted,\n  defaults to `closest` for move, tile and fit, and `newest` for everything else\n* an `hs.geometry` *size* (only valid for tile and fit) indicating the desired optimal aspect ratio for the tiled windows;\n  if omitted, defaults to 1x1 (i.e. square windows)\n* for move, tile and fit, an `hs.geometry` *rect*, or a *unit rect* plus a *screen hint* (for `hs.screen.find()`),\n  indicating the destination rect for the command\n* for fullscreen and maximize, a *screen hint* indicating the desired screen; if omitted, uses the window's current screen\n\nYou should place higher-priority rules (with highly specialized windowfilters) first, and \"fallback\" rules\n(with more generic windowfilters) last; similarly, *within* a rule, you should have commands for the more \"important\"\n(i.e. relevant to your current workflow) windows first (move, maximize...) and after that deal with less prominent\nwindows, if any remain, e.g. by placing them out of the way (minimize).\n`unhide` and `hide`, if used, should usually go into their own rules (with a windowfilter that allows invisible windows\nfor `unhide`) that come *before* other rules that deal with actual window placement - unlike the other actions,\nthey don't \"consume\" windows making them unavailable for subsequent rules, as they act on applications.\n\nIn order to avoid dealing with deeply nested maps, you can define a layout in your scripts via a list, where each element\n(or row) denotes a rule; in turn every rule can be a simplified list of two elements:\n  - a windowfilter or a constructor argument table for one (see `hs.window.filter.new()` and `hs.window.filter:setFilters()`)\n  - a single string containing all the commands (action and parameters) in order; actions and selectors can be shortened to\n    3 characters; all tokens must be separated by spaces (do not use spaces inside `hs.geometry` constructor strings);\n    for greater clarity you can separate commands with `|` (pipe character)\n\nSome command string examples:\n- `\"move 1 [0,0,50,50] -1,0\"` moves the closest window to the topleft quadrant of the left screen\n- `\"max 0,0\"` maximizes all the windows onto the primary screen, one on top of another\n- `\"move 1 foc [0,0,30,100] 0,0 | tile all foc [30,0,100,100] 0,0\"` moves the most recently focused window to the left third,\nand tiles the remaining windows onto the right side, keeping the most recently focused on top and to the left\n- `\"1 new [0,0,50,100] 0,0 | 1 new [50,0,100,100] 0,0 | min\"` divides the primary screen between the two newest windows\nand minimizes any other windows\n\nEach layout can work in \"passive\" or \"active\" modes; passive layouts must be triggered manually (via `hs.hotkey.bind()`,\n`hs.menubar`, etc.) while active layouts continuously keep their rules enforced (see `hs.window.layout:start()`\nfor more information); in general you should avoid having multiple active layouts targeting the same windows, as the\nresults will be unpredictable (if such a situation is detected, you'll see an error in the Hammerspoon console); you\n*can* have multiple active layouts, but be careful to maintain a clear \"separation of concerns\" between their respective windowfilters.\n\nEach layout can have an associated screen configuration; if so, the layout will only be valid while the current screen\narrangement satisfies it; see `hs.window.layout:setScreenConfiguration()` for more information.","def":"-> hs.window.layout"},"switcher":{"type":"Module","doc":"Window-based cmd-tab replacement\n\nUsage:\n```\n-- set up your windowfilter\nswitcher = hs.window.switcher.new() -- default windowfilter: only visible windows, all Spaces\nswitcher_space = hs.window.switcher.new(hs.window.filter.new():setCurrentSpace(true):setDefaultFilter{}) -- include minimized/hidden windows, current Space only\nswitcher_browsers = hs.window.switcher.new{'Safari','Google Chrome'} -- specialized switcher for your dozens of browser windows :)\n\n-- bind to hotkeys; WARNING: at least one modifier key is required!\nhs.hotkey.bind('alt','tab','Next window',function()switcher:next()end)\nhs.hotkey.bind('alt-shift','tab','Prev window',function()switcher:previous()end)\n\n-- alternatively, call .nextWindow() or .previousWindow() directly (same as hs.window.switcher.new():next())\nhs.hotkey.bind('alt','tab','Next window',hs.window.switcher.nextWindow)\n-- you can also bind to `repeatFn` for faster traversing\nhs.hotkey.bind('alt-shift','tab','Prev window',hs.window.switcher.previousWindow,nil,hs.window.switcher.previousWindow)\n```","def":"-> hs.window.switcher"},"tiling":{"type":"Module","doc":"**WARNING**: EXPERIMENTAL MODULE. DO **NOT** USE IN PRODUCTION.\nThis module is *for testing purposes only*. It can undergo breaking API changes or *go away entirely* **at any point and without notice**.\n(Should you encounter any issues, please feel free to report them on https://github.com/Hammerspoon/hammerspoon/issues\nor #hammerspoon on irc.libera.chat)\n\nTile windows\n\nThe `tileWindows` function in this module is primarily meant for use by `hs.window.layout`; however you can call it manually\n(e.g. for your custom layout engine).","def":"-> hs.window.tiling"},"allWindows":{"def":"hs.window.allWindows() -> list of hs.window objects","desc":"Returns all windows","doc":"Returns all windows\n\nParameters:\n * None\n\nReturns:\n * A list of `hs.window` objects representing all open windows\n\nNotes:\n * `visibleWindows()`, `orderedWindows()`, `get()`, `find()`, and several more functions and methods in this and other\n    modules make use of this function, so it is important to understand its limitations\n * This function queries all applications for their windows every time it is invoked; if you need to call it a lot and\n   performance is not acceptable consider using the `hs.window.filter` module\n * This function can only return windows in the current Mission Control Space; if you need to address windows across\n   different Spaces you can use the `hs.window.filter` module\n   - if `Displays have separate Spaces` is *on* (in System Preferences>Mission Control) the current Space is defined\n     as the union of all currently visible Spaces\n   - minimized windows and hidden windows (i.e. belonging to hidden apps, e.g. via cmd-h) are always considered\n     to be in the current Space\n * This function filters out the desktop \"window\"; use `hs.window.desktop()` to address it. (Note however that\n   `hs.application.get'Finder':allWindows()` *will* include the desktop in the returned list)\n * Beside the limitations discussed above, this function will return *all* windows as reported by OSX, including some\n   \"windows\" that one wouldn't expect: for example, every Google Chrome (actual) window has a companion window for its\n   status bar; therefore you might get unexpected results  - in the Chrome example, calling `hs.window.focusWindowSouth()`\n   from a Chrome window would end up \"focusing\" its status bar, and therefore the proper window itself, seemingly resulting\n   in a no-op. In order to avoid such surprises you can use the `hs.window.filter` module, and more specifically\n   the default windowfilter (`hs.window.filter.default`) which filters out known cases of not-actual-windows\n * Some windows will not be reported by OSX - e.g. things that are on different Spaces, or things that are Full Screen","examples":[],"file":"extensions/window/window.lua","lineno":"54","name":"allWindows","notes":[" * `visibleWindows()`, `orderedWindows()`, `get()`, `find()`, and several more functions and methods in this and other","    modules make use of this function, so it is important to understand its limitations"," * This function queries all applications for their windows every time it is invoked; if you need to call it a lot and","   performance is not acceptable consider using the `hs.window.filter` module"," * This function can only return windows in the current Mission Control Space; if you need to address windows across","   different Spaces you can use the `hs.window.filter` module","   - if `Displays have separate Spaces` is *on* (in System Preferences>Mission Control) the current Space is defined","     as the union of all currently visible Spaces","   - minimized windows and hidden windows (i.e. belonging to hidden apps, e.g. via cmd-h) are always considered","     to be in the current Space"," * This function filters out the desktop \"window\"; use `hs.window.desktop()` to address it. (Note however that","   `hs.application.get'Finder':allWindows()` *will* include the desktop in the returned list)"," * Beside the limitations discussed above, this function will return *all* windows as reported by OSX, including some","   \"windows\" that one wouldn't expect: for example, every Google Chrome (actual) window has a companion window for its","   status bar; therefore you might get unexpected results  - in the Chrome example, calling `hs.window.focusWindowSouth()`","   from a Chrome window would end up \"focusing\" its status bar, and therefore the proper window itself, seemingly resulting","   in a no-op. In order to avoid such surprises you can use the `hs.window.filter` module, and more specifically","   the default windowfilter (`hs.window.filter.default`) which filters out known cases of not-actual-windows"," * Some windows will not be reported by OSX - e.g. things that are on different Spaces, or things that are Full Screen"],"parameters":[" * None"],"returns":[" * A list of `hs.window` objects representing all open windows"],"signature":"hs.window.allWindows() -> list of hs.window objects","stripped_doc":"","type":"Function"},"animationDuration":{"def":"hs.window.animationDuration (number)","desc":"The default duration for animations, in seconds. Initial value is 0.2; set to 0 to disable animations.","doc":"The default duration for animations, in seconds. Initial value is 0.2; set to 0 to disable animations.\n\nUsage:\n```\nhs.window.animationDuration = 0 -- disable animations\nhs.window.animationDuration = 3 -- if you have time on your hands\n```","file":"extensions/window/window.lua","lineno":"21","name":"animationDuration","signature":"hs.window.animationDuration (number)","stripped_doc":"Usage:\n```\nhs.window.animationDuration = 0 -- disable animations\nhs.window.animationDuration = 3 -- if you have time on your hands\n```","type":"Variable"},"application":{"def":"hs.window:application() -> app or nil","desc":"Gets the `hs.application` object the window belongs to","doc":"Gets the `hs.application` object the window belongs to\n\nParameters:\n * None\n\nReturns:\n * An `hs.application` object representing the application that owns the window, or nil if an error occurred","examples":[],"file":"extensions/window/libwindow.m","lineno":"482","name":"application","notes":[],"parameters":[" * None"],"returns":[" * An `hs.application` object representing the application that owns the window, or nil if an error occurred"],"signature":"hs.window:application() -> app or nil","stripped_doc":"","type":"Method"},"becomeMain":{"def":"hs.window:becomeMain() -> window","desc":"Makes the window the main window of its application","doc":"Makes the window the main window of its application\n\nParameters:\n * None\n\nReturns:\n * The `hs.window` object\n\nNotes:\n * Make a window become the main window does not transfer focus to the application. See `hs.window.focus()`","examples":[],"file":"extensions/window/libwindow.m","lineno":"500","name":"becomeMain","notes":[" * Make a window become the main window does not transfer focus to the application. See `hs.window.focus()`"],"parameters":[" * None"],"returns":[" * The `hs.window` object"],"signature":"hs.window:becomeMain() -> window","stripped_doc":"","type":"Method"},"centerOnScreen":{"def":"hs.window:centerOnScreen([screen][, ensureInScreenBounds][, duration]) --> hs.window object","desc":"Centers the window on a screen","doc":"Centers the window on a screen\n\nParameters:\n * screen - (optional) An `hs.screen` object or argument for `hs.screen.find`; if nil, use the screen the window is currently on\n * ensureInScreenBounds - (optional) if `true`, use `setFrameInScreenBounds()` to ensure the resulting window frame is fully contained within\n   the window's screen\n * duration - (optional) The number of seconds to animate the transition. Defaults to the value of `hs.window.animationDuration`\n\nReturns:\n * The `hs.window` object","examples":[],"file":"extensions/window/window.lua","lineno":"864","name":"centerOnScreen","notes":[],"parameters":[" * screen - (optional) An `hs.screen` object or argument for `hs.screen.find`; if nil, use the screen the window is currently on"," * ensureInScreenBounds - (optional) if `true`, use `setFrameInScreenBounds()` to ensure the resulting window frame is fully contained within the window's screen"," * duration - (optional) The number of seconds to animate the transition. Defaults to the value of `hs.window.animationDuration`"],"returns":[" * The `hs.window` object"],"signature":"hs.window:centerOnScreen([screen][, ensureInScreenBounds][, duration]) --> hs.window object","stripped_doc":"","type":"Method"},"close":{"def":"hs.window:close() -> bool","desc":"Closes the window","doc":"Closes the window\n\nParameters:\n * None\n\nReturns:\n * True if the operation succeeded, false if not","examples":[],"file":"extensions/window/libwindow.m","lineno":"324","name":"close","notes":[],"parameters":[" * None"],"returns":[" * True if the operation succeeded, false if not"],"signature":"hs.window:close() -> bool","stripped_doc":"","type":"Method"},"desktop":{"def":"hs.window.desktop() -> hs.window object","desc":"Returns the desktop \"window\"","doc":"Returns the desktop \"window\"\n\nParameters:\n * None\n\nReturns:\n * An `hs.window` object representing the desktop, or nil if Finder is not running\n\nNotes:\n * The desktop belongs to Finder.app: when Finder is the active application, you can focus the desktop by cycling\n   through windows via cmd-`\n * The desktop window has no id, a role of `AXScrollArea` and no subrole\n * The desktop is filtered out from `hs.window.allWindows()` (and downstream uses)","examples":[],"file":"extensions/window/window.lua","lineno":"33","name":"desktop","notes":[" * The desktop belongs to Finder.app: when Finder is the active application, you can focus the desktop by cycling","   through windows via cmd-`"," * The desktop window has no id, a role of `AXScrollArea` and no subrole"," * The desktop is filtered out from `hs.window.allWindows()` (and downstream uses)"],"parameters":[" * None"],"returns":[" * An `hs.window` object representing the desktop, or nil if Finder is not running"],"signature":"hs.window.desktop() -> hs.window object","stripped_doc":"","type":"Function"},"find":{"def":"hs.window.find(hint) -> hs.window object(s)","desc":"Finds windows","doc":"Finds windows\n\nParameters:\n * hint - search criterion for the desired window(s); it can be:\n   - an id number as per `hs.window:id()`\n   - a string pattern that matches (via `string.find`) the window title as per `hs.window:title()` (for convenience, the matching will be done on lowercased strings)\n\nReturns:\n * one or more hs.window objects that match the supplied search criterion, or `nil` if none found\n\nNotes:\n * for convenience you can call this as `hs.window(hint)`\n * see also `hs.window.get`\n * for more sophisticated use cases and/or for better performance if you call this a lot, consider using `hs.window.filter`\n\nUsage:\n```\n-- by id\nhs.window(8812):title() --> Hammerspoon Console\n-- by title\nhs.window'bash':application():name() --> Terminal\n```","examples":[],"file":"extensions/window/window.lua","lineno":"208","name":"find","notes":[" * for convenience you can call this as `hs.window(hint)`"," * see also `hs.window.get`"," * for more sophisticated use cases and/or for better performance if you call this a lot, consider using `hs.window.filter`","","Usage:","```","-- by id","hs.window(8812):title() --> Hammerspoon Console","-- by title","hs.window'bash':application():name() --> Terminal","```"],"parameters":[" * hint - search criterion for the desired window(s); it can be: - an id number as per `hs.window:id()` - a string pattern that matches (via `string.find`) the window title as per `hs.window:title()` (for convenience, the matching will be done on lowercased strings)"],"returns":[" * one or more hs.window objects that match the supplied search criterion, or `nil` if none found"],"signature":"hs.window.find(hint) -> hs.window object(s)","stripped_doc":"Usage:\n```\n-- by id\nhs.window(8812):title() --> Hammerspoon Console\n-- by title\nhs.window'bash':application():name() --> Terminal\n```","type":"Constructor"},"focus":{"def":"hs.window:focus() -> hs.window object","desc":"Focuses the window","doc":"Focuses the window\n\nParameters:\n * None\n\nReturns:\n * The `hs.window` object","examples":[],"file":"extensions/window/window.lua","lineno":"508","name":"focus","notes":[],"parameters":[" * None"],"returns":[" * The `hs.window` object"],"signature":"hs.window:focus() -> hs.window object","stripped_doc":"","type":"Method"},"focusedWindow":{"def":"hs.window.focusedWindow() -> window","desc":"Returns the window that has keyboard/mouse focus","doc":"Returns the window that has keyboard/mouse focus\n\nParameters:\n * None\n\nReturns:\n * An `hs.window` object representing the currently focused window","examples":[],"file":"extensions/window/libwindow.m","lineno":"94","name":"focusedWindow","notes":[],"parameters":[" * None"],"returns":[" * An `hs.window` object representing the currently focused window"],"signature":"hs.window.focusedWindow() -> window","stripped_doc":"","type":"Constructor"},"focusTab":{"def":"hs.window:focusTab(index) -> bool","desc":"Focuses the tab in the window's tab group at index, or the last tab if index is out of bounds","doc":"Focuses the tab in the window's tab group at index, or the last tab if index is out of bounds\n\nParameters:\n * index - A number, a 1-based index of a tab to focus\n\nReturns:\n * true if the tab was successfully pressed, or false if there was a problem\n\nNotes:\n * This method works with document tab groups and some app tabs, like Chrome and Safari.","examples":[],"file":"extensions/window/libwindow.m","lineno":"341","name":"focusTab","notes":[" * This method works with document tab groups and some app tabs, like Chrome and Safari."],"parameters":[" * index - A number, a 1-based index of a tab to focus"],"returns":[" * true if the tab was successfully pressed, or false if there was a problem"],"signature":"hs.window:focusTab(index) -> bool","stripped_doc":"","type":"Method"},"focusWindowEast":{"def":"hs.window:focusWindowEast([candidateWindows[, frontmost[, strict]]]) -> boolean","desc":"Focuses the nearest possible window to the east (i.e. right)","doc":"Focuses the nearest possible window to the east (i.e. right)\n\nParameters:\n * candidateWindows - (optional) a list of candidate windows to consider; if nil, all visible windows\n   to the east are candidates.\n * frontmost - (optional) boolean, if true focuses the nearest window that isn't occluded by any other window\n * strict - (optional) boolean, if true only consider windows at an angle between 45° and -45° on the\n   eastward axis\n\nReturns:\n * `true` if a window was found and focused, `false` otherwise; `nil` if the search couldn't take place\n\nNotes:\n * If you don't pass `candidateWindows`, Hammerspoon will query for the list of all visible windows\n   every time this method is called; this can be slow, and some undesired \"windows\" could be included\n   (see the notes for `hs.window.allWindows()`); consider using the equivalent methods in\n   `hs.window.filter` instead","examples":[],"file":"extensions/window/window.lua","lineno":"783","name":"focusWindowEast","notes":[" * If you don't pass `candidateWindows`, Hammerspoon will query for the list of all visible windows","   every time this method is called; this can be slow, and some undesired \"windows\" could be included","   (see the notes for `hs.window.allWindows()`); consider using the equivalent methods in","   `hs.window.filter` instead"],"parameters":[" * candidateWindows - (optional) a list of candidate windows to consider; if nil, all visible windows to the east are candidates."," * frontmost - (optional) boolean, if true focuses the nearest window that isn't occluded by any other window"," * strict - (optional) boolean, if true only consider windows at an angle between 45° and -45° on the eastward axis"],"returns":[" * `true` if a window was found and focused, `false` otherwise; `nil` if the search couldn't take place"],"signature":"hs.window:focusWindowEast([candidateWindows[, frontmost[, strict]]]) -> boolean","stripped_doc":"","type":"Method"},"focusWindowNorth":{"def":"hs.window:focusWindowNorth([candidateWindows[, frontmost[, strict]]]) -> boolean","desc":"Focuses the nearest possible window to the north (i.e. up)","doc":"Focuses the nearest possible window to the north (i.e. up)\n\nParameters:\n * candidateWindows - (optional) a list of candidate windows to consider; if nil, all visible windows\n   to the east are candidates.\n * frontmost - (optional) boolean, if true focuses the nearest window that isn't occluded by any other window\n * strict - (optional) boolean, if true only consider windows at an angle between 45° and -45° on the\n   eastward axis\n\nReturns:\n * `true` if a window was found and focused, `false` otherwise; `nil` if the search couldn't take place\n\nNotes:\n * If you don't pass `candidateWindows`, Hammerspoon will query for the list of all visible windows\n   every time this method is called; this can be slow, and some undesired \"windows\" could be included\n   (see the notes for `hs.window.allWindows()`); consider using the equivalent methods in\n   `hs.window.filter` instead","examples":[],"file":"extensions/window/window.lua","lineno":"823","name":"focusWindowNorth","notes":[" * If you don't pass `candidateWindows`, Hammerspoon will query for the list of all visible windows","   every time this method is called; this can be slow, and some undesired \"windows\" could be included","   (see the notes for `hs.window.allWindows()`); consider using the equivalent methods in","   `hs.window.filter` instead"],"parameters":[" * candidateWindows - (optional) a list of candidate windows to consider; if nil, all visible windows to the east are candidates."," * frontmost - (optional) boolean, if true focuses the nearest window that isn't occluded by any other window"," * strict - (optional) boolean, if true only consider windows at an angle between 45° and -45° on the eastward axis"],"returns":[" * `true` if a window was found and focused, `false` otherwise; `nil` if the search couldn't take place"],"signature":"hs.window:focusWindowNorth([candidateWindows[, frontmost[, strict]]]) -> boolean","stripped_doc":"","type":"Method"},"focusWindowSouth":{"def":"hs.window:focusWindowSouth([candidateWindows[, frontmost[, strict]]]) -> boolean","desc":"Focuses the nearest possible window to the south (i.e. down)","doc":"Focuses the nearest possible window to the south (i.e. down)\n\nParameters:\n * candidateWindows - (optional) a list of candidate windows to consider; if nil, all visible windows\n   to the east are candidates.\n * frontmost - (optional) boolean, if true focuses the nearest window that isn't occluded by any other window\n * strict - (optional) boolean, if true only consider windows at an angle between 45° and -45° on the\n   eastward axis\n\nReturns:\n * `true` if a window was found and focused, `false` otherwise; `nil` if the search couldn't take place\n\nNotes:\n * If you don't pass `candidateWindows`, Hammerspoon will query for the list of all visible windows\n   every time this method is called; this can be slow, and some undesired \"windows\" could be included\n   (see the notes for `hs.window.allWindows()`); consider using the equivalent methods in\n   `hs.window.filter` instead","examples":[],"file":"extensions/window/window.lua","lineno":"843","name":"focusWindowSouth","notes":[" * If you don't pass `candidateWindows`, Hammerspoon will query for the list of all visible windows","   every time this method is called; this can be slow, and some undesired \"windows\" could be included","   (see the notes for `hs.window.allWindows()`); consider using the equivalent methods in","   `hs.window.filter` instead"],"parameters":[" * candidateWindows - (optional) a list of candidate windows to consider; if nil, all visible windows to the east are candidates."," * frontmost - (optional) boolean, if true focuses the nearest window that isn't occluded by any other window"," * strict - (optional) boolean, if true only consider windows at an angle between 45° and -45° on the eastward axis"],"returns":[" * `true` if a window was found and focused, `false` otherwise; `nil` if the search couldn't take place"],"signature":"hs.window:focusWindowSouth([candidateWindows[, frontmost[, strict]]]) -> boolean","stripped_doc":"","type":"Method"},"focusWindowWest":{"def":"hs.window:focusWindowWest([candidateWindows[, frontmost[, strict]]]) -> boolean","desc":"Focuses the nearest possible window to the west (i.e. left)","doc":"Focuses the nearest possible window to the west (i.e. left)\n\nParameters:\n * candidateWindows - (optional) a list of candidate windows to consider; if nil, all visible windows\n   to the east are candidates.\n * frontmost - (optional) boolean, if true focuses the nearest window that isn't occluded by any other window\n * strict - (optional) boolean, if true only consider windows at an angle between 45° and -45° on the\n   eastward axis\n\nReturns:\n * `true` if a window was found and focused, `false` otherwise; `nil` if the search couldn't take place\n\nNotes:\n * If you don't pass `candidateWindows`, Hammerspoon will query for the list of all visible windows\n   every time this method is called; this can be slow, and some undesired \"windows\" could be included\n   (see the notes for `hs.window.allWindows()`); consider using the equivalent methods in\n   `hs.window.filter` instead","examples":[],"file":"extensions/window/window.lua","lineno":"803","name":"focusWindowWest","notes":[" * If you don't pass `candidateWindows`, Hammerspoon will query for the list of all visible windows","   every time this method is called; this can be slow, and some undesired \"windows\" could be included","   (see the notes for `hs.window.allWindows()`); consider using the equivalent methods in","   `hs.window.filter` instead"],"parameters":[" * candidateWindows - (optional) a list of candidate windows to consider; if nil, all visible windows to the east are candidates."," * frontmost - (optional) boolean, if true focuses the nearest window that isn't occluded by any other window"," * strict - (optional) boolean, if true only consider windows at an angle between 45° and -45° on the eastward axis"],"returns":[" * `true` if a window was found and focused, `false` otherwise; `nil` if the search couldn't take place"],"signature":"hs.window:focusWindowWest([candidateWindows[, frontmost[, strict]]]) -> boolean","stripped_doc":"","type":"Method"},"frame":{"def":"hs.window:frame() -> hs.geometry rect","desc":"Gets the frame of the window in absolute coordinates","doc":"Gets the frame of the window in absolute coordinates\n\nParameters:\n * None\n\nReturns:\n * An hs.geometry rect containing the co-ordinates of the top left corner of the window and its width and height","examples":[],"file":"extensions/window/window.lua","lineno":"430","name":"frame","notes":[],"parameters":[" * None"],"returns":[" * An hs.geometry rect containing the co-ordinates of the top left corner of the window and its width and height"],"signature":"hs.window:frame() -> hs.geometry rect","stripped_doc":"","type":"Method"},"frontmostWindow":{"def":"hs.window.frontmostWindow() -> hs.window object","desc":"Returns the focused window or, if no window has focus, the frontmost one","doc":"Returns the focused window or, if no window has focus, the frontmost one\n\nParameters:\n * None\n\nReturns:\n* An `hs.window` object representing the frontmost window, or `nil` if there are no visible windows","examples":[],"file":"extensions/window/window.lua","lineno":"748","name":"frontmostWindow","notes":[],"parameters":[" * None"],"returns":["* An `hs.window` object representing the frontmost window, or `nil` if there are no visible windows"],"signature":"hs.window.frontmostWindow() -> hs.window object","stripped_doc":"","type":"Constructor"},"get":{"def":"hs.window.get(hint) -> hs.window object","desc":"Gets a specific window","doc":"Gets a specific window\n\nParameters:\n * hint - search criterion for the desired window; it can be:\n   - an id number as per `hs.window:id()`\n   - a window title string as per `hs.window:title()`\n\nReturns:\n * the first hs.window object that matches the supplied search criterion, or `nil` if not found\n\nNotes:\n * see also `hs.window.find` and `hs.application:getWindow()`","examples":[],"file":"extensions/window/window.lua","lineno":"189","name":"get","notes":[" * see also `hs.window.find` and `hs.application:getWindow()`"],"parameters":[" * hint - search criterion for the desired window; it can be: - an id number as per `hs.window:id()` - a window title string as per `hs.window:title()`"],"returns":[" * the first hs.window object that matches the supplied search criterion, or `nil` if not found"],"signature":"hs.window.get(hint) -> hs.window object","stripped_doc":"","type":"Constructor"},"id":{"def":"hs.window:id() -> number or nil","desc":"Gets the unique identifier of the window","doc":"Gets the unique identifier of the window\n\nParameters:\n * None\n\nReturns:\n * A number containing the unique identifier of the window, or nil if an error occurred","examples":[],"file":"extensions/window/libwindow.m","lineno":"546","name":"id","notes":[],"parameters":[" * None"],"returns":[" * A number containing the unique identifier of the window, or nil if an error occurred"],"signature":"hs.window:id() -> number or nil","stripped_doc":"","type":"Method"},"invisibleWindows":{"def":"hs.window.invisibleWindows() -> list of hs.window objects","desc":"Gets all invisible windows","doc":"Gets all invisible windows\n\nParameters:\n * None\n\nReturns:\n * A list containing `hs.window` objects representing all windows that are not visible as per `hs.window:isVisible()`","examples":[],"file":"extensions/window/window.lua","lineno":"139","name":"invisibleWindows","notes":[],"parameters":[" * None"],"returns":[" * A list containing `hs.window` objects representing all windows that are not visible as per `hs.window:isVisible()`"],"signature":"hs.window.invisibleWindows() -> list of hs.window objects","stripped_doc":"","type":"Function"},"isFullScreen":{"def":"hs.window:isFullScreen() -> bool or nil","desc":"Gets the fullscreen state of the window","doc":"Gets the fullscreen state of the window\n\nParameters:\n * None\n\nReturns:\n * True if the window is fullscreen, false if not. Nil if an error occurred","examples":[],"file":"extensions/window/libwindow.m","lineno":"400","name":"isFullScreen","notes":[],"parameters":[" * None"],"returns":[" * True if the window is fullscreen, false if not. Nil if an error occurred"],"signature":"hs.window:isFullScreen() -> bool or nil","stripped_doc":"","type":"Method"},"isMaximizable":{"def":"hs.window:isMaximizable() -> bool or nil","desc":"Determines if a window is maximizable","doc":"Determines if a window is maximizable\n\nParameters:\n * None\n\nReturns:\n * True if the window is maximizable, False if it isn't, or nil if an error occurred","examples":[],"file":"extensions/window/libwindow.m","lineno":"296","name":"isMaximizable","notes":[],"parameters":[" * None"],"returns":[" * True if the window is maximizable, False if it isn't, or nil if an error occurred"],"signature":"hs.window:isMaximizable() -> bool or nil","stripped_doc":"","type":"Method"},"isMinimized":{"def":"hs.window:isMinimized() -> bool","desc":"Gets the minimized state of the window","doc":"Gets the minimized state of the window\n\nParameters:\n * None\n\nReturns:\n * True if the window is minimized, otherwise false","examples":[],"file":"extensions/window/libwindow.m","lineno":"456","name":"isMinimized","notes":[],"parameters":[" * None"],"returns":[" * True if the window is minimized, otherwise false"],"signature":"hs.window:isMinimized() -> bool","stripped_doc":"","type":"Method"},"isStandard":{"def":"hs.window:isStandard() -> bool","desc":"Determines if the window is a standard window","doc":"Determines if the window is a standard window\n\nParameters:\n * None\n\nReturns:\n * True if the window is standard, otherwise false\n\nNotes:\n * \"Standard window\" means that this is not an unusual popup window, a modal dialog, a floating window, etc.","examples":[],"file":"extensions/window/libwindow.m","lineno":"164","name":"isStandard","notes":[" * \"Standard window\" means that this is not an unusual popup window, a modal dialog, a floating window, etc."],"parameters":[" * None"],"returns":[" * True if the window is standard, otherwise false"],"signature":"hs.window:isStandard() -> bool","stripped_doc":"","type":"Method"},"isVisible":{"def":"hs.window:isVisible() -> boolean","desc":"Determines if a window is visible (i.e. not hidden and not minimized)","doc":"Determines if a window is visible (i.e. not hidden and not minimized)\n\nParameters:\n * None\n\nReturns:\n * `true` if the window is visible, otherwise `false`\n\nNotes:\n * This does not mean the user can see the window - it may be obscured by other windows, or it may be off the edge of the screen","examples":[],"file":"extensions/window/window.lua","lineno":"243","name":"isVisible","notes":[" * This does not mean the user can see the window - it may be obscured by other windows, or it may be off the edge of the screen"],"parameters":[" * None"],"returns":[" * `true` if the window is visible, otherwise `false`"],"signature":"hs.window:isVisible() -> boolean","stripped_doc":"","type":"Method"},"list":{"def":"hs.window.list(allWindows) -> table","desc":"Gets a table containing all the window data retrieved from `CGWindowListCreate`.","doc":"Gets a table containing all the window data retrieved from `CGWindowListCreate`.\n\nParameters:\n * allWindows - Get all the windows, even those \"below\" the Dock window.\n\nReturns:\n * `true` is succesful otherwise `false` if an error occured.\n\nNotes:\n * This allows you to get window information without Accessibility Permissions.","examples":[],"file":"extensions/window/libwindow.m","lineno":"21","name":"list","notes":[" * This allows you to get window information without Accessibility Permissions."],"parameters":[" * allWindows - Get all the windows, even those \"below\" the Dock window."],"returns":[" * `true` is succesful otherwise `false` if an error occured."],"signature":"hs.window.list(allWindows) -> table","stripped_doc":"","type":"Function"},"maximize":{"def":"hs.window:maximize([duration]) -> hs.window object","desc":"Maximizes the window","doc":"Maximizes the window\n\nParameters:\n * duration - (optional) The number of seconds to animate the transition. Defaults to the value of `hs.window.animationDuration`\n\nReturns:\n * The `hs.window` object\n\nNotes:\n * The window will be resized as large as possible, without obscuring the dock/menu","examples":[],"file":"extensions/window/window.lua","lineno":"581","name":"maximize","notes":[" * The window will be resized as large as possible, without obscuring the dock/menu"],"parameters":[" * duration - (optional) The number of seconds to animate the transition. Defaults to the value of `hs.window.animationDuration`"],"returns":[" * The `hs.window` object"],"signature":"hs.window:maximize([duration]) -> hs.window object","stripped_doc":"","type":"Method"},"minimize":{"def":"hs.window:minimize() -> window","desc":"Minimizes the window","doc":"Minimizes the window\n\nParameters:\n * None\n\nReturns:\n * The `hs.window` object\n\nNotes:\n * This method will always animate per your system settings and is not affected by `hs.window.animationDuration`","examples":[],"file":"extensions/window/libwindow.m","lineno":"417","name":"minimize","notes":[" * This method will always animate per your system settings and is not affected by `hs.window.animationDuration`"],"parameters":[" * None"],"returns":[" * The `hs.window` object"],"signature":"hs.window:minimize() -> window","stripped_doc":"","type":"Method"},"minimizedWindows":{"def":"hs.window.minimizedWindows() -> list of hs.window objects","desc":"Gets all minimized windows","doc":"Gets all minimized windows\n\nParameters:\n * None\n\nReturns:\n * A list containing `hs.window` objects representing all windows that are minimized as per `hs.window:isMinimized()`","examples":[],"file":"extensions/window/window.lua","lineno":"156","name":"minimizedWindows","notes":[],"parameters":[" * None"],"returns":[" * A list containing `hs.window` objects representing all windows that are minimized as per `hs.window:isMinimized()`"],"signature":"hs.window.minimizedWindows() -> list of hs.window objects","stripped_doc":"","type":"Function"},"move":{"def":"hs.window:move(rect[, screen][, ensureInScreenBounds][, duration]) --> hs.window object","desc":"Moves the window","doc":"Moves the window\n\nParameters:\n * rect - It can be:\n   - an `hs.geometry` point, or argument to construct one; will move the screen by this delta, keeping its size constant; `screen` is ignored\n   - an `hs.geometry` rect, or argument to construct one; will set the window frame to this rect, in absolute coordinates; `screen` is ignored\n   - an `hs.geometry` unit rect, or argument to construct one; will set the window frame to this rect relative to the desired screen;\n     if `screen` is nil, use the screen the window is currently on\n * screen - (optional) An `hs.screen` object or argument for `hs.screen.find`; only valid if `rect` is a unit rect\n * ensureInScreenBounds - (optional) if `true`, use `setFrameInScreenBounds()` to ensure the resulting window frame is fully contained within\n   the window's screen\n * duration - (optional) The number of seconds to animate the transition. Defaults to the value of `hs.window.animationDuration`\n\nReturns:\n * The `hs.window` object","examples":[],"file":"extensions/window/window.lua","lineno":"930","name":"move","notes":[],"parameters":[" * rect - It can be: - an `hs.geometry` point, or argument to construct one; will move the screen by this delta, keeping its size constant; `screen` is ignored - an `hs.geometry` rect, or argument to construct one; will set the window frame to this rect, in absolute coordinates; `screen` is ignored - an `hs.geometry` unit rect, or argument to construct one; will set the window frame to this rect relative to the desired screen; if `screen` is nil, use the screen the window is currently on"," * screen - (optional) An `hs.screen` object or argument for `hs.screen.find`; only valid if `rect` is a unit rect"," * ensureInScreenBounds - (optional) if `true`, use `setFrameInScreenBounds()` to ensure the resulting window frame is fully contained within the window's screen"," * duration - (optional) The number of seconds to animate the transition. Defaults to the value of `hs.window.animationDuration`"],"returns":[" * The `hs.window` object"],"signature":"hs.window:move(rect[, screen][, ensureInScreenBounds][, duration]) --> hs.window object","stripped_doc":"","type":"Method"},"moveOneScreenEast":{"def":"hs.window:moveOneScreenEast([noResize, ensureInScreenBounds][, duration]) -> hs.window object","desc":"Moves the window one screen east (i.e. right)","doc":"Moves the window one screen east (i.e. right)\n\nParameters:\n * noResize - (optional) if `true`, maintain the window's absolute size\n * ensureInScreenBounds - (optional) if `true`, use `setFrameInScreenBounds()` to ensure the resulting window frame is fully contained within\n   the window's screen\n * duration - (optional) The number of seconds to animate the transition. Defaults to the value of `hs.window.animationDuration`\n\nReturns:\n * The `hs.window` object","examples":[],"file":"extensions/window/window.lua","lineno":"969","name":"moveOneScreenEast","notes":[],"parameters":[" * noResize - (optional) if `true`, maintain the window's absolute size"," * ensureInScreenBounds - (optional) if `true`, use `setFrameInScreenBounds()` to ensure the resulting window frame is fully contained within the window's screen"," * duration - (optional) The number of seconds to animate the transition. Defaults to the value of `hs.window.animationDuration`"],"returns":[" * The `hs.window` object"],"signature":"hs.window:moveOneScreenEast([noResize, ensureInScreenBounds][, duration]) -> hs.window object","stripped_doc":"","type":"Method"},"moveOneScreenNorth":{"def":"hs.window:moveOneScreenNorth([noResize, ensureInScreenBounds][, duration]) -> hs.window object","desc":"Moves the window one screen north (i.e. up)","doc":"Moves the window one screen north (i.e. up)\n\n\nParameters:\n * noResize - (optional) if `true`, maintain the window's absolute size\n * ensureInScreenBounds - (optional) if `true`, use `setFrameInScreenBounds()` to ensure the resulting window frame is fully contained within\n   the window's screen\n * duration - (optional) The number of seconds to animate the transition. Defaults to the value of `hs.window.animationDuration`\n\nReturns:\n * The `hs.window` object","examples":[],"file":"extensions/window/window.lua","lineno":"995","name":"moveOneScreenNorth","notes":[],"parameters":[" * noResize - (optional) if `true`, maintain the window's absolute size"," * ensureInScreenBounds - (optional) if `true`, use `setFrameInScreenBounds()` to ensure the resulting window frame is fully contained within the window's screen"," * duration - (optional) The number of seconds to animate the transition. Defaults to the value of `hs.window.animationDuration`"],"returns":[" * The `hs.window` object"],"signature":"hs.window:moveOneScreenNorth([noResize, ensureInScreenBounds][, duration]) -> hs.window object","stripped_doc":"","type":"Method"},"moveOneScreenSouth":{"def":"hs.window:moveOneScreenSouth([noResize, ensureInScreenBounds][, duration]) -> hs.window object","desc":"Moves the window one screen south (i.e. down)","doc":"Moves the window one screen south (i.e. down)\n\n\nParameters:\n * noResize - (optional) if `true`, maintain the window's absolute size\n * ensureInScreenBounds - (optional) if `true`, use `setFrameInScreenBounds()` to ensure the resulting window frame is fully contained within\n   the window's screen\n * duration - (optional) The number of seconds to animate the transition. Defaults to the value of `hs.window.animationDuration`\n\nReturns:\n * The `hs.window` object","examples":[],"file":"extensions/window/window.lua","lineno":"1009","name":"moveOneScreenSouth","notes":[],"parameters":[" * noResize - (optional) if `true`, maintain the window's absolute size"," * ensureInScreenBounds - (optional) if `true`, use `setFrameInScreenBounds()` to ensure the resulting window frame is fully contained within the window's screen"," * duration - (optional) The number of seconds to animate the transition. Defaults to the value of `hs.window.animationDuration`"],"returns":[" * The `hs.window` object"],"signature":"hs.window:moveOneScreenSouth([noResize, ensureInScreenBounds][, duration]) -> hs.window object","stripped_doc":"","type":"Method"},"moveOneScreenWest":{"def":"hs.window:moveOneScreenWest([noResize, ensureInScreenBounds][, duration]) -> hs.window object","desc":"Moves the window one screen west (i.e. left)","doc":"Moves the window one screen west (i.e. left)\n\nParameters:\n * noResize - (optional) if `true`, maintain the window's absolute size\n * ensureInScreenBounds - (optional) if `true`, use `setFrameInScreenBounds()` to ensure the resulting window frame is fully contained within\n   the window's screen\n * duration - (optional) The number of seconds to animate the transition. Defaults to the value of `hs.window.animationDuration`\n\nReturns:\n * The `hs.window` object","examples":[],"file":"extensions/window/window.lua","lineno":"982","name":"moveOneScreenWest","notes":[],"parameters":[" * noResize - (optional) if `true`, maintain the window's absolute size"," * ensureInScreenBounds - (optional) if `true`, use `setFrameInScreenBounds()` to ensure the resulting window frame is fully contained within the window's screen"," * duration - (optional) The number of seconds to animate the transition. Defaults to the value of `hs.window.animationDuration`"],"returns":[" * The `hs.window` object"],"signature":"hs.window:moveOneScreenWest([noResize, ensureInScreenBounds][, duration]) -> hs.window object","stripped_doc":"","type":"Method"},"moveToScreen":{"def":"hs.window:moveToScreen(screen[, noResize, ensureInScreenBounds][, duration]) -> hs.window object","desc":"Moves the window to a given screen, retaining its relative position and size","doc":"Moves the window to a given screen, retaining its relative position and size\n\nParameters:\n * screen - An `hs.screen` object, or an argument for `hs.screen.find()`, representing the screen to move the window to\n * noResize - (optional) if `true`, maintain the window's absolute size\n * ensureInScreenBounds - (optional) if `true`, use `setFrameInScreenBounds()` to ensure the resulting window frame is fully contained within\n   the window's screen\n * duration - (optional) The number of seconds to animate the transition. Defaults to the value of `hs.window.animationDuration`\n\nReturns:\n * The `hs.window` object","examples":[],"file":"extensions/window/window.lua","lineno":"904","name":"moveToScreen","notes":[],"parameters":[" * screen - An `hs.screen` object, or an argument for `hs.screen.find()`, representing the screen to move the window to"," * noResize - (optional) if `true`, maintain the window's absolute size"," * ensureInScreenBounds - (optional) if `true`, use `setFrameInScreenBounds()` to ensure the resulting window frame is fully contained within the window's screen"," * duration - (optional) The number of seconds to animate the transition. Defaults to the value of `hs.window.animationDuration`"],"returns":[" * The `hs.window` object"],"signature":"hs.window:moveToScreen(screen[, noResize, ensureInScreenBounds][, duration]) -> hs.window object","stripped_doc":"","type":"Method"},"moveToUnit":{"def":"hs.window:moveToUnit(unitrect[, duration]) -> hs.window object","desc":"Moves and resizes the window to occupy a given fraction of the screen","doc":"Moves and resizes the window to occupy a given fraction of the screen\n\nParameters:\n * unitrect - An `hs.geometry` unit rect, or constructor argument to create one\n * duration - (optional) The number of seconds to animate the transition. Defaults to the value of `hs.window.animationDuration`\n\nReturns:\n * The `hs.window` object\n\nNotes:\n * An example, which would make a window fill the top-left quarter of the screen: `win:moveToUnit'[0.0,0.0,0.5,0.5]'`","examples":[],"file":"extensions/window/window.lua","lineno":"887","name":"moveToUnit","notes":[" * An example, which would make a window fill the top-left quarter of the screen: `win:moveToUnit'[0.0,0.0,0.5,0.5]'`"],"parameters":[" * unitrect - An `hs.geometry` unit rect, or constructor argument to create one"," * duration - (optional) The number of seconds to animate the transition. Defaults to the value of `hs.window.animationDuration`"],"returns":[" * The `hs.window` object"],"signature":"hs.window:moveToUnit(unitrect[, duration]) -> hs.window object","stripped_doc":"","type":"Method"},"orderedWindows":{"def":"hs.window.orderedWindows() -> list of hs.window objects","desc":"Returns all visible windows, ordered from front to back","doc":"Returns all visible windows, ordered from front to back\n\nParameters:\n * None\n\nReturns:\n * A list of `hs.window` objects representing all visible windows, ordered from front to back","examples":[],"file":"extensions/window/window.lua","lineno":"173","name":"orderedWindows","notes":[],"parameters":[" * None"],"returns":[" * A list of `hs.window` objects representing all visible windows, ordered from front to back"],"signature":"hs.window.orderedWindows() -> list of hs.window objects","stripped_doc":"","type":"Function"},"otherWindowsAllScreens":{"def":"hs.window:otherWindowsAllScreens() -> list of hs.window objects","desc":"Gets every window except this one","doc":"Gets every window except this one\n\nParameters:\n * None\n\nReturns:\n * A table containing `hs.window` objects representing all visible windows other than this one","examples":[],"file":"extensions/window/window.lua","lineno":"493","name":"otherWindowsAllScreens","notes":[],"parameters":[" * None"],"returns":[" * A table containing `hs.window` objects representing all visible windows other than this one"],"signature":"hs.window:otherWindowsAllScreens() -> list of hs.window objects","stripped_doc":"","type":"Method"},"otherWindowsSameScreen":{"def":"hs.window:otherWindowsSameScreen() -> list of hs.window objects","desc":"Gets other windows on the same screen","doc":"Gets other windows on the same screen\n\nParameters:\n * None\n\nReturns:\n * A table of `hs.window` objects representing the visible windows other than this one that are on the same screen","examples":[],"file":"extensions/window/window.lua","lineno":"479","name":"otherWindowsSameScreen","notes":[],"parameters":[" * None"],"returns":[" * A table of `hs.window` objects representing the visible windows other than this one that are on the same screen"],"signature":"hs.window:otherWindowsSameScreen() -> list of hs.window objects","stripped_doc":"","type":"Method"},"raise":{"def":"hs.window:raise() -> window","desc":"Brings a window to the front of the screen without focussing it","doc":"Brings a window to the front of the screen without focussing it\n\nParameters:\n * None\n\nReturns:\n * The `hs.window` object","examples":[],"file":"extensions/window/libwindow.m","lineno":"521","name":"raise","notes":[],"parameters":[" * None"],"returns":[" * The `hs.window` object"],"signature":"hs.window:raise() -> window","stripped_doc":"","type":"Method"},"role":{"def":"hs.window:role() -> string","desc":"Gets the role of the window","doc":"Gets the role of the window\n\nParameters:\n * None\n\nReturns:\n * A string containing the role of the window","examples":[],"file":"extensions/window/libwindow.m","lineno":"147","name":"role","notes":[],"parameters":[" * None"],"returns":[" * A string containing the role of the window"],"signature":"hs.window:role() -> string","stripped_doc":"","type":"Method"},"screen":{"def":"hs.window:screen() -> hs.screen object","desc":"Gets the screen which the window is on","doc":"Gets the screen which the window is on\n\nParameters:\n * None\n\nReturns:\n * An `hs.screen` object representing the screen which contains the window.\n\nNotes:\n * While windows can be dragged to span multiple screens, part of the window will disappear when the mouse is released. The screen returned by this method will be the part of the window that remains visible.","examples":[],"file":"extensions/window/window.lua","lineno":"618","name":"screen","notes":[" * While windows can be dragged to span multiple screens, part of the window will disappear when the mouse is released. The screen returned by this method will be the part of the window that remains visible."],"parameters":[" * None"],"returns":[" * An `hs.screen` object representing the screen which contains the window."],"signature":"hs.window:screen() -> hs.screen object","stripped_doc":"","type":"Method"},"sendToBack":{"def":"hs.window:sendToBack() -> hs.window object","desc":"Sends the window to the back","doc":"Sends the window to the back\n\nParameters:\n * None\n\nReturns:\n * The `hs.window` object\n\nNotes:\n * Due to the way this method works and OSX limitations, calling this method when you have a lot of randomly overlapping (as opposed to neatly tiled) windows might be visually jarring, and take a fair amount of time to complete. So if you don't use orderly layouts, or if you have a lot of windows in general, you're probably better off using `hs.application:hide()` (or simply `cmd-h`)\n * This method works by focusing all overlapping windows behind this one, front to back. If called on the focused window, this method will switch focus to the topmost window under this one; otherwise, the currently focused window will regain focus after this window has been sent to the back.","examples":[],"file":"extensions/window/window.lua","lineno":"539","name":"sendToBack","notes":[" * Due to the way this method works and OSX limitations, calling this method when you have a lot of randomly overlapping (as opposed to neatly tiled) windows might be visually jarring, and take a fair amount of time to complete. So if you don't use orderly layouts, or if you have a lot of windows in general, you're probably better off using `hs.application:hide()` (or simply `cmd-h`)"," * This method works by focusing all overlapping windows behind this one, front to back. If called on the focused window, this method will switch focus to the topmost window under this one; otherwise, the currently focused window will regain focus after this window has been sent to the back."],"parameters":[" * None"],"returns":[" * The `hs.window` object"],"signature":"hs.window:sendToBack() -> hs.window object","stripped_doc":"","type":"Method"},"setFrame":{"def":"hs.window:setFrame(rect[, duration]) -> hs.window object","desc":"Sets the frame of the window in absolute coordinates","doc":"Sets the frame of the window in absolute coordinates\n\nParameters:\n * rect - An hs.geometry rect, or constructor argument, describing the frame to be applied to the window\n * duration - (optional) The number of seconds to animate the transition. Defaults to the value of `hs.window.animationDuration`\n\nReturns:\n * The `hs.window` object","examples":[],"file":"extensions/window/window.lua","lineno":"368","name":"setFrame","notes":[],"parameters":[" * rect - An hs.geometry rect, or constructor argument, describing the frame to be applied to the window"," * duration - (optional) The number of seconds to animate the transition. Defaults to the value of `hs.window.animationDuration`"],"returns":[" * The `hs.window` object"],"signature":"hs.window:setFrame(rect[, duration]) -> hs.window object","stripped_doc":"","type":"Method"},"setFrameCorrectness":{"def":"hs.window.setFrameCorrectness","desc":"Using `hs.window:setFrame()` in some cases does not work as expected: namely, the bottom (or Dock) edge, and edges between screens, might","doc":"Using `hs.window:setFrame()` in some cases does not work as expected: namely, the bottom (or Dock) edge, and edges between screens, might\nexhibit some \"stickiness\"; consequently, trying to make a window abutting one of those edges just *slightly* smaller could\nresult in no change at all (you can verify this by trying to resize such a window with the mouse: at first it won't budge,\nand, as you drag further away, suddenly snap to the new size); and similarly in some cases windows along screen edges\nmight erroneously end up partially on the adjacent screen after a move/resize.  Additionally some windows (no matter\ntheir placement on screen) only allow being resized at \"discrete\" steps of several screen points; the typical example\nis Terminal windows, which only resize to whole rows and columns. Both these OSX issues can cause incorrect behavior\nwhen using `:setFrame()` directly or in downstream uses, such as `hs.window:move()` and the `hs.grid` and `hs.window.layout` modules.\n\nSetting this variable to `true` will make `:setFrame()` perform additional checks and workarounds for these potential\nissues. However, as a side effect the window might appear to jump around briefly before setting toward its destination\nframe, and, in some cases, the move/resize animation (if requested) might be skipped entirely - these tradeoffs are\nnecessary to ensure the desired result.\n\nThe default value is `false`, in order to avoid the possibly annoying or distracting window wiggling; set to `true` if you see\nincorrect results in `:setFrame()` or downstream modules and don't mind the the wiggling.","file":"extensions/window/window.lua","lineno":"392","name":"setFrameCorrectness","signature":"hs.window.setFrameCorrectness","stripped_doc":"exhibit some \"stickiness\"; consequently, trying to make a window abutting one of those edges just *slightly* smaller could\nresult in no change at all (you can verify this by trying to resize such a window with the mouse: at first it won't budge,\nand, as you drag further away, suddenly snap to the new size); and similarly in some cases windows along screen edges\nmight erroneously end up partially on the adjacent screen after a move/resize.  Additionally some windows (no matter\ntheir placement on screen) only allow being resized at \"discrete\" steps of several screen points; the typical example\nis Terminal windows, which only resize to whole rows and columns. Both these OSX issues can cause incorrect behavior\nwhen using `:setFrame()` directly or in downstream uses, such as `hs.window:move()` and the `hs.grid` and `hs.window.layout` modules.\nSetting this variable to `true` will make `:setFrame()` perform additional checks and workarounds for these potential\nissues. However, as a side effect the window might appear to jump around briefly before setting toward its destination\nframe, and, in some cases, the move/resize animation (if requested) might be skipped entirely - these tradeoffs are\nnecessary to ensure the desired result.\nThe default value is `false`, in order to avoid the possibly annoying or distracting window wiggling; set to `true` if you see\nincorrect results in `:setFrame()` or downstream modules and don't mind the the wiggling.","type":"Variable"},"setFrameInScreenBounds":{"def":"hs.window:setFrameInScreenBounds([rect][, duration]) -> hs.window object","desc":"Sets the frame of the window in absolute coordinates, possibly adjusted to ensure it is fully inside the screen","doc":"Sets the frame of the window in absolute coordinates, possibly adjusted to ensure it is fully inside the screen\n\nParameters:\n * rect - An hs.geometry rect, or constructor argument, describing the frame to be applied to the window; if omitted,\n   the current window frame will be used\n * duration - (optional) The number of seconds to animate the transition. Defaults to the value of `hs.window.animationDuration`\n\nReturns:\n * The `hs.window` object","examples":[],"file":"extensions/window/window.lua","lineno":"412","name":"setFrameInScreenBounds","notes":[],"parameters":[" * rect - An hs.geometry rect, or constructor argument, describing the frame to be applied to the window; if omitted, the current window frame will be used"," * duration - (optional) The number of seconds to animate the transition. Defaults to the value of `hs.window.animationDuration`"],"returns":[" * The `hs.window` object"],"signature":"hs.window:setFrameInScreenBounds([rect][, duration]) -> hs.window object","stripped_doc":"","type":"Method"},"setFrameWithWorkarounds":{"def":"hs.window:setFrameWithWorkarounds(rect[, duration]) -> hs.window object","desc":"Sets the frame of the window in absolute coordinates, using the additional workarounds described in `hs.window.setFrameCorrectness`","doc":"Sets the frame of the window in absolute coordinates, using the additional workarounds described in `hs.window.setFrameCorrectness`\n\nParameters:\n * rect - An hs.geometry rect, or constructor argument, describing the frame to be applied to the window\n * duration - (optional) The number of seconds to animate the transition. Defaults to the value of `hs.window.animationDuration`\n\nReturns:\n * The `hs.window` object","examples":[],"file":"extensions/window/window.lua","lineno":"380","name":"setFrameWithWorkarounds","notes":[],"parameters":[" * rect - An hs.geometry rect, or constructor argument, describing the frame to be applied to the window"," * duration - (optional) The number of seconds to animate the transition. Defaults to the value of `hs.window.animationDuration`"],"returns":[" * The `hs.window` object"],"signature":"hs.window:setFrameWithWorkarounds(rect[, duration]) -> hs.window object","stripped_doc":"","type":"Method"},"setFullScreen":{"def":"hs.window:setFullScreen(fullscreen) -> window","desc":"Sets the fullscreen state of the window","doc":"Sets the fullscreen state of the window\n\nParameters:\n * fullscreen - A boolean, true if the window should be set fullscreen, false if not\n\nReturns:\n * The `hs.window` object","examples":[],"file":"extensions/window/libwindow.m","lineno":"382","name":"setFullScreen","notes":[],"parameters":[" * fullscreen - A boolean, true if the window should be set fullscreen, false if not"],"returns":[" * The `hs.window` object"],"signature":"hs.window:setFullScreen(fullscreen) -> window","stripped_doc":"","type":"Method"},"setShadows":{"def":"hs.window.setShadows(shadows)","desc":"Enables/Disables window shadows","doc":"Enables/Disables window shadows\n\nParameters:\n * shadows - A boolean, true to show window shadows, false to hide window shadows\n\nReturns:\n * None\n\nNotes:\n * This function uses a private, undocumented OS X API call, so it is not guaranteed to work in any future OS X release","examples":[],"file":"extensions/window/libwindow.m","lineno":"563","name":"setShadows","notes":[" * This function uses a private, undocumented OS X API call, so it is not guaranteed to work in any future OS X release"],"parameters":[" * shadows - A boolean, true to show window shadows, false to hide window shadows"],"returns":[" * None"],"signature":"hs.window.setShadows(shadows)","stripped_doc":"","type":"Function"},"setSize":{"def":"hs.window:setSize(size) -> window","desc":"Resizes the window","doc":"Resizes the window\n\nParameters:\n * size - A size-table containing the width and height the window should be resized to\n\nReturns:\n * The `hs.window` object","examples":[],"file":"extensions/window/libwindow.m","lineno":"239","name":"setSize","notes":[],"parameters":[" * size - A size-table containing the width and height the window should be resized to"],"returns":[" * The `hs.window` object"],"signature":"hs.window:setSize(size) -> window","stripped_doc":"","type":"Method"},"setTopLeft":{"def":"hs.window:setTopLeft(point) -> window","desc":"Moves the window to a given point","doc":"Moves the window to a given point\n\nParameters:\n * point - A point-table containing the absolute co-ordinates the window should be moved to\n\nReturns:\n * The `hs.window` object","examples":[],"file":"extensions/window/libwindow.m","lineno":"218","name":"setTopLeft","notes":[],"parameters":[" * point - A point-table containing the absolute co-ordinates the window should be moved to"],"returns":[" * The `hs.window` object"],"signature":"hs.window:setTopLeft(point) -> window","stripped_doc":"","type":"Method"},"size":{"def":"hs.window:size() -> size","desc":"Gets the size of the window","doc":"Gets the size of the window\n\nParameters:\n * None\n\nReturns:\n * A size-table containing the width and height of the window","examples":[],"file":"extensions/window/libwindow.m","lineno":"201","name":"size","notes":[],"parameters":[" * None"],"returns":[" * A size-table containing the width and height of the window"],"signature":"hs.window:size() -> size","stripped_doc":"","type":"Method"},"snapshot":{"def":"hs.window:snapshot([keepTransparency]) -> hs.image-object","desc":"Returns a snapshot of the window as an `hs.image` object","doc":"Returns a snapshot of the window as an `hs.image` object\n\nParameters:\n * keepTransparency - optional boolean value indicating if the windows alpha value (transparency) should be maintained in the resulting image or if it should be fully opaque (default).\n\nReturns:\n * `hs.image` object of the window snapshot or nil if unable to create a snapshot\n\nNotes:\n * See also function `hs.window.snapshotForID()`","examples":[],"file":"extensions/window/libwindow.m","lineno":"611","name":"snapshot","notes":[" * See also function `hs.window.snapshotForID()`"],"parameters":[" * keepTransparency - optional boolean value indicating if the windows alpha value (transparency) should be maintained in the resulting image or if it should be fully opaque (default)."],"returns":[" * `hs.image` object of the window snapshot or nil if unable to create a snapshot"],"signature":"hs.window:snapshot([keepTransparency]) -> hs.image-object","stripped_doc":"","type":"Method"},"snapshotForID":{"def":"hs.window.snapshotForID(ID [, keepTransparency]) -> hs.image-object","desc":"Returns a snapshot of the window specified by the ID as an `hs.image` object","doc":"Returns a snapshot of the window specified by the ID as an `hs.image` object\n\nParameters:\n * ID - Window ID of the window to take a snapshot of.\n * keepTransparency - optional boolean value indicating if the windows alpha value (transparency) should be maintained in the resulting image or if it should be fully opaque (default).\n\nReturns:\n * `hs.image` object of the window snapshot or nil if unable to create a snapshot\n\nNotes:\n * See also method `hs.window:snapshot()`\n * Because the window ID cannot always be dynamically determined, this function will allow you to provide the ID of a window that was cached earlier.","examples":[],"file":"extensions/window/libwindow.m","lineno":"589","name":"snapshotForID","notes":[" * See also method `hs.window:snapshot()`"," * Because the window ID cannot always be dynamically determined, this function will allow you to provide the ID of a window that was cached earlier."],"parameters":[" * ID - Window ID of the window to take a snapshot of."," * keepTransparency - optional boolean value indicating if the windows alpha value (transparency) should be maintained in the resulting image or if it should be fully opaque (default)."],"returns":[" * `hs.image` object of the window snapshot or nil if unable to create a snapshot"],"signature":"hs.window.snapshotForID(ID [, keepTransparency]) -> hs.image-object","stripped_doc":"","type":"Function"},"subrole":{"def":"hs.window:subrole() -> string","desc":"Gets the subrole of the window","doc":"Gets the subrole of the window\n\nParameters:\n * None\n\nReturns:\n * A string containing the subrole of the window\n\nNotes:\n * This typically helps to determine if a window is a special kind of window - such as a modal window, or a floating window","examples":[],"file":"extensions/window/libwindow.m","lineno":"127","name":"subrole","notes":[" * This typically helps to determine if a window is a special kind of window - such as a modal window, or a floating window"],"parameters":[" * None"],"returns":[" * A string containing the subrole of the window"],"signature":"hs.window:subrole() -> string","stripped_doc":"","type":"Method"},"tabCount":{"def":"hs.window:tabCount() -> number or nil","desc":"Gets the number of tabs in the window has","doc":"Gets the number of tabs in the window has\n\nParameters:\n * None\n\nReturns:\n * A number containing the number of tabs, or nil if an error occurred\n\nNotes:\n * Intended for use with the focusTab method, if this returns a number, then focusTab can switch between that many tabs.","examples":[],"file":"extensions/window/libwindow.m","lineno":"362","name":"tabCount","notes":[" * Intended for use with the focusTab method, if this returns a number, then focusTab can switch between that many tabs."],"parameters":[" * None"],"returns":[" * A number containing the number of tabs, or nil if an error occurred"],"signature":"hs.window:tabCount() -> number or nil","stripped_doc":"","type":"Method"},"timeout":{"def":"hs.window.timeout(value) -> boolean","desc":"Sets the timeout value used in the accessibility API.","doc":"Sets the timeout value used in the accessibility API.\n\nParameters:\n * value - The number of seconds for the new timeout value.\n\nReturns:\n * `true` is succesful otherwise `false` if an error occured.","examples":[],"file":"extensions/window/libwindow.m","lineno":"65","name":"timeout","notes":[],"parameters":[" * value - The number of seconds for the new timeout value."],"returns":[" * `true` is succesful otherwise `false` if an error occured."],"signature":"hs.window.timeout(value) -> boolean","stripped_doc":"","type":"Function"},"title":{"def":"hs.window:title() -> string","desc":"Gets the title of the window","doc":"Gets the title of the window\n\nParameters:\n * None\n\nReturns:\n * A string containing the title of the window","examples":[],"file":"extensions/window/libwindow.m","lineno":"110","name":"title","notes":[],"parameters":[" * None"],"returns":[" * A string containing the title of the window"],"signature":"hs.window:title() -> string","stripped_doc":"","type":"Method"},"toggleFullScreen":{"def":"hs.window:toggleFullScreen() -> hs.window object","desc":"Toggles the fullscreen state of the window","doc":"Toggles the fullscreen state of the window\n\nParameters:\n * None\n\nReturns:\n * The `hs.window` object\n\nNotes:\n * Not all windows support being full-screened","examples":[],"file":"extensions/window/window.lua","lineno":"597","name":"toggleFullScreen","notes":[" * Not all windows support being full-screened"],"parameters":[" * None"],"returns":[" * The `hs.window` object"],"signature":"hs.window:toggleFullScreen() -> hs.window object","stripped_doc":"","type":"Method"},"toggleZoom":{"def":"hs.window:toggleZoom() -> window","desc":"Toggles the zoom state of the window (this is effectively equivalent to clicking the green maximize/fullscreen button at the top left of a window)","doc":"Toggles the zoom state of the window (this is effectively equivalent to clicking the green maximize/fullscreen button at the top left of a window)\n\nParameters:\n * None\n\nReturns:\n * The `hs.window` object","examples":[],"file":"extensions/window/libwindow.m","lineno":"257","name":"toggleZoom","notes":[],"parameters":[" * None"],"returns":[" * The `hs.window` object"],"signature":"hs.window:toggleZoom() -> window","stripped_doc":"","type":"Method"},"topLeft":{"def":"hs.window:topLeft() -> point","desc":"Gets the absolute co-ordinates of the top left of the window","doc":"Gets the absolute co-ordinates of the top left of the window\n\nParameters:\n * None\n\nReturns:\n * A point-table containing the absolute co-ordinates of the top left corner of the window","examples":[],"file":"extensions/window/libwindow.m","lineno":"184","name":"topLeft","notes":[],"parameters":[" * None"],"returns":[" * A point-table containing the absolute co-ordinates of the top left corner of the window"],"signature":"hs.window:topLeft() -> point","stripped_doc":"","type":"Method"},"unminimize":{"def":"hs.window:unminimize() -> window","desc":"Un-minimizes the window","doc":"Un-minimizes the window\n\nParameters:\n * None\n\nReturns:\n * The `hs.window` object","examples":[],"file":"extensions/window/libwindow.m","lineno":"438","name":"unminimize","notes":[],"parameters":[" * None"],"returns":[" * The `hs.window` object"],"signature":"hs.window:unminimize() -> window","stripped_doc":"","type":"Method"},"visibleWindows":{"def":"hs.window.visibleWindows() -> list of hs.window objects","desc":"Gets all visible windows","doc":"Gets all visible windows\n\nParameters:\n * None\n\nReturns:\n * A list containing `hs.window` objects representing all windows that are visible as per `hs.window:isVisible()`","examples":[],"file":"extensions/window/window.lua","lineno":"122","name":"visibleWindows","notes":[],"parameters":[" * None"],"returns":[" * A list containing `hs.window` objects representing all windows that are visible as per `hs.window:isVisible()`"],"signature":"hs.window.visibleWindows() -> list of hs.window objects","stripped_doc":"","type":"Function"},"windowsToEast":{"def":"hs.window:windowsToEast([candidateWindows[, frontmost[, strict]]]) -> list of hs.window objects","desc":"Gets all windows to the east of this window","doc":"Gets all windows to the east of this window\n\nParameters:\n * candidateWindows - (optional) a list of candidate windows to consider; if nil, all visible windows to the east are candidates.\n * frontmost - (optional) boolean, if true unoccluded windows will be placed before occluded ones in the result list\n * strict - (optional) boolean, if true only consider windows at an angle between 45° and -45° on the eastward axis\n\nReturns:\n * A list of `hs.window` objects representing all windows positioned east (i.e. right) of the window, in ascending order of distance\n\nNotes:\n * If you don't pass `candidateWindows`, Hammerspoon will query for the list of all visible windows every time this method is called; this can be slow, and some undesired \"windows\" could be included (see the notes for `hs.window.allWindows()`); consider using the equivalent methods in `hs.window.filter` instead","examples":[],"file":"extensions/window/window.lua","lineno":"688","name":"windowsToEast","notes":[" * If you don't pass `candidateWindows`, Hammerspoon will query for the list of all visible windows every time this method is called; this can be slow, and some undesired \"windows\" could be included (see the notes for `hs.window.allWindows()`); consider using the equivalent methods in `hs.window.filter` instead"],"parameters":[" * candidateWindows - (optional) a list of candidate windows to consider; if nil, all visible windows to the east are candidates."," * frontmost - (optional) boolean, if true unoccluded windows will be placed before occluded ones in the result list"," * strict - (optional) boolean, if true only consider windows at an angle between 45° and -45° on the eastward axis"],"returns":[" * A list of `hs.window` objects representing all windows positioned east (i.e. right) of the window, in ascending order of distance"],"signature":"hs.window:windowsToEast([candidateWindows[, frontmost[, strict]]]) -> list of hs.window objects","stripped_doc":"","type":"Method"},"windowsToNorth":{"def":"hs.window:windowsToNorth([candidateWindows[, frontmost[, strict]]]) -> list of hs.window objects","desc":"Gets all windows to the north of this window","doc":"Gets all windows to the north of this window\n\nParameters:\n * candidateWindows - (optional) a list of candidate windows to consider; if nil, all visible windows to the north are candidates.\n * frontmost - (optional) boolean, if true unoccluded windows will be placed before occluded ones in the result list\n * strict - (optional) boolean, if true only consider windows at an angle between 45° and -45° on the northward axis\n\nReturns:\n * A list of `hs.window` objects representing all windows positioned north (i.e. up) of the window, in ascending order of distance\n\nNotes:\n * If you don't pass `candidateWindows`, Hammerspoon will query for the list of all visible windows every time this method is called; this can be slow, and some undesired \"windows\" could be included (see the notes for `hs.window.allWindows()`); consider using the equivalent methods in `hs.window.filter` instead","examples":[],"file":"extensions/window/window.lua","lineno":"718","name":"windowsToNorth","notes":[" * If you don't pass `candidateWindows`, Hammerspoon will query for the list of all visible windows every time this method is called; this can be slow, and some undesired \"windows\" could be included (see the notes for `hs.window.allWindows()`); consider using the equivalent methods in `hs.window.filter` instead"],"parameters":[" * candidateWindows - (optional) a list of candidate windows to consider; if nil, all visible windows to the north are candidates."," * frontmost - (optional) boolean, if true unoccluded windows will be placed before occluded ones in the result list"," * strict - (optional) boolean, if true only consider windows at an angle between 45° and -45° on the northward axis"],"returns":[" * A list of `hs.window` objects representing all windows positioned north (i.e. up) of the window, in ascending order of distance"],"signature":"hs.window:windowsToNorth([candidateWindows[, frontmost[, strict]]]) -> list of hs.window objects","stripped_doc":"","type":"Method"},"windowsToSouth":{"def":"hs.window:windowsToSouth([candidateWindows[, frontmost[, strict]]]) -> list of hs.window objects","desc":"Gets all windows to the south of this window","doc":"Gets all windows to the south of this window\n\nParameters:\n * candidateWindows - (optional) a list of candidate windows to consider; if nil, all visible windows to the south are candidates.\n * frontmost - (optional) boolean, if true unoccluded windows will be placed before occluded ones in the result list\n * strict - (optional) boolean, if true only consider windows at an angle between 45° and -45° on the southward axis\n\nReturns:\n * A list of `hs.window` objects representing all windows positioned south (i.e. down) of the window, in ascending order of distance\n\nNotes:\n * If you don't pass `candidateWindows`, Hammerspoon will query for the list of all visible windows every time this method is called; this can be slow, and some undesired \"windows\" could be included (see the notes for `hs.window.allWindows()`); consider using the equivalent methods in `hs.window.filter` instead","examples":[],"file":"extensions/window/window.lua","lineno":"733","name":"windowsToSouth","notes":[" * If you don't pass `candidateWindows`, Hammerspoon will query for the list of all visible windows every time this method is called; this can be slow, and some undesired \"windows\" could be included (see the notes for `hs.window.allWindows()`); consider using the equivalent methods in `hs.window.filter` instead"],"parameters":[" * candidateWindows - (optional) a list of candidate windows to consider; if nil, all visible windows to the south are candidates."," * frontmost - (optional) boolean, if true unoccluded windows will be placed before occluded ones in the result list"," * strict - (optional) boolean, if true only consider windows at an angle between 45° and -45° on the southward axis"],"returns":[" * A list of `hs.window` objects representing all windows positioned south (i.e. down) of the window, in ascending order of distance"],"signature":"hs.window:windowsToSouth([candidateWindows[, frontmost[, strict]]]) -> list of hs.window objects","stripped_doc":"","type":"Method"},"windowsToWest":{"def":"hs.window:windowsToWest([candidateWindows[, frontmost[, strict]]]) -> list of hs.window objects","desc":"Gets all windows to the west of this window","doc":"Gets all windows to the west of this window\n\nParameters:\n * candidateWindows - (optional) a list of candidate windows to consider; if nil, all visible windows to the west are candidates.\n * frontmost - (optional) boolean, if true unoccluded windows will be placed before occluded ones in the result list\n * strict - (optional) boolean, if true only consider windows at an angle between 45° and -45° on the westward axis\n\nReturns:\n * A list of `hs.window` objects representing all windows positioned west (i.e. left) of the window, in ascending order of distance\n\nNotes:\n * If you don't pass `candidateWindows`, Hammerspoon will query for the list of all visible windows every time this method is called; this can be slow, and some undesired \"windows\" could be included (see the notes for `hs.window.allWindows()`); consider using the equivalent methods in `hs.window.filter` instead","examples":[],"file":"extensions/window/window.lua","lineno":"703","name":"windowsToWest","notes":[" * If you don't pass `candidateWindows`, Hammerspoon will query for the list of all visible windows every time this method is called; this can be slow, and some undesired \"windows\" could be included (see the notes for `hs.window.allWindows()`); consider using the equivalent methods in `hs.window.filter` instead"],"parameters":[" * candidateWindows - (optional) a list of candidate windows to consider; if nil, all visible windows to the west are candidates."," * frontmost - (optional) boolean, if true unoccluded windows will be placed before occluded ones in the result list"," * strict - (optional) boolean, if true only consider windows at an angle between 45° and -45° on the westward axis"],"returns":[" * A list of `hs.window` objects representing all windows positioned west (i.e. left) of the window, in ascending order of distance"],"signature":"hs.window:windowsToWest([candidateWindows[, frontmost[, strict]]]) -> list of hs.window objects","stripped_doc":"","type":"Method"},"zoomButtonRect":{"def":"hs.window:zoomButtonRect() -> rect-table or nil","desc":"Gets a rect-table for the location of the zoom button (the green button typically found at the top left of a window)","doc":"Gets a rect-table for the location of the zoom button (the green button typically found at the top left of a window)\n\nParameters:\n * None\n\nReturns:\n * A rect-table containing the bounding frame of the zoom button, or nil if an error occured\n\nNotes:\n * The co-ordinates in the rect-table (i.e. the `x` and `y` values) are in absolute co-ordinates, not relative to the window the button is part of, or the screen the window is on\n * Although not perfect as such, this method can provide a useful way to find a region of the titlebar suitable for simulating mouse click events on, with `hs.eventtap`","examples":[],"file":"extensions/window/libwindow.m","lineno":"275","name":"zoomButtonRect","notes":[" * The co-ordinates in the rect-table (i.e. the `x` and `y` values) are in absolute co-ordinates, not relative to the window the button is part of, or the screen the window is on"," * Although not perfect as such, this method can provide a useful way to find a region of the titlebar suitable for simulating mouse click events on, with `hs.eventtap`"],"parameters":[" * None"],"returns":[" * A rect-table containing the bounding frame of the zoom button, or nil if an error occured"],"signature":"hs.window:zoomButtonRect() -> rect-table or nil","stripped_doc":"","type":"Method"}}