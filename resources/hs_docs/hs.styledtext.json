{"ansi":{"def":"hs.styledtext.ansi(string, [attributes]) -> styledText object","desc":"Create an `hs.styledtext` object from the string provided, converting ANSI SGR color and some font sequences into the appropriate attributes.  Attributes to apply to the resulting string may also be optionally provided.","doc":"Create an `hs.styledtext` object from the string provided, converting ANSI SGR color and some font sequences into the appropriate attributes.  Attributes to apply to the resulting string may also be optionally provided.\n\nParameters:\n * string     - The string containing the text with ANSI SGR sequences to be converted.\n * attributes - an optional table containing attribute key-value pairs to apply to the entire `hs.styledtext` object to be returned.\n\nReturns:\n * an `hs.styledtext` object\n\nNotes:\n * Because a font is required for the SGR sequences indicating Bold and Italic, the base font is determined using the following logic:\n*  * if no `attributes` table is provided, the font is assumed to be the default for `hs.drawing` as returned by the `hs.drawing.defaultTextStyle` function\n*  * if an `attributes` table is provided and it defines a `font` attribute, this font is used.\n*  * if an `attributes` table is provided, but it does not provide a `font` attribute, the NSAttributedString default of Helvetica at 12 points is used.\n * As the most common use of this constructor is likely to be from the output of a terminal shell command, you will most likely want to specify a fixed-pitch (monospace) font.  You can get a list of installed fixed-pitch fonts by typing `hs.styledtext.fontNamesWithTraits(hs.styledtext.fontTraits.fixedPitchFont)` into the Hammerspoon console.\n\n * See the module description documentation (`help.hs.styledtext`) for a description of the attributes table format which can be provided for the optional second argument.\n\n * This function was modeled after the ANSIEscapeHelper.m file at https://github.com/balthamos/geektool-3 in the /NerdTool/classes directory.","examples":[],"file":"extensions/styledtext/styledtext.lua","lineno":"287","name":"ansi","notes":[" * Because a font is required for the SGR sequences indicating Bold and Italic, the base font is determined using the following logic:","*  * if no `attributes` table is provided, the font is assumed to be the default for `hs.drawing` as returned by the `hs.drawing.defaultTextStyle` function","*  * if an `attributes` table is provided and it defines a `font` attribute, this font is used.","*  * if an `attributes` table is provided, but it does not provide a `font` attribute, the NSAttributedString default of Helvetica at 12 points is used."," * As the most common use of this constructor is likely to be from the output of a terminal shell command, you will most likely want to specify a fixed-pitch (monospace) font.  You can get a list of installed fixed-pitch fonts by typing `hs.styledtext.fontNamesWithTraits(hs.styledtext.fontTraits.fixedPitchFont)` into the Hammerspoon console.",""," * See the module description documentation (`help.hs.styledtext`) for a description of the attributes table format which can be provided for the optional second argument.",""," * This function was modeled after the ANSIEscapeHelper.m file at https://github.com/balthamos/geektool-3 in the /NerdTool/classes directory."],"parameters":[" * string     - The string containing the text with ANSI SGR sequences to be converted."," * attributes - an optional table containing attribute key-value pairs to apply to the entire `hs.styledtext` object to be returned."],"returns":[" * an `hs.styledtext` object"],"signature":"hs.styledtext.ansi(string, [attributes]) -> styledText object","stripped_doc":" * See the module description documentation (`help.hs.styledtext`) for a description of the attributes table format which can be provided for the optional second argument.\n * This function was modeled after the ANSIEscapeHelper.m file at https://github.com/balthamos/geektool-3 in the /NerdTool/classes directory.","type":"Constructor"},"asTable":{"def":"hs.styledtext:asTable([starts], [ends]) -> table","desc":"Returns the table representation of the `hs.styledtext` object or its specified substring.","doc":"Returns the table representation of the `hs.styledtext` object or its specified substring.\n\nParameters:\n * starts - an optional index position within the text of the `hs.styledtext` object indicating the beginning of the substring to return the table for.  Defaults to 1, the beginning of the objects text.  If this number is negative, it is counted backwards from the end of the object's text (i.e. -1 would be the last character position).\n * ends   - an optional index position within the text of the `hs.styledtext` object indicating the end of the substring to return the table for.  Defaults to the length of the objects text.  If this number is negative, it is counted backwards from the end of the object's text.\n\nReturns:\n * a table representing the `hs.styledtext` object.  The table will be an array with the following structure:\n   * index 1             - the text of the `hs.styledtext` object as a Lua String.\n   * index 2+            - a table with the following keys:\n     * starts            - the index position in the original styled text object where this list of attributes is first applied\n     * ends              - the index position in the original styled text object where the application of this list of attributes ends\n     * attributes        - a table of attribute key-value pairs that apply to the string between the positions of `starts` and `ends`\n     * unsupportedFields - this field only exists, and will be set to `true` when an attribute that was included in the attributes table that this module cannot modify.  A best effort will be made to render the attributes assigned value in the attributes table, but modifying the attribute and re-applying it with `hs.styledtext:setStyle` will be silently ignored.\n\nNotes:\n * `starts` and `ends` follow the conventions of `i` and `j` for Lua's `string.sub` function.\n * The attribute which contains an attachment (image) for a converted RTFD or other document is known to set the `unsupportedFields` flag.\n\n * The indexes in the table returned are relative to their position in the original `hs.styledtext` object.  If you want the table version of a substring which does not start at index position 1 that can be safely fed as a \"proper\" table version of an `hs.styledtext` object into another function or constructor, the proper way to generate it is `destination = object:sub(i,j):asTable().\n\n * See the module description documentation (`help.hs.styledtext`) for a description of the attributes table format","examples":[],"file":"extensions/styledtext/libstyledtext.m","lineno":"745","name":"asTable","notes":[" * `starts` and `ends` follow the conventions of `i` and `j` for Lua's `string.sub` function."," * The attribute which contains an attachment (image) for a converted RTFD or other document is known to set the `unsupportedFields` flag.",""," * The indexes in the table returned are relative to their position in the original `hs.styledtext` object.  If you want the table version of a substring which does not start at index position 1 that can be safely fed as a \"proper\" table version of an `hs.styledtext` object into another function or constructor, the proper way to generate it is `destination = object:sub(i,j):asTable().",""," * See the module description documentation (`help.hs.styledtext`) for a description of the attributes table format"],"parameters":[" * starts - an optional index position within the text of the `hs.styledtext` object indicating the beginning of the substring to return the table for.  Defaults to 1, the beginning of the objects text.  If this number is negative, it is counted backwards from the end of the object's text (i.e. -1 would be the last character position)."," * ends   - an optional index position within the text of the `hs.styledtext` object indicating the end of the substring to return the table for.  Defaults to the length of the objects text.  If this number is negative, it is counted backwards from the end of the object's text."],"returns":[" * a table representing the `hs.styledtext` object.  The table will be an array with the following structure:","   * index 1             - the text of the `hs.styledtext` object as a Lua String.","   * index 2+            - a table with the following keys:","     * starts            - the index position in the original styled text object where this list of attributes is first applied","     * ends              - the index position in the original styled text object where the application of this list of attributes ends","     * attributes        - a table of attribute key-value pairs that apply to the string between the positions of `starts` and `ends`","     * unsupportedFields - this field only exists, and will be set to `true` when an attribute that was included in the attributes table that this module cannot modify.  A best effort will be made to render the attributes assigned value in the attributes table, but modifying the attribute and re-applying it with `hs.styledtext:setStyle` will be silently ignored."],"signature":"hs.styledtext:asTable([starts], [ends]) -> table","stripped_doc":" * The indexes in the table returned are relative to their position in the original `hs.styledtext` object.  If you want the table version of a substring which does not start at index position 1 that can be safely fed as a \"proper\" table version of an `hs.styledtext` object into another function or constructor, the proper way to generate it is `destination = object:sub(i,j):asTable().\n * See the module description documentation (`help.hs.styledtext`) for a description of the attributes table format","type":"Method"},"byte":{"def":"hs.styledtext:byte([starts], [ends]) -> integer, ...","desc":"Returns the internal numerical representation of the characters in the `hs.styledtext` object specified by the given indicies.  Mimics the Lua `string.byte` function.","doc":"Returns the internal numerical representation of the characters in the `hs.styledtext` object specified by the given indicies.  Mimics the Lua `string.byte` function.\n\nParameters:\n * starts - an optional index position within the text of the `hs.styledtext` object indicating the beginning of the substring to return numerical values for.  Defaults to 1, the beginning of the objects text.  If this number is negative, it is counted backwards from the end of the object's text (i.e. -1 would be the last character position).\n * ends   - an optional index position within the text of the `hs.styledtext` object indicating the end of the substring to return numerical values for.  Defaults to the value of `starts`.  If this number is negative, it is counted backwards from the end of the object's text.\n\nReturns:\n * a list of integers representing the internal numeric representation of the characters in the `hs.styledtext` object specified by the given indicies.\n\nNotes:\n * `starts` and `ends` follow the conventions of `i` and `j` for Lua's `string.sub` function.","examples":[],"file":"extensions/styledtext/styledtext.lua","lineno":"84","name":"byte","notes":[" * `starts` and `ends` follow the conventions of `i` and `j` for Lua's `string.sub` function."],"parameters":[" * starts - an optional index position within the text of the `hs.styledtext` object indicating the beginning of the substring to return numerical values for.  Defaults to 1, the beginning of the objects text.  If this number is negative, it is counted backwards from the end of the object's text (i.e. -1 would be the last character position)."," * ends   - an optional index position within the text of the `hs.styledtext` object indicating the end of the substring to return numerical values for.  Defaults to the value of `starts`.  If this number is negative, it is counted backwards from the end of the object's text."],"returns":[" * a list of integers representing the internal numeric representation of the characters in the `hs.styledtext` object specified by the given indicies."],"signature":"hs.styledtext:byte([starts], [ends]) -> integer, ...","stripped_doc":"","type":"Method"},"convert":{"def":"hs.styledtext:convert([type]) -> string","desc":"Converts the styledtext object into the data format specified.","doc":"Converts the styledtext object into the data format specified.\n\nParameters:\n * type          - a string indicating the format to convert the styletext object into.  Defaults to \"html\".  The string may be one of the following:\n   * \"text\"      - Plain text document.\n   * \"rtf\"        - Rich text format document.\n   * \"rtfd\"       - Rich text format with attachments document.\n   * \"html\"       - Hypertext Markup Language (HTML) document.\n   * \"word\"       - Microsoft Word document.\n   * \"wordXML\"    - Microsoft Word XML (WordML schema) document.\n   * \"webArchive\" - Web Kit WebArchive document.\n   * \"openXML\"    - ECMA Office Open XML text document format.\n   * \"open\"       - OASIS Open Document text document format.\n\nReturns:\n * a string containing the converted data","examples":[],"file":"extensions/styledtext/libstyledtext.m","lineno":"1220","name":"convert","notes":[],"parameters":[" * type          - a string indicating the format to convert the styletext object into.  Defaults to \"html\".  The string may be one of the following:\n   * \"text\"      - Plain text document.\n   * \"rtf\"        - Rich text format document.\n   * \"rtfd\"       - Rich text format with attachments document.\n   * \"html\"       - Hypertext Markup Language (HTML) document.\n   * \"word\"       - Microsoft Word document.\n   * \"wordXML\"    - Microsoft Word XML (WordML schema) document.\n   * \"webArchive\" - Web Kit WebArchive document.\n   * \"openXML\"    - ECMA Office Open XML text document format.\n   * \"open\"       - OASIS Open Document text document format."],"returns":[" * a string containing the converted data"],"signature":"hs.styledtext:convert([type]) -> string","stripped_doc":"","type":"Method"},"convertFont":{"def":"hs.styledtext.convertFont(fontTable, trait) -> table","desc":"Returns the font which most closely matches the given font and the trait change requested.","doc":"Returns the font which most closely matches the given font and the trait change requested.\n\nParameters:\n * font - a string or a table which specifies a font.  If a string is given, the default system font size is assumed.  If a table is provided, it should contain the following keys:\n   * name - the name of the font (defaults to the system font)\n   * size - the point size of the font (defaults to the default system font size)\n * trait - a number corresponding to a trait listed in `hs.styledtext.fontTraits` you wish to add or remove (unboldFont and unitalicFont) from the given font, or a boolean indicating whether you want a heavier version (true) or a lighter version (false).\n\nReturns:\n * a table containing the name and size of the font which most closely matches the specified font and the trait change requested.  If no such font is available, then the original font is returned unchanged.","examples":[],"file":"extensions/styledtext/libstyledtext.m","lineno":"309","name":"convertFont","notes":[],"parameters":[" * font - a string or a table which specifies a font.  If a string is given, the default system font size is assumed.  If a table is provided, it should contain the following keys:\n   * name - the name of the font (defaults to the system font)\n   * size - the point size of the font (defaults to the default system font size)"," * trait - a number corresponding to a trait listed in `hs.styledtext.fontTraits` you wish to add or remove (unboldFont and unitalicFont) from the given font, or a boolean indicating whether you want a heavier version (true) or a lighter version (false)."],"returns":[" * a table containing the name and size of the font which most closely matches the specified font and the trait change requested.  If no such font is available, then the original font is returned unchanged."],"signature":"hs.styledtext.convertFont(fontTable, trait) -> table","stripped_doc":"","type":"Function"},"copy":{"def":"hs.styledtext:copy(styledText) -> styledText object","desc":"Create a copy of the `hs.styledtext` object.","doc":"Create a copy of the `hs.styledtext` object.\n\nParameters:\n * styledText - an `hs.styledtext` object\n\nReturns:\n * a copy of the styledText object","examples":[],"file":"extensions/styledtext/libstyledtext.m","lineno":"707","name":"copy","notes":[],"parameters":[" * styledText - an `hs.styledtext` object"],"returns":[" * a copy of the styledText object"],"signature":"hs.styledtext:copy(styledText) -> styledText object","stripped_doc":"","type":"Method"},"defaultFonts":{"def":"hs.styledtext.defaultFonts","desc":"A table containing the system default fonts and sizes.","doc":"A table containing the system default fonts and sizes.\n\nDefined fonts included are:\n * boldSystem     - the system font used for standard interface items that are rendered in boldface type\n * controlContent - the font used for the content of controls\n * label          - the font used for standard interface labels\n * menu           - the font used for menu items\n * menuBar        - the font used for menu bar items\n * message        - the font used for standard interface items, such as button labels, menu items, etc.\n * palette        - the font used for palette window title bars\n * system         - the system font used for standard interface items, such as button labels, menu items, etc.\n * titleBar       - the font used for window title bars\n * toolTips       - the font used for tool tips labels\n * user           - the font used by default for documents and other text under the user’s control\n * userFixedPitch - the font used by default for documents and other text under the user’s control when that font should be fixed-pitch\n\nNotes:\n * These are useful when defining a styled text object which should be similar to or based on a specific system element type.\n\n * Because the user can change font defaults while Hammerspoon is running, this table is actually generated dynamically on request.  This should not affect of your use of this constant as a table; however, you can generate a static table if desired by invoking `hs.styledtext._defaultFonts()` directly instead.","file":"extensions/styledtext/libstyledtext.m","lineno":"664","name":"defaultFonts","notes":[" * These are useful when defining a styled text object which should be similar to or based on a specific system element type.",""," * Because the user can change font defaults while Hammerspoon is running, this table is actually generated dynamically on request.  This should not affect of your use of this constant as a table; however, you can generate a static table if desired by invoking `hs.styledtext._defaultFonts()` directly instead."],"signature":"hs.styledtext.defaultFonts","stripped_doc":"Defined fonts included are:\n * boldSystem     - the system font used for standard interface items that are rendered in boldface type\n * controlContent - the font used for the content of controls\n * label          - the font used for standard interface labels\n * menu           - the font used for menu items\n * menuBar        - the font used for menu bar items\n * message        - the font used for standard interface items, such as button labels, menu items, etc.\n * palette        - the font used for palette window title bars\n * system         - the system font used for standard interface items, such as button labels, menu items, etc.\n * titleBar       - the font used for window title bars\n * toolTips       - the font used for tool tips labels\n * user           - the font used by default for documents and other text under the user’s control\n * userFixedPitch - the font used by default for documents and other text under the user’s control when that font should be fixed-pitch\n * Because the user can change font defaults while Hammerspoon is running, this table is actually generated dynamically on request.  This should not affect of your use of this constant as a table; however, you can generate a static table if desired by invoking `hs.styledtext._defaultFonts()` directly instead.","type":"Constant"},"find":{"def":"hs.styledtext:find(pattern, [init, [plain]]) -> start, end, ... | nil","desc":"Returns the indicies of the first occurrence of the specified pattern in the text of the `hs.styledtext` object.  Mimics the Lua `string.find` function.","doc":"Returns the indicies of the first occurrence of the specified pattern in the text of the `hs.styledtext` object.  Mimics the Lua `string.find` function.\n\nParameters:\n * pattern  - a string containing the pattern to locate.  See the Lua manual, section 6.4.1 (`help.lua._man._6_4_1`) for more details.\n * init     - an optional integer specifying the location within the text to start the pattern search\n * plain    - an optional boolean specifying whether or not to treat the pattern as plain text (i.e. an exact match).  Defaults to false.  If you wish to specify this argument, you must also specify init.\n\nReturns:\n * if a match is found, `start` and `end` will be the indices where the pattern was first located.  If captures were specified in the pattern, they will also be returned as additional arguments after `start` and `end`.  If the pattern was not found in the text, then this method returns nil.\n\nNotes:\n * Any captures returned are returned as Lua Strings, not as `hs.styledtext` objects.","examples":[],"file":"extensions/styledtext/styledtext.lua","lineno":"99","name":"find","notes":[" * Any captures returned are returned as Lua Strings, not as `hs.styledtext` objects."],"parameters":[" * pattern  - a string containing the pattern to locate.  See the Lua manual, section 6.4.1 (`help.lua._man._6_4_1`) for more details."," * init     - an optional integer specifying the location within the text to start the pattern search"," * plain    - an optional boolean specifying whether or not to treat the pattern as plain text (i.e. an exact match).  Defaults to false.  If you wish to specify this argument, you must also specify init."],"returns":[" * if a match is found, `start` and `end` will be the indices where the pattern was first located.  If captures were specified in the pattern, they will also be returned as additional arguments after `start` and `end`.  If the pattern was not found in the text, then this method returns nil."],"signature":"hs.styledtext:find(pattern, [init, [plain]]) -> start, end, ... | nil","stripped_doc":"","type":"Method"},"fontFamilies":{"def":"hs.styledtext.fontFamilies() -> table","desc":"Returns the names of all font families installed for the system.","doc":"Returns the names of all font families installed for the system.\n\nParameters:\n * None\n\nReturns:\n * a table containing the names of every font family installed for the system.","examples":[],"file":"extensions/styledtext/libstyledtext.m","lineno":"272","name":"fontFamilies","notes":[],"parameters":[" * None"],"returns":[" * a table containing the names of every font family installed for the system."],"signature":"hs.styledtext.fontFamilies() -> table","stripped_doc":"","type":"Function"},"fontInfo":{"def":"hs.styledtext.fontInfo(font) -> table","desc":"Get information about the font Specified in the attributes table.","doc":"Get information about the font Specified in the attributes table.\n\nParameters:\n * font - a string or a table which specifies a font.  If a string is given, the default system font size is assumed.  If a table is provided, it should contain the following keys:\n   * name - the name of the font (defaults to the system font)\n   * size - the point size of the font (defaults to the default system font size)\n\nReturns:\n * a table containing the following keys:\n   * fontName           - The font's internally recognized name.\n   * familyName         - The font's family name.\n   * displayName        - The font’s display name is typically localized for the user’s language.\n   * fixedPitch         - A boolean value indicating whether all glyphs in the font have the same advancement.\n   * ascender           - The top y-coordinate, offset from the baseline, of the font’s longest ascender.\n   * boundingRect       - A table containing the font’s bounding rectangle, scaled to the font’s size.  This rectangle is the union of the bounding rectangles of every glyph in the font.\n   * capHeight          - The cap height of the font.\n   * descender          - The bottom y-coordinate, offset from the baseline, of the font’s longest descender.\n   * italicAngle        - The number of degrees that the font is slanted counterclockwise from the vertical. (read-only)\n   * leading            - The leading value of the font.\n   * maximumAdvancement - A table containing the maximum advance of any of the font’s glyphs.\n   * numberOfGlyphs     - The number of glyphs in the font.\n   * pointSize          - The point size of the font.\n   * underlinePosition  - The baseline offset to use when drawing underlines with the font.\n   * underlineThickness - The thickness to use when drawing underlines with the font.\n   * xHeight            - The x-height of the font.","examples":[],"file":"extensions/styledtext/libstyledtext.m","lineno":"453","name":"fontInfo","notes":[],"parameters":[" * font - a string or a table which specifies a font.  If a string is given, the default system font size is assumed.  If a table is provided, it should contain the following keys:\n   * name - the name of the font (defaults to the system font)\n   * size - the point size of the font (defaults to the default system font size)"],"returns":[" * a table containing the following keys:","   * fontName           - The font's internally recognized name.","   * familyName         - The font's family name.","   * displayName        - The font’s display name is typically localized for the user’s language.","   * fixedPitch         - A boolean value indicating whether all glyphs in the font have the same advancement.","   * ascender           - The top y-coordinate, offset from the baseline, of the font’s longest ascender.","   * boundingRect       - A table containing the font’s bounding rectangle, scaled to the font’s size.  This rectangle is the union of the bounding rectangles of every glyph in the font.","   * capHeight          - The cap height of the font.","   * descender          - The bottom y-coordinate, offset from the baseline, of the font’s longest descender.","   * italicAngle        - The number of degrees that the font is slanted counterclockwise from the vertical. (read-only)","   * leading            - The leading value of the font.","   * maximumAdvancement - A table containing the maximum advance of any of the font’s glyphs.","   * numberOfGlyphs     - The number of glyphs in the font.","   * pointSize          - The point size of the font.","   * underlinePosition  - The baseline offset to use when drawing underlines with the font.","   * underlineThickness - The thickness to use when drawing underlines with the font.","   * xHeight            - The x-height of the font."],"signature":"hs.styledtext.fontInfo(font) -> table","stripped_doc":"","type":"Function"},"fontNames":{"def":"hs.styledtext.fontNames() -> table","desc":"Returns the names of all installed fonts for the system.","doc":"Returns the names of all installed fonts for the system.\n\nParameters:\n * None\n\nReturns:\n * a table containing the names of every font installed for the system.  The individual names are strings which can be used in the `hs.drawing:setTextFont(fontname)` method.","examples":[],"file":"extensions/styledtext/libstyledtext.m","lineno":"250","name":"fontNames","notes":[],"parameters":[" * None"],"returns":[" * a table containing the names of every font installed for the system.  The individual names are strings which can be used in the `hs.drawing:setTextFont(fontname)` method."],"signature":"hs.styledtext.fontNames() -> table","stripped_doc":"","type":"Function"},"fontNamesWithTraits":{"def":"hs.styledtext.fontNamesWithTraits(fontTraitMask) -> table","desc":"Returns the names of all installed fonts for the system with the specified traits.","doc":"Returns the names of all installed fonts for the system with the specified traits.\n\nParameters:\n * traits - a number, specifying the fontTraitMask, or a table containing traits listed in `hs.styledtext.fontTraits` which are logically 'OR'ed together to create the fontTraitMask used.\n\nReturns:\n * a table containing the names of every font installed for the system which matches the fontTraitMask specified.  The individual names are strings which can be used in the `hs.drawing:setTextFont(fontname)` method.\n\nNotes:\n * specifying 0 or an empty table will match all fonts that are neither italic nor bold.  This would be the same list as you'd get with { hs.styledtext.fontTraits.unBold, hs.styledtext.fontTraits.unItalic } as the parameter.","examples":[],"file":"extensions/styledtext/libstyledtext.m","lineno":"339","name":"fontNamesWithTraits","notes":[" * specifying 0 or an empty table will match all fonts that are neither italic nor bold.  This would be the same list as you'd get with { hs.styledtext.fontTraits.unBold, hs.styledtext.fontTraits.unItalic } as the parameter."],"parameters":[" * traits - a number, specifying the fontTraitMask, or a table containing traits listed in `hs.styledtext.fontTraits` which are logically 'OR'ed together to create the fontTraitMask used."],"returns":[" * a table containing the names of every font installed for the system which matches the fontTraitMask specified.  The individual names are strings which can be used in the `hs.drawing:setTextFont(fontname)` method."],"signature":"hs.styledtext.fontNamesWithTraits(fontTraitMask) -> table","stripped_doc":"","type":"Function"},"fontPath":{"def":"hs.styledtext.fontPath(font) -> table","desc":"Get the path of a font.","doc":"Get the path of a font.\n\nParameters:\n * font - a string containing the name of the font you want to check.\n\nReturns:\n * The path to the font or `nil` if the font name is not valid.","examples":[],"file":"extensions/styledtext/libstyledtext.m","lineno":"536","name":"fontPath","notes":[],"parameters":[" * font - a string containing the name of the font you want to check."],"returns":[" * The path to the font or `nil` if the font name is not valid."],"signature":"hs.styledtext.fontPath(font) -> table","stripped_doc":"","type":"Function"},"fontsForFamily":{"def":"hs.styledtext.fontsForFamily(familyName) -> table","desc":"Returns an array containing fonts available for the specified font family or nil if no fonts for the specified family are present.","doc":"Returns an array containing fonts available for the specified font family or nil if no fonts for the specified family are present.\n\nParameters:\n * `familyName` - a string specifying the font family to return available fonts for. The strings should be one of the values returned by the [hs.styledtext.fontFamiles](#fontFamilies) function.\n\nReturns:\n * a table containing an array of available fonts for the specified family. Each array entry will be a table, also as an array, in the following order:\n   * a string specifying the font name which can be used in the `hs.drawing:setTextFont(fontname)` method.\n   * a string specifying the basic style of the font (e.g. Bold, Italic, Roman, etc.)\n   * a table containing one or more strings specifying common names for the weight of the font. ISO equivalent names are preceded with \"ISO:\". Possible values are:\n            `{ \"ultralight\" }`\n            `{ \"thin\", \"ISO:ultralight\" }`\n            `{ \"light\", \"extralight\", \"ISO:extralight\" }`\n            `{ \"book\", \"ISO:light\" }`\n            `{ \"regular\", \"plain\", \"display\", \"roman\", \"ISO:semilight\" }`\n            `{ \"medium\", \"ISO:medium\" }`\n            `{ \"demi\", \"demibold\" }`\n            `{ \"semi\", \"semibold\", \"ISO:semibold\" }`\n            `{ \"bold\", \"ISO:bold\" }`\n            `{ \"extra\", \"extrabold\", \"ISO:extrabold\" }`\n            `{ \"heavy\", \"heavyface\" }`\n            `{ \"black\", \"super\", \"ISO:ultrabold\" }`\n            `{ \"ultra\", \"ultrablack\", \"fat\" }`\n            `{ \"extrablack\", \"obese\", \"nord\" }`\n   * a table specifying zero or more traits for the font as defined in the [hs.styledtext.fontTraits](#fontTraits) table. A field with the key `_numeric` is also set which specified the numeric value corresponding to the traits for easy use with the [hs.styledtext.convertFont](#convertFont) function.","examples":[],"file":"extensions/styledtext/styledtext.lua","lineno":"196","name":"fontsForFamily","notes":[],"parameters":[" * `familyName` - a string specifying the font family to return available fonts for. The strings should be one of the values returned by the [hs.styledtext.fontFamiles](#fontFamilies) function."],"returns":[" * a table containing an array of available fonts for the specified family. Each array entry will be a table, also as an array, in the following order:","   * a string specifying the font name which can be used in the `hs.drawing:setTextFont(fontname)` method.","   * a string specifying the basic style of the font (e.g. Bold, Italic, Roman, etc.)","   * a table containing one or more strings specifying common names for the weight of the font. ISO equivalent names are preceded with \"ISO:\". Possible values are:","            `{ \"ultralight\" }`","            `{ \"thin\", \"ISO:ultralight\" }`","            `{ \"light\", \"extralight\", \"ISO:extralight\" }`","            `{ \"book\", \"ISO:light\" }`","            `{ \"regular\", \"plain\", \"display\", \"roman\", \"ISO:semilight\" }`","            `{ \"medium\", \"ISO:medium\" }`","            `{ \"demi\", \"demibold\" }`","            `{ \"semi\", \"semibold\", \"ISO:semibold\" }`","            `{ \"bold\", \"ISO:bold\" }`","            `{ \"extra\", \"extrabold\", \"ISO:extrabold\" }`","            `{ \"heavy\", \"heavyface\" }`","            `{ \"black\", \"super\", \"ISO:ultrabold\" }`","            `{ \"ultra\", \"ultrablack\", \"fat\" }`","            `{ \"extrablack\", \"obese\", \"nord\" }`","   * a table specifying zero or more traits for the font as defined in the [hs.styledtext.fontTraits](#fontTraits) table. A field with the key `_numeric` is also set which specified the numeric value corresponding to the traits for easy use with the [hs.styledtext.convertFont](#convertFont) function."],"signature":"hs.styledtext.fontsForFamily(familyName) -> table","stripped_doc":"","type":"Function"},"fontTraits":{"def":"hs.styledtext.fontTraits -> table","desc":"A table for containing Font Trait masks for use with `hs.styledtext.fontNamesWithTraits(...)`","doc":"A table for containing Font Trait masks for use with `hs.styledtext.fontNamesWithTraits(...)`\n\n * boldFont                    - fonts with the 'Bold' attribute set\n * compressedFont              - fonts with the 'Compressed' attribute set\n * condensedFont               - fonts with the 'Condensed' attribute set\n * expandedFont                - fonts with the 'Expanded' attribute set\n * fixedPitchFont              - fonts with the 'FixedPitch' attribute set\n * italicFont                  - fonts with the 'Italic' attribute set\n * narrowFont                  - fonts with the 'Narrow' attribute set\n * posterFont                  - fonts with the 'Poster' attribute set\n * smallCapsFont               - fonts with the 'SmallCaps' attribute set\n * nonStandardCharacterSetFont - fonts with the 'NonStandardCharacterSet' attribute set\n * unboldFont                  - fonts that do not have the 'Bold' attribute set\n * unitalicFont                - fonts that do not have the 'Italic' attribute set","file":"extensions/styledtext/libstyledtext.m","lineno":"383","name":"fontTraits","signature":"hs.styledtext.fontTraits -> table","stripped_doc":" * boldFont                    - fonts with the 'Bold' attribute set\n * compressedFont              - fonts with the 'Compressed' attribute set\n * condensedFont               - fonts with the 'Condensed' attribute set\n * expandedFont                - fonts with the 'Expanded' attribute set\n * fixedPitchFont              - fonts with the 'FixedPitch' attribute set\n * italicFont                  - fonts with the 'Italic' attribute set\n * narrowFont                  - fonts with the 'Narrow' attribute set\n * posterFont                  - fonts with the 'Poster' attribute set\n * smallCapsFont               - fonts with the 'SmallCaps' attribute set\n * nonStandardCharacterSetFont - fonts with the 'NonStandardCharacterSet' attribute set\n * unboldFont                  - fonts that do not have the 'Bold' attribute set\n * unitalicFont                - fonts that do not have the 'Italic' attribute set","type":"Constant"},"getString":{"def":"hs.styledtext:getString([starts], [ends]) -> string","desc":"Returns the text of the `hs.styledtext` object as a Lua String","doc":"Returns the text of the `hs.styledtext` object as a Lua String\n\nParameters:\n * starts - an optional index position within the text of the `hs.styledtext` object indicating the beginning of the substring to return the string for.  Defaults to 1, the beginning of the objects text.  If this number is negative, it is counted backwards from the end of the object's text (i.e. -1 would be the last character position).\n * ends   - an optional index position within the text of the `hs.styledtext` object indicating the end of the substring to return the string for.  Defaults to the length of the objects text.  If this number is negative, it is counted backwards from the end of the object's text.\n\nReturns:\n * a string containing the text of the `hs.styledtext` object specified\n\nNotes:\n * `starts` and `ends` follow the conventions of `i` and `j` for Lua's `string.sub` function.","examples":[],"file":"extensions/styledtext/libstyledtext.m","lineno":"897","name":"getString","notes":[" * `starts` and `ends` follow the conventions of `i` and `j` for Lua's `string.sub` function."],"parameters":[" * starts - an optional index position within the text of the `hs.styledtext` object indicating the beginning of the substring to return the string for.  Defaults to 1, the beginning of the objects text.  If this number is negative, it is counted backwards from the end of the object's text (i.e. -1 would be the last character position)."," * ends   - an optional index position within the text of the `hs.styledtext` object indicating the end of the substring to return the string for.  Defaults to the length of the objects text.  If this number is negative, it is counted backwards from the end of the object's text."],"returns":[" * a string containing the text of the `hs.styledtext` object specified"],"signature":"hs.styledtext:getString([starts], [ends]) -> string","stripped_doc":"","type":"Method"},"getStyledTextFromData":{"def":"hs.styledtext.getStyledTextFromData(data, [type]) -> styledText object","desc":"Converts the provided data into a styled text string.","doc":"Converts the provided data into a styled text string.\n\nParameters:\n * data          - the data, as a lua string, which contains the raw data to be converted to a styledText object\n * type          - a string indicating the format of the contents in `data`.  Defaults to \"html\".  The string may be one of the following (not all formats may be fully representable as a simple string container - see also `hs.styledtext.setTextFromFile`):\n   * \"text\"      - Plain text document.\n   * \"rtf\"        - Rich text format document.\n   * \"rtfd\"       - Rich text format with attachments document.\n   * \"simpleText\" - Macintosh SimpleText document.\n   * \"html\"       - Hypertext Markup Language (HTML) document.\n   * \"word\"       - Microsoft Word document.\n   * \"wordXML\"    - Microsoft Word XML (WordML schema) document.\n   * \"webArchive\" - Web Kit WebArchive document.\n   * \"openXML\"    - ECMA Office Open XML text document format.\n   * \"open\"       - OASIS Open Document text document format.\n\nReturns:\n * the styledText object\n\nNotes:\n * See also `hs.styledtext.getStyledTextFromFile`","examples":[],"file":"extensions/styledtext/libstyledtext.m","lineno":"100","name":"getStyledTextFromData","notes":[" * See also `hs.styledtext.getStyledTextFromFile`"],"parameters":[" * data          - the data, as a lua string, which contains the raw data to be converted to a styledText object"," * type          - a string indicating the format of the contents in `data`.  Defaults to \"html\".  The string may be one of the following (not all formats may be fully representable as a simple string container - see also `hs.styledtext.setTextFromFile`):\n   * \"text\"      - Plain text document.\n   * \"rtf\"        - Rich text format document.\n   * \"rtfd\"       - Rich text format with attachments document.\n   * \"simpleText\" - Macintosh SimpleText document.\n   * \"html\"       - Hypertext Markup Language (HTML) document.\n   * \"word\"       - Microsoft Word document.\n   * \"wordXML\"    - Microsoft Word XML (WordML schema) document.\n   * \"webArchive\" - Web Kit WebArchive document.\n   * \"openXML\"    - ECMA Office Open XML text document format.\n   * \"open\"       - OASIS Open Document text document format."],"returns":[" * the styledText object"],"signature":"hs.styledtext.getStyledTextFromData(data, [type]) -> styledText object","stripped_doc":"","type":"Constructor"},"getStyledTextFromFile":{"def":"hs.styledtext.getStyledTextFromFile(file, [type]) -> styledText object","desc":"Converts the data in the specified file into a styled text string.","doc":"Converts the data in the specified file into a styled text string.\n\nParameters:\n * file          - the path to the file to use as the source for the data to convert into a styledText object\n * type          - a string indicating the format of the contents in `data`.  Defaults to \"html\".  The string may be one of the following (not all formats may be fully representable as a simple string container - see also `hs.styledtext.setTextFromFile`):\n   * \"text\"      - Plain text document.\n   * \"rtf\"        - Rich text format document.\n   * \"rtfd\"       - Rich text format with attachments document.\n   * \"simpleText\" - Macintosh SimpleText document.\n   * \"html\"       - Hypertext Markup Language (HTML) document.\n   * \"word\"       - Microsoft Word document.\n   * \"wordXML\"    - Microsoft Word XML (WordML schema) document.\n   * \"webArchive\" - Web Kit WebArchive document.\n   * \"openXML\"    - ECMA Office Open XML text document format.\n   * \"open\"       - OASIS Open Document text document format.\n\nReturns:\n * the styledText object\n\nNotes:\n * See also `hs.styledtext.getStyledTextFromData`","examples":[],"file":"extensions/styledtext/libstyledtext.m","lineno":"178","name":"getStyledTextFromFile","notes":[" * See also `hs.styledtext.getStyledTextFromData`"],"parameters":[" * file          - the path to the file to use as the source for the data to convert into a styledText object"," * type          - a string indicating the format of the contents in `data`.  Defaults to \"html\".  The string may be one of the following (not all formats may be fully representable as a simple string container - see also `hs.styledtext.setTextFromFile`):\n   * \"text\"      - Plain text document.\n   * \"rtf\"        - Rich text format document.\n   * \"rtfd\"       - Rich text format with attachments document.\n   * \"simpleText\" - Macintosh SimpleText document.\n   * \"html\"       - Hypertext Markup Language (HTML) document.\n   * \"word\"       - Microsoft Word document.\n   * \"wordXML\"    - Microsoft Word XML (WordML schema) document.\n   * \"webArchive\" - Web Kit WebArchive document.\n   * \"openXML\"    - ECMA Office Open XML text document format.\n   * \"open\"       - OASIS Open Document text document format."],"returns":[" * the styledText object"],"signature":"hs.styledtext.getStyledTextFromFile(file, [type]) -> styledText object","stripped_doc":"","type":"Constructor"},"gmatch":{"def":"hs.styledtext:gmatch(pattern) -> iterator-function","desc":"Returns an iterator function which will return the captures (or the entire pattern) of the next match of the specified pattern in the text of the `hs.styledtext` object each time it is called.  Mimics the Lua `string.gmatch` function.","doc":"Returns an iterator function which will return the captures (or the entire pattern) of the next match of the specified pattern in the text of the `hs.styledtext` object each time it is called.  Mimics the Lua `string.gmatch` function.\n\nParameters:\n * pattern  - a string containing the pattern to locate.  See the Lua manual, section 6.4.1 (`help.lua._man._6_4_1`) for more details.\n\nReturns:\n * an iterator function which will return the captures (or the entire pattern) of the next match of the specified pattern in the text of the `hs.styledtext` object each time it is called.\n\nNotes:\n * Any captures (or the entire pattern) returned by the iterator are returned as Lua Strings, not as `hs.styledtext` objects.","examples":[],"file":"extensions/styledtext/styledtext.lua","lineno":"130","name":"gmatch","notes":[" * Any captures (or the entire pattern) returned by the iterator are returned as Lua Strings, not as `hs.styledtext` objects."],"parameters":[" * pattern  - a string containing the pattern to locate.  See the Lua manual, section 6.4.1 (`help.lua._man._6_4_1`) for more details."],"returns":[" * an iterator function which will return the captures (or the entire pattern) of the next match of the specified pattern in the text of the `hs.styledtext` object each time it is called."],"signature":"hs.styledtext:gmatch(pattern) -> iterator-function","stripped_doc":"","type":"Method"},"isIdentical":{"def":"hs.styledtext:isIdentical(styledText) -> boolean","desc":"Determine if the `styledText` object is identical to the one specified.","doc":"Determine if the `styledText` object is identical to the one specified.\n\nParameters:\n * styledText - an `hs.styledtext` object\n\nReturns:\n * a boolean value indicating whether or not the styled text objects are identical, both in text content and attributes specified.\n\nNotes:\n * comparing two `hs.styledtext` objects with the `==` operator only compares whether or not the string values are identical.  This method also compares their attributes.","examples":[],"file":"extensions/styledtext/libstyledtext.m","lineno":"724","name":"isIdentical","notes":[" * comparing two `hs.styledtext` objects with the `==` operator only compares whether or not the string values are identical.  This method also compares their attributes."],"parameters":[" * styledText - an `hs.styledtext` object"],"returns":[" * a boolean value indicating whether or not the styled text objects are identical, both in text content and attributes specified."],"signature":"hs.styledtext:isIdentical(styledText) -> boolean","stripped_doc":"","type":"Method"},"len":{"def":"hs.styledtext:len() -> integer","desc":"Returns the length of the text of the `hs.styledtext` object.  Mimics the Lua `string.len` function.","doc":"Returns the length of the text of the `hs.styledtext` object.  Mimics the Lua `string.len` function.\n\nParameters:\n * None\n\nReturns:\n * an integer which is the length of the text of the `hs.styledtext` object.","examples":[],"file":"extensions/styledtext/libstyledtext.m","lineno":"1315","name":"len","notes":[],"parameters":[" * None"],"returns":[" * an integer which is the length of the text of the `hs.styledtext` object."],"signature":"hs.styledtext:len() -> integer","stripped_doc":"","type":"Method"},"lineAppliesTo":{"def":"hs.styledtext.lineAppliesTo","desc":"A table of values indicating how the line for underlining or strike-through are applied to the text.","doc":"A table of values indicating how the line for underlining or strike-through are applied to the text.\n\nNotes:\n * Valid keys are as follows:\n   * line - the underline or strike-through is applied to an entire line of text\n   * word - the underline or strike-through is only applied to words and not the spaces in a line of text\n\n * When specifying a line type for underlining or strike-through, you can combine one entry from each of the following tables:\n   * hs.styledtext.lineStyles\n   * hs.styledtext.linePatterns\n   * hs.styledtext.lineAppliesTo\n\n * The entries chosen should be combined with the `or` operator to provide a single value. for example:\n   * hs.styledtext.lineStyles.single | hs.styledtext.linePatterns.dash | hs.styledtext.lineAppliesToWord","file":"extensions/styledtext/libstyledtext.m","lineno":"633","name":"lineAppliesTo","notes":[" * Valid keys are as follows:","   * line - the underline or strike-through is applied to an entire line of text","   * word - the underline or strike-through is only applied to words and not the spaces in a line of text",""," * When specifying a line type for underlining or strike-through, you can combine one entry from each of the following tables:","   * hs.styledtext.lineStyles","   * hs.styledtext.linePatterns","   * hs.styledtext.lineAppliesTo",""," * The entries chosen should be combined with the `or` operator to provide a single value. for example:","   * hs.styledtext.lineStyles.single | hs.styledtext.linePatterns.dash | hs.styledtext.lineAppliesToWord"],"signature":"hs.styledtext.lineAppliesTo","stripped_doc":" * When specifying a line type for underlining or strike-through, you can combine one entry from each of the following tables:\n   * hs.styledtext.lineStyles\n   * hs.styledtext.linePatterns\n   * hs.styledtext.lineAppliesTo\n * The entries chosen should be combined with the `or` operator to provide a single value. for example:\n   * hs.styledtext.lineStyles.single | hs.styledtext.linePatterns.dash | hs.styledtext.lineAppliesToWord","type":"Constant"},"linePatterns":{"def":"hs.styledtext.linePatterns","desc":"A table of patterns which apply to the line for underlining or strike-through.","doc":"A table of patterns which apply to the line for underlining or strike-through.\n\nNotes:\n * Valid line pattern keys are as follows:\n   * solid      - a solid line\n   * dot        - a dotted line\n   * dash       - a dashed line\n   * dashDot    - a pattern of a dash followed by a dot\n   * dashDotDot - a pattern of a dash followed by two dots\n\n * When specifying a line type for underlining or strike-through, you can combine one entry from each of the following tables:\n   * hs.styledtext.lineStyles\n   * hs.styledtext.linePatterns\n   * hs.styledtext.lineAppliesTo\n\n * The entries chosen should be combined with the `or` operator to provide a single value. for example:\n   * hs.styledtext.lineStyles.single | hs.styledtext.linePatterns.dash | hs.styledtext.lineAppliesToWord","file":"extensions/styledtext/libstyledtext.m","lineno":"599","name":"linePatterns","notes":[" * Valid line pattern keys are as follows:","   * solid      - a solid line","   * dot        - a dotted line","   * dash       - a dashed line","   * dashDot    - a pattern of a dash followed by a dot","   * dashDotDot - a pattern of a dash followed by two dots",""," * When specifying a line type for underlining or strike-through, you can combine one entry from each of the following tables:","   * hs.styledtext.lineStyles","   * hs.styledtext.linePatterns","   * hs.styledtext.lineAppliesTo",""," * The entries chosen should be combined with the `or` operator to provide a single value. for example:","   * hs.styledtext.lineStyles.single | hs.styledtext.linePatterns.dash | hs.styledtext.lineAppliesToWord"],"signature":"hs.styledtext.linePatterns","stripped_doc":" * When specifying a line type for underlining or strike-through, you can combine one entry from each of the following tables:\n   * hs.styledtext.lineStyles\n   * hs.styledtext.linePatterns\n   * hs.styledtext.lineAppliesTo\n * The entries chosen should be combined with the `or` operator to provide a single value. for example:\n   * hs.styledtext.lineStyles.single | hs.styledtext.linePatterns.dash | hs.styledtext.lineAppliesToWord","type":"Constant"},"lineStyles":{"def":"hs.styledtext.lineStyles","desc":"A table of styles which apply to the line for underlining or strike-through.","doc":"A table of styles which apply to the line for underlining or strike-through.\n\nNotes:\n * Valid line style keys are as follows:\n   * none   - no line style\n   * single - a single thin line\n   * thick  - a single thick line (usually double the single line's thickness)\n   * double - double think lines\n\n * When specifying a line type for underlining or strike-through, you can combine one entry from each of the following tables:\n   * hs.styledtext.lineStyles\n   * hs.styledtext.linePatterns\n   * hs.styledtext.lineAppliesTo\n\n * The entries chosen should be combined with the `or` operator to provide a single value. for example:\n   * hs.styledtext.lineStyles.single | hs.styledtext.linePatterns.dash | hs.styledtext.lineAppliesToWord","file":"extensions/styledtext/libstyledtext.m","lineno":"568","name":"lineStyles","notes":[" * Valid line style keys are as follows:","   * none   - no line style","   * single - a single thin line","   * thick  - a single thick line (usually double the single line's thickness)","   * double - double think lines",""," * When specifying a line type for underlining or strike-through, you can combine one entry from each of the following tables:","   * hs.styledtext.lineStyles","   * hs.styledtext.linePatterns","   * hs.styledtext.lineAppliesTo",""," * The entries chosen should be combined with the `or` operator to provide a single value. for example:","   * hs.styledtext.lineStyles.single | hs.styledtext.linePatterns.dash | hs.styledtext.lineAppliesToWord"],"signature":"hs.styledtext.lineStyles","stripped_doc":" * When specifying a line type for underlining or strike-through, you can combine one entry from each of the following tables:\n   * hs.styledtext.lineStyles\n   * hs.styledtext.linePatterns\n   * hs.styledtext.lineAppliesTo\n * The entries chosen should be combined with the `or` operator to provide a single value. for example:\n   * hs.styledtext.lineStyles.single | hs.styledtext.linePatterns.dash | hs.styledtext.lineAppliesToWord","type":"Constant"},"loadFont":{"def":"hs.styledtext.loadFont(path) -> boolean[, string]","desc":"Loads a font from a file at the specified path.","doc":"Loads a font from a file at the specified path.\n\nParameters:\n * `path` - the path and filename of the font file to attempt to load\n\nReturns:\n * If the font can be registered returns `true`, otherwise `false` and an error message as string.","examples":[],"file":"extensions/styledtext/libstyledtext.m","lineno":"1287","name":"loadFont","notes":[],"parameters":[" * `path` - the path and filename of the font file to attempt to load"],"returns":[" * If the font can be registered returns `true`, otherwise `false` and an error message as string."],"signature":"hs.styledtext.loadFont(path) -> boolean[, string]","stripped_doc":"","type":"Function"},"lower":{"def":"hs.styledtext:lower() -> styledText object","desc":"Returns a copy of the `hs.styledtext` object with all alpha characters converted to lower case.  Mimics the Lua `string.lower` function.","doc":"Returns a copy of the `hs.styledtext` object with all alpha characters converted to lower case.  Mimics the Lua `string.lower` function.\n\nParameters:\n * None\n\nReturns:\n * a copy of the `hs.styledtext` object with all alpha characters converted to lower case","examples":[],"file":"extensions/styledtext/libstyledtext.m","lineno":"1360","name":"lower","notes":[],"parameters":[" * None"],"returns":[" * a copy of the `hs.styledtext` object with all alpha characters converted to lower case"],"signature":"hs.styledtext:lower() -> styledText object","stripped_doc":"","type":"Method"},"match":{"def":"hs.styledtext:match(pattern, [init]) -> match ... | nil","desc":"Returns the first occurrence of the captures in the specified pattern (or the complete pattern, if no captures are specified) in the text of the `hs.styledtext` object.  Mimics the Lua `string.match` function.","doc":"Returns the first occurrence of the captures in the specified pattern (or the complete pattern, if no captures are specified) in the text of the `hs.styledtext` object.  Mimics the Lua `string.match` function.\n\nParameters:\n * pattern  - a string containing the pattern to locate.  See the Lua manual, section 6.4.1 (`help.lua._man._6_4_1`) for more details.\n * init     - an optional integer specifying the location within the text to start the pattern search\n\nReturns:\n * if a match is found, the captures in the specified pattern (or the complete pattern, if no captures are specified).  If the pattern was not found in the text, then this method returns nil.\n\nNotes:\n * Any captures (or the entire pattern) returned are returned as Lua Strings, not as `hs.styledtext` objects.","examples":[],"file":"extensions/styledtext/styledtext.lua","lineno":"115","name":"match","notes":[" * Any captures (or the entire pattern) returned are returned as Lua Strings, not as `hs.styledtext` objects."],"parameters":[" * pattern  - a string containing the pattern to locate.  See the Lua manual, section 6.4.1 (`help.lua._man._6_4_1`) for more details."," * init     - an optional integer specifying the location within the text to start the pattern search"],"returns":[" * if a match is found, the captures in the specified pattern (or the complete pattern, if no captures are specified).  If the pattern was not found in the text, then this method returns nil."],"signature":"hs.styledtext:match(pattern, [init]) -> match ... | nil","stripped_doc":"","type":"Method"},"new":{"def":"hs.styledtext.new(string, [attributes]) -> styledText object","desc":"Create an `hs.styledtext` object from the string or table representation provided.  Attributes to apply to the resulting string may also be optionally provided.","doc":"Create an `hs.styledtext` object from the string or table representation provided.  Attributes to apply to the resulting string may also be optionally provided.\n\nParameters:\n * string     - a string, table, or `hs.styledtext` object to create a new `hs.styledtext` object from.\n * attributes - an optional table containing attribute key-value pairs to apply to the entire `hs.styledtext` object to be returned.\n\nReturns:\n * an `hs.styledtext` object\n\nNotes:\n * See `hs.styledtext:asTable` for a description of the table representation of an `hs.styledtext` object\n * See the module description documentation (`help.hs.styledtext`) for a description of the attributes table format which can be provided for the optional second argument.\n\n * Passing an `hs.styledtext` object as the first parameter without specifying an `attributes` table is the equivalent of invoking `hs.styledtext:copy`.","examples":[],"file":"extensions/styledtext/libstyledtext.m","lineno":"66","name":"new","notes":[" * See `hs.styledtext:asTable` for a description of the table representation of an `hs.styledtext` object"," * See the module description documentation (`help.hs.styledtext`) for a description of the attributes table format which can be provided for the optional second argument.",""," * Passing an `hs.styledtext` object as the first parameter without specifying an `attributes` table is the equivalent of invoking `hs.styledtext:copy`."],"parameters":[" * string     - a string, table, or `hs.styledtext` object to create a new `hs.styledtext` object from."," * attributes - an optional table containing attribute key-value pairs to apply to the entire `hs.styledtext` object to be returned."],"returns":[" * an `hs.styledtext` object"],"signature":"hs.styledtext.new(string, [attributes]) -> styledText object","stripped_doc":" * Passing an `hs.styledtext` object as the first parameter without specifying an `attributes` table is the equivalent of invoking `hs.styledtext:copy`.","type":"Constructor"},"removeStyle":{"def":"hs.styledtext:removeStyle(attributes, [starts], [ends]) -> styledText object","desc":"Return a copy of the `hs.styledtext` object containing the changes to its attributes specified in the `attributes` table.","doc":"Return a copy of the `hs.styledtext` object containing the changes to its attributes specified in the `attributes` table.\n\nParameters:\n * attributes - an array of attribute labels to remove (set to `nil`) from the `hs.styledtext` object.\n * starts     - an optional index position within the text of the `hs.styledtext` object indicating the beginning of the substring to remove attributes for.  Defaults to 1, the beginning of the object's text.  If this number is negative, it is counted backwards from the end of the object's text (i.e. -1 would be the last character position).\n * ends       - an optional index position within the text of the `hs.styledtext` object indicating the end of the substring to remove attributes for.  Defaults to the length of the object's text.  If this number is negative, it is counted backwards from the end of the object's text.\n\nReturns:\n * a copy of the `hs.styledtext` object with the attributes specified removed from the given range of the original object.\n\nNotes:\n * `starts` and `ends` follow the conventions of `i` and `j` for Lua's `string.sub` function.\n\n * See the module description documentation (`help.hs.styledtext`) for a list of officially recognized attribute label names.\n * The officially recognized attribute labels were chosen for brevity or for consistency with conventions used in Hammerspoon's other modules.  If you know the Objective-C name for an attribute, you can list it instead of an officially recognized label, allowing the removal of attributes which this module cannot manipulate in other ways.","examples":[],"file":"extensions/styledtext/libstyledtext.m","lineno":"1022","name":"removeStyle","notes":[" * `starts` and `ends` follow the conventions of `i` and `j` for Lua's `string.sub` function.",""," * See the module description documentation (`help.hs.styledtext`) for a list of officially recognized attribute label names."," * The officially recognized attribute labels were chosen for brevity or for consistency with conventions used in Hammerspoon's other modules.  If you know the Objective-C name for an attribute, you can list it instead of an officially recognized label, allowing the removal of attributes which this module cannot manipulate in other ways."],"parameters":[" * attributes - an array of attribute labels to remove (set to `nil`) from the `hs.styledtext` object."," * starts     - an optional index position within the text of the `hs.styledtext` object indicating the beginning of the substring to remove attributes for.  Defaults to 1, the beginning of the object's text.  If this number is negative, it is counted backwards from the end of the object's text (i.e. -1 would be the last character position)."," * ends       - an optional index position within the text of the `hs.styledtext` object indicating the end of the substring to remove attributes for.  Defaults to the length of the object's text.  If this number is negative, it is counted backwards from the end of the object's text."],"returns":[" * a copy of the `hs.styledtext` object with the attributes specified removed from the given range of the original object."],"signature":"hs.styledtext:removeStyle(attributes, [starts], [ends]) -> styledText object","stripped_doc":" * See the module description documentation (`help.hs.styledtext`) for a list of officially recognized attribute label names.\n * The officially recognized attribute labels were chosen for brevity or for consistency with conventions used in Hammerspoon's other modules.  If you know the Objective-C name for an attribute, you can list it instead of an officially recognized label, allowing the removal of attributes which this module cannot manipulate in other ways.","type":"Method"},"rep":{"def":"hs.styledtext:rep(n, [separator]) -> styledText object","desc":"Returns an `hs.styledtext` object which contains `n` repetitions of the `hs.styledtext` object, optionally with `separator` between each repetition.  Mimics the Lua `string.rep` function.","doc":"Returns an `hs.styledtext` object which contains `n` repetitions of the `hs.styledtext` object, optionally with `separator` between each repetition.  Mimics the Lua `string.rep` function.\n\nParameters:\n * n         - the number of times to repeat the `hs.styledtext` object.\n * separator - an optional string or `hs.styledtext` object to insert between repetitions.\n\nReturns:\n * an `hs.styledtext` object which contains `n` repitions of the object, including `separator` between repetitions, if it is specified.","examples":[],"file":"extensions/styledtext/styledtext.lua","lineno":"145","name":"rep","notes":[],"parameters":[" * n         - the number of times to repeat the `hs.styledtext` object."," * separator - an optional string or `hs.styledtext` object to insert between repetitions."],"returns":[" * an `hs.styledtext` object which contains `n` repitions of the object, including `separator` between repetitions, if it is specified."],"signature":"hs.styledtext:rep(n, [separator]) -> styledText object","stripped_doc":"","type":"Method"},"setString":{"def":"hs.styledtext:setString(string, [starts], [ends], [clear]) -> styledText object","desc":"Return a copy of the `hs.styledtext` object containing the changes to its attributes specified in the `attributes` table.","doc":"Return a copy of the `hs.styledtext` object containing the changes to its attributes specified in the `attributes` table.\n\nParameters:\n * string     - a string, table, or `hs.styledtext` object to insert or replace the substring specified.\n * starts     - an optional index position within the text of the `hs.styledtext` object indicating the beginning of the destination for the specified string.  Defaults to 1, the beginning of the objects text.  If this number is negative, it is counted backwards from the end of the object's text (i.e. -1 would be the last character position).\n * ends       - an optional index position within the text of the `hs.styledtext` object indicating the end of destination for the specified string.  Defaults to the length of the objects text.  If this number is negative, it is counted backwards from the end of the object's text.  If this number is 0, then the substring is inserted at the index specified by `starts` rather than replacing it.\n * clear      - an optional boolean indicating whether or not the attributes of the new string should be included (true) or whether the new substring should inherit the attributes of the first character replaced (false).  Defaults to false if `string` is a Lua String or number; otherwise defaults to true.\n\nReturns:\n * a copy of the `hs.styledtext` object with the specified substring replacement to the original object, or nil if an error occurs\n\nNotes:\n * `starts` and `ends` follow the conventions of `i` and `j` for Lua's `string.sub` function except that `starts` must refer to an index preceding or equal to `ends`, even after negative and out-of-bounds indices are adjusted for.\n\n * See the module description documentation (`help.hs.styledtext`) for a description of the attributes table format","examples":[],"file":"extensions/styledtext/libstyledtext.m","lineno":"1137","name":"setString","notes":[" * `starts` and `ends` follow the conventions of `i` and `j` for Lua's `string.sub` function except that `starts` must refer to an index preceding or equal to `ends`, even after negative and out-of-bounds indices are adjusted for.",""," * See the module description documentation (`help.hs.styledtext`) for a description of the attributes table format"],"parameters":[" * string     - a string, table, or `hs.styledtext` object to insert or replace the substring specified."," * starts     - an optional index position within the text of the `hs.styledtext` object indicating the beginning of the destination for the specified string.  Defaults to 1, the beginning of the objects text.  If this number is negative, it is counted backwards from the end of the object's text (i.e. -1 would be the last character position)."," * ends       - an optional index position within the text of the `hs.styledtext` object indicating the end of destination for the specified string.  Defaults to the length of the objects text.  If this number is negative, it is counted backwards from the end of the object's text.  If this number is 0, then the substring is inserted at the index specified by `starts` rather than replacing it."," * clear      - an optional boolean indicating whether or not the attributes of the new string should be included (true) or whether the new substring should inherit the attributes of the first character replaced (false).  Defaults to false if `string` is a Lua String or number; otherwise defaults to true."],"returns":[" * a copy of the `hs.styledtext` object with the specified substring replacement to the original object, or nil if an error occurs"],"signature":"hs.styledtext:setString(string, [starts], [ends], [clear]) -> styledText object","stripped_doc":" * See the module description documentation (`help.hs.styledtext`) for a description of the attributes table format","type":"Method"},"setStyle":{"def":"hs.styledtext:setStyle(attributes, [starts], [ends], [clear]) -> styledText object","desc":"Return a copy of the `hs.styledtext` object containing the changes to its attributes specified in the `attributes` table.","doc":"Return a copy of the `hs.styledtext` object containing the changes to its attributes specified in the `attributes` table.\n\nParameters:\n * attributes - a table of attribute key-value pairs to apply to the object between the positions of `starts` and `ends`\n * starts     - an optional index position within the text of the `hs.styledtext` object indicating the beginning of the substring to set attributes for.  Defaults to 1, the beginning of the objects text.  If this number is negative, it is counted backwards from the end of the object's text (i.e. -1 would be the last character position).\n * ends       - an optional index position within the text of the `hs.styledtext` object indicating the end of the substring to set attributes for.  Defaults to the length of the objects text.  If this number is negative, it is counted backwards from the end of the object's text.\n * clear      - an optional boolean indicating whether or not the attributes specified should completely replace the existing attributes (true) or be added to/modify them (false).  Defaults to false.\n\nReturns:\n * a copy of the `hs.styledtext` object with the attributes specified applied to the given range of the original object.\n\nNotes:\n * `starts` and `ends` follow the conventions of `i` and `j` for Lua's `string.sub` function.\n\n * See the module description documentation (`help.hs.styledtext`) for a description of the attributes table format","examples":[],"file":"extensions/styledtext/libstyledtext.m","lineno":"952","name":"setStyle","notes":[" * `starts` and `ends` follow the conventions of `i` and `j` for Lua's `string.sub` function.",""," * See the module description documentation (`help.hs.styledtext`) for a description of the attributes table format"],"parameters":[" * attributes - a table of attribute key-value pairs to apply to the object between the positions of `starts` and `ends`"," * starts     - an optional index position within the text of the `hs.styledtext` object indicating the beginning of the substring to set attributes for.  Defaults to 1, the beginning of the objects text.  If this number is negative, it is counted backwards from the end of the object's text (i.e. -1 would be the last character position)."," * ends       - an optional index position within the text of the `hs.styledtext` object indicating the end of the substring to set attributes for.  Defaults to the length of the objects text.  If this number is negative, it is counted backwards from the end of the object's text."," * clear      - an optional boolean indicating whether or not the attributes specified should completely replace the existing attributes (true) or be added to/modify them (false).  Defaults to false."],"returns":[" * a copy of the `hs.styledtext` object with the attributes specified applied to the given range of the original object."],"signature":"hs.styledtext:setStyle(attributes, [starts], [ends], [clear]) -> styledText object","stripped_doc":" * See the module description documentation (`help.hs.styledtext`) for a description of the attributes table format","type":"Method"},"sub":{"def":"hs.styledtext:sub(starts, [ends]) -> styledText object","desc":"Returns a substring, including the style attributes, specified by the given indicies from the `hs.styledtext` object.  Mimics the Lua `string.sub` function.","doc":"Returns a substring, including the style attributes, specified by the given indicies from the `hs.styledtext` object.  Mimics the Lua `string.sub` function.\n\nParameters:\n * starts - the index position within the text of the `hs.styledtext` object indicating the beginning of the substring to return.  If this number is negative, it is counted backwards from the end of the object's text (i.e. -1 would be the last character position).\n * ends   - an optional index position within the text of the `hs.styledtext` object indicating the end of the substring to return.  Defaults to the length of the objects text.  If this number is negative, it is counted backwards from the end of the object's text.\n\nReturns:\n * an `hs.styledtext` object containing the specified substring.\n\nNotes:\n * `starts` and `ends` follow the conventions of `i` and `j` for Lua's `string.sub` function.","examples":[],"file":"extensions/styledtext/libstyledtext.m","lineno":"1384","name":"sub","notes":[" * `starts` and `ends` follow the conventions of `i` and `j` for Lua's `string.sub` function."],"parameters":[" * starts - the index position within the text of the `hs.styledtext` object indicating the beginning of the substring to return.  If this number is negative, it is counted backwards from the end of the object's text (i.e. -1 would be the last character position)."," * ends   - an optional index position within the text of the `hs.styledtext` object indicating the end of the substring to return.  Defaults to the length of the objects text.  If this number is negative, it is counted backwards from the end of the object's text."],"returns":[" * an `hs.styledtext` object containing the specified substring."],"signature":"hs.styledtext:sub(starts, [ends]) -> styledText object","stripped_doc":"","type":"Method"},"upper":{"def":"hs.styledtext:upper() -> styledText object","desc":"Returns a copy of the `hs.styledtext` object with all alpha characters converted to upper case.  Mimics the Lua `string.upper` function.","doc":"Returns a copy of the `hs.styledtext` object with all alpha characters converted to upper case.  Mimics the Lua `string.upper` function.\n\nParameters:\n * None\n\nReturns:\n * a copy of the `hs.styledtext` object with all alpha characters converted to upper case","examples":[],"file":"extensions/styledtext/libstyledtext.m","lineno":"1336","name":"upper","notes":[],"parameters":[" * None"],"returns":[" * a copy of the `hs.styledtext` object with all alpha characters converted to upper case"],"signature":"hs.styledtext:upper() -> styledText object","stripped_doc":"","type":"Method"},"validFont":{"def":"hs.styledtext.validFont(font) -> boolean","desc":"Checks to see if a font is valid.","doc":"Checks to see if a font is valid.\n\nParameters:\n * font - a string containing the name of the font you want to check.\n\nReturns:\n * `true` if valid, otherwise `false`.","examples":[],"file":"extensions/styledtext/libstyledtext.m","lineno":"428","name":"validFont","notes":[],"parameters":[" * font - a string containing the name of the font you want to check."],"returns":[" * `true` if valid, otherwise `false`."],"signature":"hs.styledtext.validFont(font) -> boolean","stripped_doc":"","type":"Function"}}