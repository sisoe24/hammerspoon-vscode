{"udp":{"type":"Module","doc":"Talk to custom protocols using asynchronous UDP sockets\n\nFor TCP sockets see [`hs.socket`](./hs.socket.html)\n\nYou can do a lot of neat trivial and non-trivial things with these. A simple ping ponger:\n```lua\nfunction ping(data, addr)\n  print(data)\n  addr = hs.socket.parseAddress(addr)\n  hs.timer.doAfter(1, function()\n    client:send(\"ping\", addr.host, addr.port)\n  end)\nend\n\nfunction pong(data, addr)\n  print(data)\n  addr = hs.socket.parseAddress(addr)\n  hs.timer.doAfter(1, function()\n    server:send(\"pong\", addr.host, addr.port)\n  end)\nend\n\nserver = hs.socket.udp.server(9001, pong):receive()\nclient = hs.socket.udp.new(ping):send(\"ping\", \"localhost\", 9001):receive()\n```\nResulting in the following endless exchange:\n```\n20:26:56    LuaSkin: (secondary thread): Data written to UDP socket\n            LuaSkin: (secondary thread): Data read from UDP socket\nping\n20:26:57    LuaSkin: (secondary thread): Data written to UDP socket\n            LuaSkin: (secondary thread): Data read from UDP socket\npong\n20:26:58    LuaSkin: (secondary thread): Data written to UDP socket\n            LuaSkin: (secondary thread): Data read from UDP socket\nping\n20:26:59    LuaSkin: (secondary thread): Data written to UDP socket\n            LuaSkin: (secondary thread): Data read from UDP socket\npong\n...\n```\n\nYou can do some silly things with a callback factory and enabling broadcasting:\n```lua\nlocal function callbackMaker(name)\n  local fun = function(data, addr)\n    addr = hs.socket.parseAddress(addr)\n    print(name..\" received data:\\n\"..data..\"\\nfrom host: \"..addr.host..\" port: \"..addr.port)\n  end\n  return fun\nend\n\nlocal listeners = {}\nlocal port = 9001\n\nfor i=1,3 do\n  table.insert(listeners, hs.socket.udp.new(callbackMaker(\"listener \"..i)):reusePort():listen(port):receive())\nend\n\nbroadcaster = hs.socket.udp.new():broadcast()\nbroadcaster:send(\"hello!\", \"255.255.255.255\", port)\n```\nSince neither IPv4 nor IPv6 have been disabled, the broadcast is received on both protocols ('dual-stack' IPv6 addresses shown):\n```\nlistener 2 received data:\nhello!\nfrom host: ::ffff:192.168.0.3 port: 53057\nlistener 1 received data:\nhello!\nfrom host: ::ffff:192.168.0.3 port: 53057\nlistener 3 received data:\nhello!\nfrom host: ::ffff:192.168.0.3 port: 53057\nlistener 1 received data:\nhello!\nfrom host: 192.168.0.3 port: 53057\nlistener 3 received data:\nhello!\nfrom host: 192.168.0.3 port: 53057\nlistener 2 received data:\nhello!\nfrom host: 192.168.0.3 port: 53057\n```\n","def":"-> hs.socket.udp"},"connect":{"def":"hs.socket:connect({host, port}|path[, fn]) -> self or nil","desc":"Connects an unconnected [`hs.socket`](#new) instance","doc":"Connects an unconnected [`hs.socket`](#new) instance\n\nParameters:\n * host - A string containing the hostname or IP address\n * port - A port number [1-65535]\n * path - A string containing the path to the Unix domain socket\n * fn - An optional single-use callback function to execute after establishing the connection. Receives no parameters\n\nReturns:\n * The [`hs.socket`](#new) object or `nil` if an error occurred\n\nNotes:\n * Either a host/port pair OR a Unix domain socket path must be supplied. If no port is passed, the first param is assumed to be a path to the socket file\n","examples":[],"file":"extensions/socket/libsocket.m","lineno":"234","name":"connect","notes":[" * Either a host/port pair OR a Unix domain socket path must be supplied. If no port is passed, the first param is assumed to be a path to the socket file"],"parameters":[" * host - A string containing the hostname or IP address"," * port - A port number [1-65535]"," * path - A string containing the path to the Unix domain socket"," * fn - An optional single-use callback function to execute after establishing the connection. Receives no parameters"],"returns":[" * The [`hs.socket`](#new) object or `nil` if an error occurred"],"signature":"hs.socket:connect({host, port}|path[, fn]) -> self or nil","stripped_doc":"","type":"Method"},"connected":{"def":"hs.socket:connected() -> bool","desc":"Returns the connection status of the [`hs.socket`](#new) instance","doc":"Returns the connection status of the [`hs.socket`](#new) instance\n\nParameters:\n * None\n\nReturns:\n * `true` if connected, otherwise `false`\n","examples":[],"file":"extensions/socket/libsocket.m","lineno":"575","name":"connected","notes":[],"parameters":[" * None"],"returns":[" * `true` if connected, otherwise `false`"],"signature":"hs.socket:connected() -> bool","stripped_doc":"","type":"Method"},"connections":{"def":"hs.socket:connections() -> number","desc":"Returns the number of connections to the socket, which is at most 1 for default (non-listening) sockets","doc":"Returns the number of connections to the socket, which is at most 1 for default (non-listening) sockets\n\nParameters:\n * None\n\nReturns:\n * The number of connections to the socket\n","examples":[],"file":"extensions/socket/libsocket.m","lineno":"593","name":"connections","notes":[],"parameters":[" * None"],"returns":[" * The number of connections to the socket"],"signature":"hs.socket:connections() -> number","stripped_doc":"","type":"Method"},"disconnect":{"def":"hs.socket:disconnect() -> self","desc":"Disconnects the [`hs.socket`](#new) instance, freeing it for reuse","doc":"Disconnects the [`hs.socket`](#new) instance, freeing it for reuse\n\nParameters:\n * None\n\nReturns:\n * The [`hs.socket`](#new) object\n\nNotes:\n * If called on a listening socket with multiple connections, each client is disconnected\n","examples":[],"file":"extensions/socket/libsocket.m","lineno":"345","name":"disconnect","notes":[" * If called on a listening socket with multiple connections, each client is disconnected"],"parameters":[" * None"],"returns":[" * The [`hs.socket`](#new) object"],"signature":"hs.socket:disconnect() -> self","stripped_doc":"","type":"Method"},"info":{"def":"hs.socket:info() -> table","desc":"Returns information on the [`hs.socket`](#new) instance","doc":"Returns information on the [`hs.socket`](#new) instance\n\nParameters:\n * None\n\nReturns:\n * A table containing the following keys:\n  * connectedAddress - `string` (`sockaddr` struct)\n  * connectedHost - `string`\n  * connectedPort - `number`\n  * connectedURL - `string`\n  * connections - `number`\n  * isConnected - `boolean`\n  * isDisconnected - `boolean`\n  * isIPv4 - `boolean`\n  * isIPv4Enabled - `boolean`\n  * isIPv4PreferredOverIPv6 - `boolean`\n  * isIPv6 - `boolean`\n  * isIPv6Enabled - `boolean`\n  * isSecure - `boolean`\n  * localAddress - `string` (`sockaddr` struct)\n  * localHost - `string`\n  * localPort - `number`\n  * timeout - `number`\n  * unixSocketPath - `string`\n  * userData - `string`\n","examples":[],"file":"extensions/socket/libsocket.m","lineno":"611","name":"info","notes":[],"parameters":[" * None"],"returns":[" * A table containing the following keys:","  * connectedAddress - `string` (`sockaddr` struct)","  * connectedHost - `string`","  * connectedPort - `number`","  * connectedURL - `string`","  * connections - `number`","  * isConnected - `boolean`","  * isDisconnected - `boolean`","  * isIPv4 - `boolean`","  * isIPv4Enabled - `boolean`","  * isIPv4PreferredOverIPv6 - `boolean`","  * isIPv6 - `boolean`","  * isIPv6Enabled - `boolean`","  * isSecure - `boolean`","  * localAddress - `string` (`sockaddr` struct)","  * localHost - `string`","  * localPort - `number`","  * timeout - `number`","  * unixSocketPath - `string`","  * userData - `string`"],"signature":"hs.socket:info() -> table","stripped_doc":"","type":"Method"},"listen":{"def":"hs.socket:listen(port|path) -> self or nil","desc":"Binds an unconnected [`hs.socket`](#new) instance to a port or path (Unix domain socket) for listening","doc":"Binds an unconnected [`hs.socket`](#new) instance to a port or path (Unix domain socket) for listening\n\nParameters:\n * port - A port number [0-65535]. Ports [1-1023] are privileged. Port 0 allows the OS to select any available port\n * path - A string containing the path to the Unix domain socket\n\nReturns:\n * The [`hs.socket`](#new) object or `nil` if an error occurred\n","examples":[],"file":"extensions/socket/libsocket.m","lineno":"297","name":"listen","notes":[],"parameters":[" * port - A port number [0-65535]. Ports [1-1023] are privileged. Port 0 allows the OS to select any available port"," * path - A string containing the path to the Unix domain socket"],"returns":[" * The [`hs.socket`](#new) object or `nil` if an error occurred"],"signature":"hs.socket:listen(port|path) -> self or nil","stripped_doc":"","type":"Method"},"new":{"def":"hs.socket.new([fn]) -> hs.socket object","desc":"Creates an unconnected asynchronous TCP socket object","doc":"Creates an unconnected asynchronous TCP socket object\n\nParameters:\n * fn - An optional [callback function](#setCallback) for reading data from the socket, settable here for convenience\n\nReturns:\n * An [`hs.socket`](#new) object\n","examples":[],"file":"extensions/socket/libsocket.m","lineno":"154","name":"new","notes":[],"parameters":[" * fn - An optional [callback function](#setCallback) for reading data from the socket, settable here for convenience"],"returns":[" * An [`hs.socket`](#new) object"],"signature":"hs.socket.new([fn]) -> hs.socket object","stripped_doc":"","type":"Constructor"},"parseAddress":{"def":"hs.socket.parseAddress(sockaddr) -> table or nil","desc":"Parses a binary socket address structure into a readable table","doc":"Parses a binary socket address structure into a readable table\n\nParameters:\n * sockaddr - A binary socket address structure, usually obtained from the [`info`](#info) method or in [`hs.socket.udp`](./hs.socket.udp.html)'s [read callback](./hs.socket.udp.html#setCallback)\n\nReturns:\n * A table describing the address with the following keys or `nil`:\n  * host - A string containing the host IP\n  * port - A number containing the port\n  * addressFamily - A number containing the address family\n\nNotes:\n * Some address family definitions from `<sys/socket.h>`:\n\naddress family | number | description\n:--- | :--- | :\nAF_UNSPEC | 0 | unspecified\nAF_UNIX | 1 | local to host (pipes)\nAF_LOCAL | AF_UNIX | backward compatibility\nAF_INET | 2 | internetwork: UDP, TCP, etc.\nAF_NS | 6 | XEROX NS protocols\nAF_CCITT | 10 | CCITT protocols, X.25 etc\nAF_APPLETALK | 16 | Apple Talk\nAF_ROUTE | 17 | Internal Routing Protocol\nAF_LINK | 18 | Link layer interface\nAF_INET6 | 30 | IPv6\n","examples":[],"file":"extensions/socket/libsocket.m","lineno":"187","name":"parseAddress","notes":[" * Some address family definitions from `<sys/socket.h>`:","","address family | number | description",":--- | :--- | :","AF_UNSPEC | 0 | unspecified","AF_UNIX | 1 | local to host (pipes)","AF_LOCAL | AF_UNIX | backward compatibility","AF_INET | 2 | internetwork: UDP, TCP, etc.","AF_NS | 6 | XEROX NS protocols","AF_CCITT | 10 | CCITT protocols, X.25 etc","AF_APPLETALK | 16 | Apple Talk","AF_ROUTE | 17 | Internal Routing Protocol","AF_LINK | 18 | Link layer interface","AF_INET6 | 30 | IPv6"],"parameters":[" * sockaddr - A binary socket address structure, usually obtained from the [`info`](#info) method or in [`hs.socket.udp`](./hs.socket.udp.html)'s [read callback](./hs.socket.udp.html#setCallback)"],"returns":[" * A table describing the address with the following keys or `nil`:","  * host - A string containing the host IP","  * port - A number containing the port","  * addressFamily - A number containing the address family"],"signature":"hs.socket.parseAddress(sockaddr) -> table or nil","stripped_doc":"address family | number | description\n:--- | :--- | :\nAF_UNSPEC | 0 | unspecified\nAF_UNIX | 1 | local to host (pipes)\nAF_LOCAL | AF_UNIX | backward compatibility\nAF_INET | 2 | internetwork: UDP, TCP, etc.\nAF_NS | 6 | XEROX NS protocols\nAF_CCITT | 10 | CCITT protocols, X.25 etc\nAF_APPLETALK | 16 | Apple Talk\nAF_ROUTE | 17 | Internal Routing Protocol\nAF_LINK | 18 | Link layer interface\nAF_INET6 | 30 | IPv6","type":"Function"},"read":{"def":"hs.socket:read(delimiter[, tag]) -> self or nil","desc":"Read data from the socket. Results are passed to the [callback function](#setCallback), which must be set to use this method","doc":"Read data from the socket. Results are passed to the [callback function](#setCallback), which must be set to use this method\n\nParameters:\n * delimiter - Either a number of bytes to read, or a string delimiter such as \"&#92;n\" or \"&#92;r&#92;n\". Data is read up to and including the delimiter\n * tag - An optional integer to assist with labeling reads. It is passed to the callback to assist with implementing [state machines](https://github.com/robbiehanson/CocoaAsyncSocket/wiki/Intro_GCDAsyncSocket#reading--writing) for processing complex protocols\n\nReturns:\n * The [`hs.socket`](#new) object or `nil` if an error occured\n\nNotes:\n * If called on a listening socket with multiple connections, data is read from each of them\n","examples":[],"file":"extensions/socket/libsocket.m","lineno":"369","name":"read","notes":[" * If called on a listening socket with multiple connections, data is read from each of them"],"parameters":[" * delimiter - Either a number of bytes to read, or a string delimiter such as \"&#92;n\" or \"&#92;r&#92;n\". Data is read up to and including the delimiter"," * tag - An optional integer to assist with labeling reads. It is passed to the callback to assist with implementing [state machines](https://github.com/robbiehanson/CocoaAsyncSocket/wiki/Intro_GCDAsyncSocket#reading--writing) for processing complex protocols"],"returns":[" * The [`hs.socket`](#new) object or `nil` if an error occured"],"signature":"hs.socket:read(delimiter[, tag]) -> self or nil","stripped_doc":"","type":"Method"},"receive":{"def":"hs.socket:receive(delimiter[, tag]) -> self","desc":"Alias for [`hs.socket:read`](#read)","doc":"Alias for [`hs.socket:read`](#read)\n","file":"extensions/socket/socket.lua","lineno":"219","name":"receive","notes":[],"parameters":[],"returns":[],"signature":"hs.socket:receive(delimiter[, tag]) -> self","stripped_doc":"","type":"Method"},"send":{"def":"hs.socket:send(message[, tag]) -> self","desc":"Alias for [`hs.socket:write`](#write)","doc":"Alias for [`hs.socket:write`](#write)\n","file":"extensions/socket/socket.lua","lineno":"225","name":"send","notes":[],"parameters":[],"returns":[],"signature":"hs.socket:send(message[, tag]) -> self","stripped_doc":"","type":"Method"},"server":{"def":"hs.socket.server(port|path[, fn]) -> hs.socket object","desc":"Creates and binds an [`hs.socket`](#new) instance to a port or path (Unix domain socket) for listening","doc":"Creates and binds an [`hs.socket`](#new) instance to a port or path (Unix domain socket) for listening\n\nParameters:\n * port - A port number [0-65535]. Ports [1-1023] are privileged. Port 0 allows the OS to select any available port\n * path - A string containing the path to the Unix domain socket\n * fn - An optional [callback function](#setCallback) for reading data from the socket, settable here for convenience\n\nReturns:\n * An [`hs.socket`](#new) object\n","examples":[],"file":"extensions/socket/socket.lua","lineno":"184","name":"server","notes":[],"parameters":[" * port - A port number [0-65535]. Ports [1-1023] are privileged. Port 0 allows the OS to select any available port"," * path - A string containing the path to the Unix domain socket"," * fn - An optional [callback function](#setCallback) for reading data from the socket, settable here for convenience"],"returns":[" * An [`hs.socket`](#new) object"],"signature":"hs.socket.server(port|path[, fn]) -> hs.socket object","stripped_doc":"","type":"Constructor"},"setCallback":{"def":"hs.socket:setCallback([fn]) -> self","desc":"Sets the read callback for the [`hs.socket`](#new) instance. Must be set to read data from the socket","doc":"Sets the read callback for the [`hs.socket`](#new) instance. Must be set to read data from the socket\n\nParameters:\n * fn - An optional callback function to process data read from the socket. `nil` or no argument clears the callback. The callback receives 2 parameters:\n   * data - The data read from the socket as a string\n   * tag - The integer tag associated with the read call, which defaults to -1\n\nReturns:\n * The [`hs.socket`](#new) object\n","examples":[],"file":"extensions/socket/libsocket.m","lineno":"472","name":"setCallback","notes":[],"parameters":[" * fn - An optional callback function to process data read from the socket. `nil` or no argument clears the callback. The callback receives 2 parameters:\n   * data - The data read from the socket as a string\n   * tag - The integer tag associated with the read call, which defaults to -1"],"returns":[" * The [`hs.socket`](#new) object"],"signature":"hs.socket:setCallback([fn]) -> self","stripped_doc":"","type":"Method"},"setTimeout":{"def":"hs.socket:setTimeout(timeout) -> self","desc":"Sets the timeout for the socket operations. If the timeout value is negative, the operations will not use a timeout, which is the default","doc":"Sets the timeout for the socket operations. If the timeout value is negative, the operations will not use a timeout, which is the default\n\nParameters:\n * timeout - A number containing the timeout duration, in seconds\n\nReturns:\n * The [`hs.socket`](#new) object\n","examples":[],"file":"extensions/socket/libsocket.m","lineno":"499","name":"setTimeout","notes":[],"parameters":[" * timeout - A number containing the timeout duration, in seconds"],"returns":[" * The [`hs.socket`](#new) object"],"signature":"hs.socket:setTimeout(timeout) -> self","stripped_doc":"","type":"Method"},"startTLS":{"def":"hs.socket:startTLS([verify][, peerName]) -> self","desc":"Secures the socket with TLS. The socket will disconnect immediately if TLS negotiation fails","doc":"Secures the socket with TLS. The socket will disconnect immediately if TLS negotiation fails\n\nParameters:\n * verify - An optional boolean that, if `false`, allows TLS handshaking with servers with self-signed certificates and does not evaluate the chain of trust. Defaults to `true` and omitted if `peerName` is supplied\n * peerName - An optional string containing the fully qualified domain name of the peer to validate against — for example, `store.apple.com`. It should match the name in the X.509 certificate given by the remote party. See notes below\n\nReturns:\n * The [`hs.socket`](#new) object\n\nNotes:\n* IMPORTANT SECURITY NOTE:\nThe default settings will check to make sure the remote party's certificate is signed by a\ntrusted 3rd party certificate agency (e.g. verisign) and that the certificate is not expired.\nHowever it will not verify the name on the certificate unless you\ngive it a name to verify against via `peerName`.\nThe security implications of this are important to understand.\nImagine you are attempting to create a secure connection to MySecureServer.com,\nbut your socket gets directed to MaliciousServer.com because of a hacked DNS server.\nIf you simply use the default settings, and MaliciousServer.com has a valid certificate,\nthe default settings will not detect any problems since the certificate is valid.\nTo properly secure your connection in this particular scenario you\nshould set `peerName` to \"MySecureServer.com\".\n","examples":[],"file":"extensions/socket/libsocket.m","lineno":"520","name":"startTLS","notes":["* IMPORTANT SECURITY NOTE:","The default settings will check to make sure the remote party's certificate is signed by a","trusted 3rd party certificate agency (e.g. verisign) and that the certificate is not expired.","However it will not verify the name on the certificate unless you","give it a name to verify against via `peerName`.","The security implications of this are important to understand.","Imagine you are attempting to create a secure connection to MySecureServer.com,","but your socket gets directed to MaliciousServer.com because of a hacked DNS server.","If you simply use the default settings, and MaliciousServer.com has a valid certificate,","the default settings will not detect any problems since the certificate is valid.","To properly secure your connection in this particular scenario you","should set `peerName` to \"MySecureServer.com\"."],"parameters":[" * verify - An optional boolean that, if `false`, allows TLS handshaking with servers with self-signed certificates and does not evaluate the chain of trust. Defaults to `true` and omitted if `peerName` is supplied"," * peerName - An optional string containing the fully qualified domain name of the peer to validate against — for example, `store.apple.com`. It should match the name in the X.509 certificate given by the remote party. See notes below"],"returns":[" * The [`hs.socket`](#new) object"],"signature":"hs.socket:startTLS([verify][, peerName]) -> self","stripped_doc":"","type":"Method"},"timeout":{"def":"hs.socket.timeout","desc":"Timeout for the socket operations, in seconds. New [`hs.socket`](#new) objects will be created with this timeout value, but can individually change it with the [`setTimeout`](#setTimeout) method","doc":"Timeout for the socket operations, in seconds. New [`hs.socket`](#new) objects will be created with this timeout value, but can individually change it with the [`setTimeout`](#setTimeout) method\n\nIf the timeout value is negative, the operations will not use a timeout. The default value is -1\n","file":"extensions/socket/socket.lua","lineno":"162","name":"timeout","signature":"hs.socket.timeout","stripped_doc":"If the timeout value is negative, the operations will not use a timeout. The default value is -1","type":"Variable"},"write":{"def":"hs.socket:write(message[, tag][, fn]) -> self","desc":"Write data to the socket","doc":"Write data to the socket\n\nParameters:\n * message - A string containing data to be sent on the socket\n * tag - An optional integer to assist with labeling writes\n * fn - An optional single-use callback function to execute after writing data to the socket. Receives the tag parameter\n\nReturns:\n * The [`hs.socket`](#new) object\n\nNotes:\n * If called on a listening socket with multiple connections, data is broadcasted to all connected sockets\n","examples":[],"file":"extensions/socket/libsocket.m","lineno":"428","name":"write","notes":[" * If called on a listening socket with multiple connections, data is broadcasted to all connected sockets"],"parameters":[" * message - A string containing data to be sent on the socket"," * tag - An optional integer to assist with labeling writes"," * fn - An optional single-use callback function to execute after writing data to the socket. Receives the tag parameter"],"returns":[" * The [`hs.socket`](#new) object"],"signature":"hs.socket:write(message[, tag][, fn]) -> self","stripped_doc":"","type":"Method"}}