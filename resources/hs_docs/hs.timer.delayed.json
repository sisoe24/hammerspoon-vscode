{"new":{"def":"hs.timer.delayed.new(delay, fn) -> hs.timer.delayed object","desc":"Creates a new delayed timer","doc":"Creates a new delayed timer\n\nParameters:\n * delay - number of seconds to wait for after a `:start()` invocation (the \"callback countdown\")\n * fn - a function to call after `delay` has fully elapsed without any further `:start()` invocations\n\nReturns:\n * a new `hs.timer.delayed` object\n\nNotes:\n * These timers are meant to be long-lived: once instantiated, there's no way to remove them from the run loop; create them once at the module level.\n * Delayed timers have specialized methods that behave differently from regular timers. When the `:start()` method is invoked, the timer will wait for `delay` seconds before calling `fn()`; this is referred to as the callback countdown. If `:start()` is invoked again before `delay` has elapsed, the countdown starts over again.\n * You can use a delayed timer to coalesce processing of unpredictable asynchronous events into a single callback; for example, if you have an event stream that happens in \"bursts\" of dozens of events at once, set an appropriate `delay` to wait for things to settle down, and then your callback will run just once.","examples":[],"file":"extensions/timer/timer.lua","lineno":"328","name":"new","notes":[" * These timers are meant to be long-lived: once instantiated, there's no way to remove them from the run loop; create them once at the module level."," * Delayed timers have specialized methods that behave differently from regular timers. When the `:start()` method is invoked, the timer will wait for `delay` seconds before calling `fn()`; this is referred to as the callback countdown. If `:start()` is invoked again before `delay` has elapsed, the countdown starts over again."," * You can use a delayed timer to coalesce processing of unpredictable asynchronous events into a single callback; for example, if you have an event stream that happens in \"bursts\" of dozens of events at once, set an appropriate `delay` to wait for things to settle down, and then your callback will run just once."],"parameters":[" * delay - number of seconds to wait for after a `:start()` invocation (the \"callback countdown\")"," * fn - a function to call after `delay` has fully elapsed without any further `:start()` invocations"],"returns":[" * a new `hs.timer.delayed` object"],"signature":"hs.timer.delayed.new(delay, fn) -> hs.timer.delayed object","stripped_doc":"","type":"Constructor"},"nextTrigger":{"def":"hs.timer.delayed:nextTrigger() -> number or nil","desc":"Returns the time left in the callback countdown","doc":"Returns the time left in the callback countdown\n\nParameters:\n * None\n\nReturns:\n * if the callback countdown is running, returns the number of seconds until it triggers; otherwise returns nil","examples":[],"file":"extensions/timer/timer.lua","lineno":"318","name":"nextTrigger","notes":[],"parameters":[" * None"],"returns":[" * if the callback countdown is running, returns the number of seconds until it triggers; otherwise returns nil"],"signature":"hs.timer.delayed:nextTrigger() -> number or nil","stripped_doc":"","type":"Method"},"running":{"def":"hs.timer.delayed:running() -> boolean","desc":"Returns a boolean indicating whether the callback countdown is running","doc":"Returns a boolean indicating whether the callback countdown is running\n\nParameters:\n * None\n\nReturns:\n * a boolean","examples":[],"file":"extensions/timer/timer.lua","lineno":"295","name":"running","notes":[],"parameters":[" * None"],"returns":[" * a boolean"],"signature":"hs.timer.delayed:running() -> boolean","stripped_doc":"","type":"Method"},"setDelay":{"def":"hs.timer.delayed:setDelay(delay) -> hs.timer.delayed object","desc":"Changes the callback countdown duration","doc":"Changes the callback countdown duration\n\nParameters:\n * None\n\nReturns:\n * the delayed timer object\n\nNotes:\n * if the callback countdown is running, calling this method will restart it","examples":[],"file":"extensions/timer/timer.lua","lineno":"305","name":"setDelay","notes":[" * if the callback countdown is running, calling this method will restart it"],"parameters":[" * None"],"returns":[" * the delayed timer object"],"signature":"hs.timer.delayed:setDelay(delay) -> hs.timer.delayed object","stripped_doc":"","type":"Method"},"start":{"def":"hs.timer.delayed:start([delay]) -> hs.timer.delayed object","desc":"Starts or restarts the callback countdown","doc":"Starts or restarts the callback countdown\n\nParameters:\n * delay - (optional) if provided, sets the countdown duration to this number of seconds for this time only; subsequent calls to `:start()` will revert to the original delay (or to the delay set with `:setDelay(delay)`)\n\nReturns:\n * the delayed timer object","examples":[],"file":"extensions/timer/timer.lua","lineno":"275","name":"start","notes":[],"parameters":[" * delay - (optional) if provided, sets the countdown duration to this number of seconds for this time only; subsequent calls to `:start()` will revert to the original delay (or to the delay set with `:setDelay(delay)`)"],"returns":[" * the delayed timer object"],"signature":"hs.timer.delayed:start([delay]) -> hs.timer.delayed object","stripped_doc":"","type":"Method"},"stop":{"def":"hs.timer.delayed:stop() -> hs.timer.delayed object","desc":"Cancels the callback countdown, if running; the callback will therefore not be triggered","doc":"Cancels the callback countdown, if running; the callback will therefore not be triggered\n\nParameters:\n * None\n\nReturns:\n * the delayed timer object","examples":[],"file":"extensions/timer/timer.lua","lineno":"285","name":"stop","notes":[],"parameters":[" * None"],"returns":[" * the delayed timer object"],"signature":"hs.timer.delayed:stop() -> hs.timer.delayed object","stripped_doc":"","type":"Method"}}