{"asciiOnly":{"def":"hs.utf8.asciiOnly(string[, all]) -> string","desc":"Returns the provided string with all non-printable ascii characters escaped, except Return, Linefeed, and Tab.","doc":"Returns the provided string with all non-printable ascii characters escaped, except Return, Linefeed, and Tab.\n\nParameters:\n * string - The input string which is to have all non-printable ascii characters escaped as \\x## (a single byte hexadecimal number).\n * all    - an optional boolean parameter (default false) indicating whether or not Return, Linefeed, and Tab should also be considered \"non-printable\"\n\nReturns:\n * The cleaned up string, with non-printable characters escaped.\n\nNotes:\n * Because Unicode characters outside of the basic ascii alphabet are multi-byte characters, any UTF8 or other Unicode encoded character will be broken up into their individual bytes and likely escaped by this function.\n * This function is useful for displaying binary data in a human readable way that might otherwise be inexpressible in the Hammerspoon console or other destination.  For example:\n   * `utf8.charpattern`, which contains the regular expression for matching valid UTF8 encoded sequences, results in `(null)` in the Hammerspoon console, but `hs.utf8.asciiOnly(utf8.charpattern)` will display `[\\x00-\\x7F\\xC2-\\xF4][\\x80-\\xBF]*`.","examples":[],"file":"extensions/utf8/utf8.lua","lineno":"296","name":"asciiOnly","notes":[" * Because Unicode characters outside of the basic ascii alphabet are multi-byte characters, any UTF8 or other Unicode encoded character will be broken up into their individual bytes and likely escaped by this function."," * This function is useful for displaying binary data in a human readable way that might otherwise be inexpressible in the Hammerspoon console or other destination.  For example:","   * `utf8.charpattern`, which contains the regular expression for matching valid UTF8 encoded sequences, results in `(null)` in the Hammerspoon console, but `hs.utf8.asciiOnly(utf8.charpattern)` will display `[\\x00-\\x7F\\xC2-\\xF4][\\x80-\\xBF]*`."],"parameters":[" * string - The input string which is to have all non-printable ascii characters escaped as \\x## (a single byte hexadecimal number)."," * all    - an optional boolean parameter (default false) indicating whether or not Return, Linefeed, and Tab should also be considered \"non-printable\""],"returns":[" * The cleaned up string, with non-printable characters escaped."],"signature":"hs.utf8.asciiOnly(string[, all]) -> string","stripped_doc":"","type":"Function"},"codepointToUTF8":{"def":"hs.utf8.codepointToUTF8(...) -> string","desc":"Wrapper to `utf8.char(...)` which ensures that all codepoints return valid UTF8 characters.","doc":"Wrapper to `utf8.char(...)` which ensures that all codepoints return valid UTF8 characters.\n\nParameters:\n * codepoints - A series of numeric Unicode code points to be converted to a UTF-8 byte sequences.  If a codepoint is a string (and does not start with U+, it is used as a key for lookup in `hs.utf8.registeredKeys[]`\n\nReturns:\n * A string containing the UTF-8 byte sequences corresponding to provided codepoints as a combined string.\n\nNotes:\n * Valid codepoint values are from 0x0000 - 0x10FFFF (0 - 1114111)\n * If the codepoint provided is a string that starts with U+, then the 'U+' is converted to a '0x' so that lua can properly treat the value as numeric.\n * Invalid codepoints are returned as the Unicode Replacement Character (U+FFFD)\n   * This includes out of range codepoints as well as the Unicode Surrogate codepoints (U+D800 - U+DFFF)","examples":[],"file":"extensions/utf8/utf8.lua","lineno":"72","name":"codepointToUTF8","notes":[" * Valid codepoint values are from 0x0000 - 0x10FFFF (0 - 1114111)"," * If the codepoint provided is a string that starts with U+, then the 'U+' is converted to a '0x' so that lua can properly treat the value as numeric."," * Invalid codepoints are returned as the Unicode Replacement Character (U+FFFD)","   * This includes out of range codepoints as well as the Unicode Surrogate codepoints (U+D800 - U+DFFF)"],"parameters":[" * codepoints - A series of numeric Unicode code points to be converted to a UTF-8 byte sequences.  If a codepoint is a string (and does not start with U+, it is used as a key for lookup in `hs.utf8.registeredKeys[]`"],"returns":[" * A string containing the UTF-8 byte sequences corresponding to provided codepoints as a combined string."],"signature":"hs.utf8.codepointToUTF8(...) -> string","stripped_doc":"","type":"Function"},"fixUTF8":{"def":"hs.utf8.fixUTF8(inString[, replacementChar]) -> outString, posTable","desc":"Replace invalid UTF8 character sequences in `inString` with `replacementChar` so it can be safely displayed in the console or other destination which requires valid UTF8 encoding.","doc":"Replace invalid UTF8 character sequences in `inString` with `replacementChar` so it can be safely displayed in the console or other destination which requires valid UTF8 encoding.\n\nParameters:\n * inString - String of characters which may contain invalid UTF8 byte sequences\n * replacementChar - optional parameter to replace invalid byte sequences in `inString`.  If this parameter is not provided, the default UTF8 replacement character, U+FFFD, is used.\n\nReturns:\n * outString - The contents of `inString` with all invalid UTF8 byte sequences replaced by the `replacementChar`.\n * posTable - a table of indexes in `outString` corresponding indicating where `replacementChar` has been used.\n\nNotes:\n * This function is a slight modification to code found at http://notebook.kulchenko.com/programming/fixing-malformed-utf8-in-lua.\n * If `replacementChar` is a multi-byte character (like U+FFFD) or multi character string, then the string length of `outString` will be longer than the string length of `inString`.  The character positions in `posTable` will reflect these new positions in `outString`.\n * To calculate the character position of the invalid characters in `inString`, use something like the following:\n\n      outString, outErrors = hs.utf8.fixUTF8(inString, replacement)\n      inErrors = {}\n      for i,p in ipairs(outErrors) do\n          table.insert(inErrors, p - ((i - 1) * string.length(replacement) - 1))\n      end\n\n   Where replacement is `utf8.char(0xFFFD)`, if you leave it out of the `hs.utf8.fixUTF8` function in the first line.\n","examples":[],"file":"extensions/utf8/utf8.lua","lineno":"121","name":"fixUTF8","notes":[" * This function is a slight modification to code found at http://notebook.kulchenko.com/programming/fixing-malformed-utf8-in-lua."," * If `replacementChar` is a multi-byte character (like U+FFFD) or multi character string, then the string length of `outString` will be longer than the string length of `inString`.  The character positions in `posTable` will reflect these new positions in `outString`."," * To calculate the character position of the invalid characters in `inString`, use something like the following:","","      outString, outErrors = hs.utf8.fixUTF8(inString, replacement)","      inErrors = {}","      for i,p in ipairs(outErrors) do","          table.insert(inErrors, p - ((i - 1) * string.length(replacement) - 1))","      end","","   Where replacement is `utf8.char(0xFFFD)`, if you leave it out of the `hs.utf8.fixUTF8` function in the first line."],"parameters":[" * inString - String of characters which may contain invalid UTF8 byte sequences"," * replacementChar - optional parameter to replace invalid byte sequences in `inString`.  If this parameter is not provided, the default UTF8 replacement character, U+FFFD, is used."],"returns":[" * outString - The contents of `inString` with all invalid UTF8 byte sequences replaced by the `replacementChar`."," * posTable - a table of indexes in `outString` corresponding indicating where `replacementChar` has been used."],"signature":"hs.utf8.fixUTF8(inString[, replacementChar]) -> outString, posTable","stripped_doc":"      outString, outErrors = hs.utf8.fixUTF8(inString, replacement)\n      inErrors = {}\n      for i,p in ipairs(outErrors) do\n          table.insert(inErrors, p - ((i - 1) * string.length(replacement) - 1))\n      end\n   Where replacement is `utf8.char(0xFFFD)`, if you leave it out of the `hs.utf8.fixUTF8` function in the first line.","type":"Function"},"hexDump":{"def":"hs.utf8.hexDump(inputString [, count]) -> string","desc":"Returns a hex dump of the provided string.  This is primarily useful for examining the exact makeup of binary data contained in a Lua String as individual bytes for debugging purposes.","doc":"Returns a hex dump of the provided string.  This is primarily useful for examining the exact makeup of binary data contained in a Lua String as individual bytes for debugging purposes.\n\nParameters:\n * inputString - the data to be rendered as individual hexadecimal bytes for examination.\n * count - an optional parameter specifying the number of bytes to display per line (default 16)\n\nReturns:\n * a string containing the hex dump of the input string.\n\nNotes:\n * Like hs.utf8.asciiOnly, this function will break up Unicode characters into their individual bytes.\n * As an example:\n     `hs.utf8.hexDump(utf8.charpattern)` will return\n     `00 : 5B 00 2D 7F C2 2D F4 5D 5B 80 2D BF 5D 2A        : [.-..-.][.-.]*`","examples":[],"file":"extensions/utf8/utf8.lua","lineno":"328","name":"hexDump","notes":[" * Like hs.utf8.asciiOnly, this function will break up Unicode characters into their individual bytes."," * As an example:","     `hs.utf8.hexDump(utf8.charpattern)` will return","     `00 : 5B 00 2D 7F C2 2D F4 5D 5B 80 2D BF 5D 2A        : [.-..-.][.-.]*`"],"parameters":[" * inputString - the data to be rendered as individual hexadecimal bytes for examination."," * count - an optional parameter specifying the number of bytes to display per line (default 16)"],"returns":[" * a string containing the hex dump of the input string."],"signature":"hs.utf8.hexDump(inputString [, count]) -> string","stripped_doc":"","type":"Function"},"registerCodepoint":{"def":"hs.utf8.registerCodepoint(label, codepoint) -> string","desc":"Registers a Unicode codepoint under the given label as a UTF-8 string of bytes which can be referenced by the label later in your code as `hs.utf8.registeredKeys[label]` for convenience and readability.","doc":"Registers a Unicode codepoint under the given label as a UTF-8 string of bytes which can be referenced by the label later in your code as `hs.utf8.registeredKeys[label]` for convenience and readability.\n\nParameters:\n * label - a string label to use as a human-readable reference when getting the UTF-8 byte sequence for use in other strings and output functions.\n * codepoint - a Unicode codepoint in numeric or `U+xxxx` format to register with the given label.\n\nReturns:\n * Returns the UTF-8 byte sequence for the Unicode codepoint registered.\n\nNotes:\n * If a codepoint label was previously registered, this will overwrite the previous value with a new one.  Because many of the special keys you may want to register have different variants, this allows you to easily modify the existing predefined defaults to suite your preferences.\n * The return value is merely syntactic sugar and you do not need to save it locally; it can be safely ignored -- future access to the pre-converted codepoint should be retrieved as `hs.utf8.registeredKeys[label]` in your code.  It looks good when invoked from the console, though ☺.","examples":[],"file":"extensions/utf8/utf8.lua","lineno":"169","name":"registerCodepoint","notes":[" * If a codepoint label was previously registered, this will overwrite the previous value with a new one.  Because many of the special keys you may want to register have different variants, this allows you to easily modify the existing predefined defaults to suite your preferences."," * The return value is merely syntactic sugar and you do not need to save it locally; it can be safely ignored -- future access to the pre-converted codepoint should be retrieved as `hs.utf8.registeredKeys[label]` in your code.  It looks good when invoked from the console, though ☺."],"parameters":[" * label - a string label to use as a human-readable reference when getting the UTF-8 byte sequence for use in other strings and output functions."," * codepoint - a Unicode codepoint in numeric or `U+xxxx` format to register with the given label."],"returns":[" * Returns the UTF-8 byte sequence for the Unicode codepoint registered."],"signature":"hs.utf8.registerCodepoint(label, codepoint) -> string","stripped_doc":"","type":"Function"},"registeredKeys":{"def":"hs.utf8.registeredKeys[]","desc":"A collection of UTF-8 characters already converted from codepoint and available as convenient key-value pairs.  UTF-8 printable versions of common Apple and OS X special keys are predefined and others can be added with `hs.utf8.registerCodepoint(label, codepoint)` for your own use.","doc":"A collection of UTF-8 characters already converted from codepoint and available as convenient key-value pairs.  UTF-8 printable versions of common Apple and OS X special keys are predefined and others can be added with `hs.utf8.registerCodepoint(label, codepoint)` for your own use.\n\nPredefined keys include:\n\n    (U+2325) alt              ⌥\n    (U+F8FF) apple            \n    (U+21E4) backtab          ⇤\n    (U+21EA) capslock         ⇪\n    (U+2713) checkMark        ✓\n    (U+2318) cmd              ⌘\n    (U+27E1) concaveDiamond   ✧\n    (U+00A9) copyrightSign    ©\n    (U+2303) ctrl             ⌃\n    (U+232B) delete           ⌫\n    (U+2193) down             ↓\n    (U+21E3) down2            ⇣\n    (U+23CF) eject            ⏏\n    (U+21F2) end              ⇲\n    (U+2198) end2             ↘\n    (U+238B) escape           ⎋\n    (U+2326) forwarddelete    ⌦\n    (U+FE56) help             ﹖\n    (U+21F1) home             ⇱\n    (U+2196) home2            ↖\n    (U+21B8) home3            ↸\n    (U+2190) left             ←\n    (U+21E0) left2            ⇠\n    (U+201C) leftDoubleQuote  “\n    (U+2018) leftSingleQuote  ‘\n    (U+00B7) middleDot        ·\n    (U+21ED) numlock          ⇭\n    (U+2325) option           ⌥\n    (U+2327) padclear         ⌧\n    (U+2324) padenter         ⌤\n    (U+2386) padenter2        ⎆\n    (U+21A9) padenter3        ↩\n    (U+21DF) pagedown         ⇟\n    (U+21DE) pageup           ⇞\n    (U+233D) power            ⌽\n    (U+00AE) registeredSign   ®\n    (U+23CE) return           ⏎\n    (U+21A9) return2          ↩\n    (U+2192) right            →\n    (U+21E2) right2           ⇢\n    (U+201D) rightDoubleQuote  ”\n    (U+2019) rightSingleQuote  ’\n    (U+00A7) sectionSign      §\n    (U+21E7) shift            ⇧\n    (U+2423) space            ␣\n    (U+21E5) tab              ⇥\n    (U+2191) up               ↑\n    (U+21E1) up2              ⇡\n\nNotes:\n * This table has a __tostring() metamethod which allows listing it's contents in the Hammerspoon console by typing `hs.utf8.registeredKeys`.\n * For parity with `hs.utf8.registeredLabels`, this can also invoked as a function, i.e. `hs.utf8.registeredKeys[\"cmd\"]` is equivalent to `hs.utf8.registeredKeys(\"cmd\")`","file":"extensions/utf8/utf8.lua","lineno":"188","name":"registeredKeys","notes":[" * This table has a __tostring() metamethod which allows listing it's contents in the Hammerspoon console by typing `hs.utf8.registeredKeys`."," * For parity with `hs.utf8.registeredLabels`, this can also invoked as a function, i.e. `hs.utf8.registeredKeys[\"cmd\"]` is equivalent to `hs.utf8.registeredKeys(\"cmd\")`"],"signature":"hs.utf8.registeredKeys[]","stripped_doc":"Predefined keys include:\n    (U+2325) alt              ⌥\n    (U+F8FF) apple            \n    (U+21E4) backtab          ⇤\n    (U+21EA) capslock         ⇪\n    (U+2713) checkMark        ✓\n    (U+2318) cmd              ⌘\n    (U+27E1) concaveDiamond   ✧\n    (U+00A9) copyrightSign    ©\n    (U+2303) ctrl             ⌃\n    (U+232B) delete           ⌫\n    (U+2193) down             ↓\n    (U+21E3) down2            ⇣\n    (U+23CF) eject            ⏏\n    (U+21F2) end              ⇲\n    (U+2198) end2             ↘\n    (U+238B) escape           ⎋\n    (U+2326) forwarddelete    ⌦\n    (U+FE56) help             ﹖\n    (U+21F1) home             ⇱\n    (U+2196) home2            ↖\n    (U+21B8) home3            ↸\n    (U+2190) left             ←\n    (U+21E0) left2            ⇠\n    (U+201C) leftDoubleQuote  “\n    (U+2018) leftSingleQuote  ‘\n    (U+00B7) middleDot        ·\n    (U+21ED) numlock          ⇭\n    (U+2325) option           ⌥\n    (U+2327) padclear         ⌧\n    (U+2324) padenter         ⌤\n    (U+2386) padenter2        ⎆\n    (U+21A9) padenter3        ↩\n    (U+21DF) pagedown         ⇟\n    (U+21DE) pageup           ⇞\n    (U+233D) power            ⌽\n    (U+00AE) registeredSign   ®\n    (U+23CE) return           ⏎\n    (U+21A9) return2          ↩\n    (U+2192) right            →\n    (U+21E2) right2           ⇢\n    (U+201D) rightDoubleQuote  ”\n    (U+2019) rightSingleQuote  ’\n    (U+00A7) sectionSign      §\n    (U+21E7) shift            ⇧\n    (U+2423) space            ␣\n    (U+21E5) tab              ⇥\n    (U+2191) up               ↑\n    (U+21E1) up2              ⇡","type":"Variable"},"registeredLabels":{"def":"hs.utf8.registeredLabels(utf8char) -> string","desc":"Returns the label name for a UTF8 character, as it is registered in `hs.utf8.registeredKeys[]`.","doc":"Returns the label name for a UTF8 character, as it is registered in `hs.utf8.registeredKeys[]`.\n\nParameters:\n * utf8char -- the character to lookup in `hs.utf8.registeredKeys[]`\n\nReturns:\n * The string label for the UTF8 character or a string in the format of \"U+XXXX\", if it is not defined in `hs.utf8.registeredKeys[]`, or nil, if utf8char is not a valid UTF8 character.\n\nNotes:\n * For parity with `hs.utf8.registeredKeys`, this can also be invoked as if it were an array: i.e. `hs.utf8.registeredLabels(char)` is equivalent to `hs.utf8.registeredLabels[char]`","examples":[],"file":"extensions/utf8/utf8.lua","lineno":"46","name":"registeredLabels","notes":[" * For parity with `hs.utf8.registeredKeys`, this can also be invoked as if it were an array: i.e. `hs.utf8.registeredLabels(char)` is equivalent to `hs.utf8.registeredLabels[char]`"],"parameters":[" * utf8char -- the character to lookup in `hs.utf8.registeredKeys[]`"],"returns":[" * The string label for the UTF8 character or a string in the format of \"U+XXXX\", if it is not defined in `hs.utf8.registeredKeys[]`, or nil, if utf8char is not a valid UTF8 character."],"signature":"hs.utf8.registeredLabels(utf8char) -> string","stripped_doc":"","type":"Function"}}
