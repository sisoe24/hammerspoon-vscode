{"delayed":{"type":"Module","doc":"Specialized timer objects to coalesce processing of unpredictable asynchronous events into a single callback","def":"-> hs.timer.delayed"},"absoluteTime":{"def":"hs.timer.absoluteTime() -> nanoseconds","desc":"Returns the absolute time in nanoseconds since the last system boot.","doc":"Returns the absolute time in nanoseconds since the last system boot.\n\nParameters:\n * None\n\nReturns:\n * the time since the last system boot in nanoseconds\n\nNotes:\n * this value does not include time that the system has spent asleep\n * this value is used for the timestamps in system generated events.","examples":[],"file":"extensions/timer/libtimer.m","lineno":"447","name":"absoluteTime","notes":[" * this value does not include time that the system has spent asleep"," * this value is used for the timestamps in system generated events."],"parameters":[" * None"],"returns":[" * the time since the last system boot in nanoseconds"],"signature":"hs.timer.absoluteTime() -> nanoseconds","stripped_doc":"","type":"Function"},"days":{"def":"hs.timer.days(n) -> sec","desc":"Converts days to seconds","doc":"Converts days to seconds\n\nParameters:\n * n - A number of days\n\nReturns:\n * The number of seconds in n days","examples":[],"file":"extensions/timer/timer.lua","lineno":"81","name":"days","notes":[],"parameters":[" * n - A number of days"],"returns":[" * The number of seconds in n days"],"signature":"hs.timer.days(n) -> sec","stripped_doc":"","type":"Function"},"doAfter":{"def":"hs.timer.doAfter(sec, fn) -> timer","desc":"Calls a function after a delay","doc":"Calls a function after a delay\n\nParameters:\n * sec - A number of seconds to wait before calling the function\n * fn - A function to call\n\nReturns:\n * An `hs.timer` object\n\nNotes:\n * There is no need to call `:start()` on the returned object, the timer will be already running.\n * The callback can be cancelled by calling the `:stop()` method on the returned object before `sec` seconds have passed.","examples":[],"file":"extensions/timer/libtimer.m","lineno":"205","name":"doAfter","notes":[" * There is no need to call `:start()` on the returned object, the timer will be already running."," * The callback can be cancelled by calling the `:stop()` method on the returned object before `sec` seconds have passed."],"parameters":[" * sec - A number of seconds to wait before calling the function"," * fn - A function to call"],"returns":[" * An `hs.timer` object"],"signature":"hs.timer.doAfter(sec, fn) -> timer","stripped_doc":"","type":"Constructor"},"doAt":{"def":"hs.timer.doAt(time[, repeatInterval], fn[, continueOnError]) -> timer","desc":"Creates and starts a timer which will perform `fn` at the given (local) `time` and then (optionally) repeat it every `interval`.","doc":"Creates and starts a timer which will perform `fn` at the given (local) `time` and then (optionally) repeat it every `interval`.\n\nParameters:\n * time - number of seconds after (local) midnight, or a string in the format \"HH:MM\" (24-hour local time), indicating\n   the desired trigger time\n * repeatInterval - (optional) number of seconds between triggers, or a string in the format\n   \"DDd\", \"DDdHHh\", \"HHhMMm\", \"HHh\" or \"MMm\" indicating days, hours and/or minutes between triggers; if omitted\n   or `0` the timer will trigger only once\n * fn - a function to call every time the timer triggers\n * continueOnError - an optional boolean flag, defaulting to false, which indicates that the timer should not be automatically stopped if the callback function results in an error.\n\nReturns:\n * a timer object\n\nNotes:\n * The timer can trigger up to 1 second early or late\n * The first trigger will be set to the earliest occurrence given the `repeatInterval`; if that's omitted,\n   and `time` is earlier than the current time, the timer will trigger the next day. If the repeated interval\n   results in exactly 24 hours you can schedule regular jobs that will run at the expected time independently\n   of when Hammerspoon was restarted/reloaded. E.g.:\n   * If it's 19:00, `hs.timer.doAt(\"20:00\",somefn)` will set the timer 1 hour from now\n   * If it's 21:00, `hs.timer.doAt(\"20:00\",somefn)` will set the timer 23 hours from now\n   * If it's 21:00, `hs.timer.doAt(\"20:00\",\"6h\",somefn)` will set the timer 5 hours from now (at 02:00)\n   * To run a job every hour on the hour from 8:00 to 20:00: `for h=8,20 do hs.timer.doAt(h..\":00\",\"1d\",runJob) end`","examples":[],"file":"extensions/timer/timer.lua","lineno":"229","name":"doAt","notes":[" * The timer can trigger up to 1 second early or late"," * The first trigger will be set to the earliest occurrence given the `repeatInterval`; if that's omitted,","   and `time` is earlier than the current time, the timer will trigger the next day. If the repeated interval","   results in exactly 24 hours you can schedule regular jobs that will run at the expected time independently","   of when Hammerspoon was restarted/reloaded. E.g.:","   * If it's 19:00, `hs.timer.doAt(\"20:00\",somefn)` will set the timer 1 hour from now","   * If it's 21:00, `hs.timer.doAt(\"20:00\",somefn)` will set the timer 23 hours from now","   * If it's 21:00, `hs.timer.doAt(\"20:00\",\"6h\",somefn)` will set the timer 5 hours from now (at 02:00)","   * To run a job every hour on the hour from 8:00 to 20:00: `for h=8,20 do hs.timer.doAt(h..\":00\",\"1d\",runJob) end`"],"parameters":[" * time - number of seconds after (local) midnight, or a string in the format \"HH:MM\" (24-hour local time), indicating the desired trigger time"," * repeatInterval - (optional) number of seconds between triggers, or a string in the format \"DDd\", \"DDdHHh\", \"HHhMMm\", \"HHh\" or \"MMm\" indicating days, hours and/or minutes between triggers; if omitted or `0` the timer will trigger only once"," * fn - a function to call every time the timer triggers"," * continueOnError - an optional boolean flag, defaulting to false, which indicates that the timer should not be automatically stopped if the callback function results in an error."],"returns":[" * a timer object"],"signature":"hs.timer.doAt(time[, repeatInterval], fn[, continueOnError]) -> timer","stripped_doc":"","type":"Constructor"},"doEvery":{"def":"hs.timer.doEvery(interval, fn) -> timer","desc":"Repeats fn every interval seconds.","doc":"Repeats fn every interval seconds.\n\nParameters:\n * interval - A number of seconds between triggers\n * fn - A function to call every time the timer triggers\n\nReturns:\n * An `hs.timer` object\n\nNotes:\n * This function is a shorthand for `hs.timer.new(interval, fn):start()`","examples":[],"file":"extensions/timer/timer.lua","lineno":"159","name":"doEvery","notes":[" * This function is a shorthand for `hs.timer.new(interval, fn):start()`"],"parameters":[" * interval - A number of seconds between triggers"," * fn - A function to call every time the timer triggers"],"returns":[" * An `hs.timer` object"],"signature":"hs.timer.doEvery(interval, fn) -> timer","stripped_doc":"","type":"Constructor"},"doUntil":{"def":"hs.timer.doUntil(predicateFn, actionFn[, checkInterval]) -> timer","desc":"Creates and starts a timer which will perform `actionFn` every `checkinterval` seconds until `predicateFn` returns true.  The timer is automatically stopped when `predicateFn` returns true.","doc":"Creates and starts a timer which will perform `actionFn` every `checkinterval` seconds until `predicateFn` returns true.  The timer is automatically stopped when `predicateFn` returns true.\n\nParameters:\n * predicateFn - a function which determines when to stop calling `actionFn`.  This function takes no arguments, but should return true when it is time to stop calling `actionFn`.\n * actionFn - a function which performs the desired action.  This function may take a single argument, the timer itself.\n * checkInterval - an optional parameter indicating how often to repeat the `predicateFn` check. Defaults to 1 second.\n\nReturns:\n * a timer object\n\nNotes:\n * The timer is passed as an argument to `actionFn` so that it may stop the timer prematurely (i.e. before predicateFn returns true) if desired.\n * See also `hs.timer.doWhile`, which is essentially the opposite of this function","examples":[],"file":"extensions/timer/timer.lua","lineno":"131","name":"doUntil","notes":[" * The timer is passed as an argument to `actionFn` so that it may stop the timer prematurely (i.e. before predicateFn returns true) if desired."," * See also `hs.timer.doWhile`, which is essentially the opposite of this function"],"parameters":[" * predicateFn - a function which determines when to stop calling `actionFn`.  This function takes no arguments, but should return true when it is time to stop calling `actionFn`."," * actionFn - a function which performs the desired action.  This function may take a single argument, the timer itself."," * checkInterval - an optional parameter indicating how often to repeat the `predicateFn` check. Defaults to 1 second."],"returns":[" * a timer object"],"signature":"hs.timer.doUntil(predicateFn, actionFn[, checkInterval]) -> timer","stripped_doc":"","type":"Constructor"},"doWhile":{"def":"hs.timer.doWhile(predicateFn, actionFn[, checkInterval]) -> timer","desc":"Creates and starts a timer which will perform `actionFn` every `checkinterval` seconds while `predicateFn` returns true.  The timer is automatically stopped when `predicateFn` returns false.","doc":"Creates and starts a timer which will perform `actionFn` every `checkinterval` seconds while `predicateFn` returns true.  The timer is automatically stopped when `predicateFn` returns false.\n\nParameters:\n * predicateFn - a function which determines when to stop calling `actionFn`.  This function takes no arguments, but should return false when it is time to stop calling `actionFn`.\n * actionFn - a function which performs the desired action.  This function may take a single argument, the timer itself.\n * checkInterval - an optional parameter indicating how often to repeat the `predicateFn` check. Defaults to 1 second.\n\nReturns:\n * a timer object\n\nNotes:\n * The timer is passed as an argument to `actionFn` so that it may stop the timer prematurely (i.e. before predicateFn returns false) if desired.\n * See also `hs.timer.doUntil`, which is essentially the opposite of this function","examples":[],"file":"extensions/timer/timer.lua","lineno":"195","name":"doWhile","notes":[" * The timer is passed as an argument to `actionFn` so that it may stop the timer prematurely (i.e. before predicateFn returns false) if desired."," * See also `hs.timer.doUntil`, which is essentially the opposite of this function"],"parameters":[" * predicateFn - a function which determines when to stop calling `actionFn`.  This function takes no arguments, but should return false when it is time to stop calling `actionFn`."," * actionFn - a function which performs the desired action.  This function may take a single argument, the timer itself."," * checkInterval - an optional parameter indicating how often to repeat the `predicateFn` check. Defaults to 1 second."],"returns":[" * a timer object"],"signature":"hs.timer.doWhile(predicateFn, actionFn[, checkInterval]) -> timer","stripped_doc":"","type":"Constructor"},"fire":{"def":"hs.timer:fire() -> timer","desc":"Immediately fires a timer","doc":"Immediately fires a timer\n\nParameters:\n * None\n\nReturns:\n * The `hs.timer` object\n\nNotes:\n * This cannot be used on a timer which has already stopped running","examples":[],"file":"extensions/timer/libtimer.m","lineno":"336","name":"fire","notes":[" * This cannot be used on a timer which has already stopped running"],"parameters":[" * None"],"returns":[" * The `hs.timer` object"],"signature":"hs.timer:fire() -> timer","stripped_doc":"","type":"Method"},"hours":{"def":"hs.timer.hours(n) -> seconds","desc":"Converts hours to seconds","doc":"Converts hours to seconds\n\nParameters:\n * n - A number of hours\n\nReturns:\n * The number of seconds in n hours","examples":[],"file":"extensions/timer/timer.lua","lineno":"70","name":"hours","notes":[],"parameters":[" * n - A number of hours"],"returns":[" * The number of seconds in n hours"],"signature":"hs.timer.hours(n) -> seconds","stripped_doc":"","type":"Function"},"localTime":{"def":"hs.timer.localTime() -> number","desc":"Returns the number of seconds since local time midnight","doc":"Returns the number of seconds since local time midnight\n\nParameters:\n * None\n\nReturns:\n * the number of seconds","examples":[],"file":"extensions/timer/timer.lua","lineno":"215","name":"localTime","notes":[],"parameters":[" * None"],"returns":[" * the number of seconds"],"signature":"hs.timer.localTime() -> number","stripped_doc":"","type":"Function"},"minutes":{"def":"hs.timer.minutes(n) -> seconds","desc":"Converts minutes to seconds","doc":"Converts minutes to seconds\n\nParameters:\n * n - A number of minutes\n\nReturns:\n * The number of seconds in n minutes","examples":[],"file":"extensions/timer/timer.lua","lineno":"59","name":"minutes","notes":[],"parameters":[" * n - A number of minutes"],"returns":[" * The number of seconds in n minutes"],"signature":"hs.timer.minutes(n) -> seconds","stripped_doc":"","type":"Function"},"new":{"def":"hs.timer.new(interval, fn [, continueOnError]) -> timer","desc":"Creates a new `hs.timer` object for repeating interval callbacks","doc":"Creates a new `hs.timer` object for repeating interval callbacks\n\nParameters:\n * interval - A number of seconds between firings of the timer\n * fn - A function to call every time the timer fires\n * continueOnError - An optional boolean, true if the timer should continue to be triggered after the callback function has produced an error, false if the timer should stop being triggered after the callback function has produced an error. Defaults to false.\n\nReturns:\n * An `hs.timer` object\n\nNotes:\n * The returned object does not start its timer until its `:start()` method is called\n * If `interval` is 0, the timer will not repeat (because if it did, it would be repeating as fast as your machine can manage, which seems generally unwise)\n * For non-zero intervals, the lowest acceptable value for the interval is 0.00001s. Values >0 and <0.00001 will be coerced to 0.00001","examples":[],"file":"extensions/timer/libtimer.m","lineno":"128","name":"new","notes":[" * The returned object does not start its timer until its `:start()` method is called"," * If `interval` is 0, the timer will not repeat (because if it did, it would be repeating as fast as your machine can manage, which seems generally unwise)"," * For non-zero intervals, the lowest acceptable value for the interval is 0.00001s. Values >0 and <0.00001 will be coerced to 0.00001"],"parameters":[" * interval - A number of seconds between firings of the timer"," * fn - A function to call every time the timer fires"," * continueOnError - An optional boolean, true if the timer should continue to be triggered after the callback function has produced an error, false if the timer should stop being triggered after the callback function has produced an error. Defaults to false."],"returns":[" * An `hs.timer` object"],"signature":"hs.timer.new(interval, fn [, continueOnError]) -> timer","stripped_doc":"","type":"Constructor"},"nextTrigger":{"def":"hs.timer:nextTrigger() -> number","desc":"Returns the number of seconds until the timer will next trigger","doc":"Returns the number of seconds until the timer will next trigger\n\nParameters:\n * None\n\nReturns:\n * A number containing the number of seconds until the next firing\n\nNotes:\n * The return value may be a negative integer in two circumstances:\n  * Hammerspoon's runloop is backlogged and is catching up on missed timer triggers\n  * The timer object is not currently running. In this case, the return value of this method is the number of seconds since the last firing (you can check if the timer is running or not, with `hs.timer:running()`","examples":[],"file":"extensions/timer/libtimer.m","lineno":"283","name":"nextTrigger","notes":[" * The return value may be a negative integer in two circumstances:","  * Hammerspoon's runloop is backlogged and is catching up on missed timer triggers","  * The timer object is not currently running. In this case, the return value of this method is the number of seconds since the last firing (you can check if the timer is running or not, with `hs.timer:running()`"],"parameters":[" * None"],"returns":[" * A number containing the number of seconds until the next firing"],"signature":"hs.timer:nextTrigger() -> number","stripped_doc":"","type":"Method"},"running":{"def":"hs.timer:running() -> boolean","desc":"Returns a boolean indicating whether or not the timer is currently running.","doc":"Returns a boolean indicating whether or not the timer is currently running.\n\nParameters:\n * None\n\nReturns:\n * A boolean value indicating whether or not the timer is currently running.","examples":[],"file":"extensions/timer/libtimer.m","lineno":"264","name":"running","notes":[],"parameters":[" * None"],"returns":[" * A boolean value indicating whether or not the timer is currently running."],"signature":"hs.timer:running() -> boolean","stripped_doc":"","type":"Method"},"seconds":{"def":"hs.timer.seconds(timeOrDuration) -> seconds","desc":"Converts a string with a time of day or a duration into number of seconds","doc":"Converts a string with a time of day or a duration into number of seconds\n\nParameters:\n * timeOrDuration - a string that can have any of the following formats:\n   * \"HH:MM:SS\" or \"HH:MM\" - represents a time of day (24-hour clock), returns the number of seconds since midnight\n   * \"DDdHHh\", \"HHhMMm\", \"MMmSSs\", \"DDd\", \"HHh\", \"MMm\", \"SSs\", \"NNNNms\" - represents a duration in days, hours, minutes,\n     seconds and/or milliseconds\n\nReturns:\n * The number of seconds","examples":[],"file":"extensions/timer/timer.lua","lineno":"45","name":"seconds","notes":[],"parameters":[" * timeOrDuration - a string that can have any of the following formats:\n   * \"HH:MM:SS\" or \"HH:MM\" - represents a time of day (24-hour clock), returns the number of seconds since midnight\n   * \"DDdHHh\", \"HHhMMm\", \"MMmSSs\", \"DDd\", \"HHh\", \"MMm\", \"SSs\", \"NNNNms\" - represents a duration in days, hours, minutes, seconds and/or milliseconds"],"returns":[" * The number of seconds"],"signature":"hs.timer.seconds(timeOrDuration) -> seconds","stripped_doc":"","type":"Function"},"secondsSinceEpoch":{"def":"hs.timer.secondsSinceEpoch() -> sec","desc":"Gets the (fractional) number of seconds since the UNIX epoch (January 1, 1970)","doc":"Gets the (fractional) number of seconds since the UNIX epoch (January 1, 1970)\n\nParameters:\n * None\n\nReturns:\n * The number of seconds since the epoch\n\nNotes:\n * This has much better precision than `os.time()`, which is limited to whole seconds.","examples":[],"file":"extensions/timer/libtimer.m","lineno":"424","name":"secondsSinceEpoch","notes":[" * This has much better precision than `os.time()`, which is limited to whole seconds."],"parameters":[" * None"],"returns":[" * The number of seconds since the epoch"],"signature":"hs.timer.secondsSinceEpoch() -> sec","stripped_doc":"","type":"Function"},"setNextTrigger":{"def":"hs.timer:setNextTrigger(seconds) -> timer","desc":"Sets the next trigger time of a timer","doc":"Sets the next trigger time of a timer\n\nParameters:\n * seconds - A number of seconds after which to trigger the timer\n\nReturns:\n * The `hs.timer` object, or nil if an error occurred\n\nNotes:\n * If the timer is not already running, this will start it","examples":[],"file":"extensions/timer/libtimer.m","lineno":"307","name":"setNextTrigger","notes":[" * If the timer is not already running, this will start it"],"parameters":[" * seconds - A number of seconds after which to trigger the timer"],"returns":[" * The `hs.timer` object, or nil if an error occurred"],"signature":"hs.timer:setNextTrigger(seconds) -> timer","stripped_doc":"","type":"Method"},"start":{"def":"hs.timer:start() -> timer","desc":"Starts an `hs.timer` object","doc":"Starts an `hs.timer` object\n\nParameters:\n * None\n\nReturns:\n * The `hs.timer` object\n\nNotes:\n * The timer will not call the callback immediately, the timer will wait until it fires\n * If the callback function results in an error, the timer will be stopped to prevent repeated error notifications (see the `continueOnError` parameter to `hs.timer.new()` to override this)","examples":[],"file":"extensions/timer/libtimer.m","lineno":"179","name":"start","notes":[" * The timer will not call the callback immediately, the timer will wait until it fires"," * If the callback function results in an error, the timer will be stopped to prevent repeated error notifications (see the `continueOnError` parameter to `hs.timer.new()` to override this)"],"parameters":[" * None"],"returns":[" * The `hs.timer` object"],"signature":"hs.timer:start() -> timer","stripped_doc":"","type":"Method"},"stop":{"def":"hs.timer:stop() -> timer","desc":"Stops an `hs.timer` object","doc":"Stops an `hs.timer` object\n\nParameters:\n * None\n\nReturns:\n * The `hs.timer` object","examples":[],"file":"extensions/timer/libtimer.m","lineno":"359","name":"stop","notes":[],"parameters":[" * None"],"returns":[" * The `hs.timer` object"],"signature":"hs.timer:stop() -> timer","stripped_doc":"","type":"Method"},"usleep":{"def":"hs.timer.usleep(microsecs)","desc":"Blocks Lua execution for the specified time","doc":"Blocks Lua execution for the specified time\n\nParameters:\n * microsecs - A number containing a time in microseconds to block for\n\nReturns:\n * None\n\nNotes:\n * Use of this function is strongly discouraged, as it blocks all main-thread execution in Hammerspoon. This means no hotkeys or events will be processed in that time, no GUI updates will happen, and no Lua will execute. This is only provided as a last resort, or for extremely short sleeps. For all other purposes, you really should be splitting up your code into multiple functions and calling `hs.timer.doAfter()`","examples":[],"file":"extensions/timer/libtimer.m","lineno":"243","name":"usleep","notes":[" * Use of this function is strongly discouraged, as it blocks all main-thread execution in Hammerspoon. This means no hotkeys or events will be processed in that time, no GUI updates will happen, and no Lua will execute. This is only provided as a last resort, or for extremely short sleeps. For all other purposes, you really should be splitting up your code into multiple functions and calling `hs.timer.doAfter()`"],"parameters":[" * microsecs - A number containing a time in microseconds to block for"],"returns":[" * None"],"signature":"hs.timer.usleep(microsecs)","stripped_doc":"","type":"Function"},"waitUntil":{"def":"hs.timer.waitUntil(predicateFn, actionFn[, checkInterval]) -> timer","desc":"Creates and starts a timer which will perform `actionFn` when `predicateFn` returns true.  The timer is automatically stopped when `actionFn` is called.","doc":"Creates and starts a timer which will perform `actionFn` when `predicateFn` returns true.  The timer is automatically stopped when `actionFn` is called.\n\nParameters:\n * predicateFn - a function which determines when `actionFn` should be called.  This function takes no arguments, but should return true when it is time to call `actionFn`.\n * actionFn - a function which performs the desired action.  This function may take a single argument, the timer itself.\n * checkInterval - an optional parameter indicating how often to repeat the `predicateFn` check. Defaults to 1 second.\n\nReturns:\n * a timer object\n\nNotes:\n * The timer is stopped before `actionFn` is called, but the timer is passed as an argument to `actionFn` so that the actionFn may restart the timer to be called again the next time predicateFn returns true.\n * See also `hs.timer.waitWhile`, which is essentially the opposite of this function","examples":[],"file":"extensions/timer/timer.lua","lineno":"103","name":"waitUntil","notes":[" * The timer is stopped before `actionFn` is called, but the timer is passed as an argument to `actionFn` so that the actionFn may restart the timer to be called again the next time predicateFn returns true."," * See also `hs.timer.waitWhile`, which is essentially the opposite of this function"],"parameters":[" * predicateFn - a function which determines when `actionFn` should be called.  This function takes no arguments, but should return true when it is time to call `actionFn`."," * actionFn - a function which performs the desired action.  This function may take a single argument, the timer itself."," * checkInterval - an optional parameter indicating how often to repeat the `predicateFn` check. Defaults to 1 second."],"returns":[" * a timer object"],"signature":"hs.timer.waitUntil(predicateFn, actionFn[, checkInterval]) -> timer","stripped_doc":"","type":"Constructor"},"waitWhile":{"def":"hs.timer.waitWhile(predicateFn, actionFn[, checkInterval]) -> timer","desc":"Creates and starts a timer which will perform `actionFn` when `predicateFn` returns false.  The timer is automatically stopped when `actionFn` is called.","doc":"Creates and starts a timer which will perform `actionFn` when `predicateFn` returns false.  The timer is automatically stopped when `actionFn` is called.\n\nParameters:\n * predicateFn - a function which determines when `actionFn` should be called.  This function takes no arguments, but should return false when it is time to call `actionFn`.\n * actionFn - a function which performs the desired action.  This function may take a single argument, the timer itself.\n * checkInterval - an optional parameter indicating how often to repeat the `predicateFn` check. Defaults to 1 second.\n\nReturns:\n * a timer object\n\nNotes:\n * The timer is stopped before `actionFn` is called, but the timer is passed as an argument to `actionFn` so that the actionFn may restart the timer to be called again the next time predicateFn returns false.\n * See also `hs.timer.waitUntil`, which is essentially the opposite of this function","examples":[],"file":"extensions/timer/timer.lua","lineno":"176","name":"waitWhile","notes":[" * The timer is stopped before `actionFn` is called, but the timer is passed as an argument to `actionFn` so that the actionFn may restart the timer to be called again the next time predicateFn returns false."," * See also `hs.timer.waitUntil`, which is essentially the opposite of this function"],"parameters":[" * predicateFn - a function which determines when `actionFn` should be called.  This function takes no arguments, but should return false when it is time to call `actionFn`."," * actionFn - a function which performs the desired action.  This function may take a single argument, the timer itself."," * checkInterval - an optional parameter indicating how often to repeat the `predicateFn` check. Defaults to 1 second."],"returns":[" * a timer object"],"signature":"hs.timer.waitWhile(predicateFn, actionFn[, checkInterval]) -> timer","stripped_doc":"","type":"Constructor"},"weeks":{"def":"hs.timer.weeks(n) -> sec","desc":"Converts weeks to seconds","doc":"Converts weeks to seconds\n\nParameters:\n * n - A number of weeks\n\nReturns:\n * The number of seconds in n weeks","examples":[],"file":"extensions/timer/timer.lua","lineno":"92","name":"weeks","notes":[],"parameters":[" * n - A number of weeks"],"returns":[" * The number of seconds in n weeks"],"signature":"hs.timer.weeks(n) -> sec","stripped_doc":"","type":"Function"}}
