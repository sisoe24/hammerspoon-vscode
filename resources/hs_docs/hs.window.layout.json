{"apply":{"def":"hs.window.layout:apply()","desc":"Applies the layout","doc":"Applies the layout\n\nParameters:\n * None\n\nReturns:\n * the `hs.window.layout` object\n\nNotes:\n * if a screen configuration is defined for this windowfilter, and currently not satisfied, this method will do nothing","examples":[],"file":"extensions/window/window_layout.lua","lineno":"576","name":"apply","notes":[" * if a screen configuration is defined for this windowfilter, and currently not satisfied, this method will do nothing"],"parameters":[" * None"],"returns":[" * the `hs.window.layout` object"],"signature":"hs.window.layout:apply()","stripped_doc":"","type":"Method"},"applyDelay":{"def":"hs.window.layout.applyDelay","desc":"When \"active mode\" windowlayouts apply a rule, they will pause briefly for this amount of time in seconds, to allow windows","doc":"When \"active mode\" windowlayouts apply a rule, they will pause briefly for this amount of time in seconds, to allow windows\nto \"settle\" in their new configuration without triggering other rules (or the same rule), which could result in a\ncascade (or worse, a loop) or rules being applied. Defaults to 1; increase this if you experience unwanted repeated\ntriggering of rules due to sluggish performance.","file":"extensions/window/window_layout.lua","lineno":"598","name":"applyDelay","signature":"hs.window.layout.applyDelay","stripped_doc":"to \"settle\" in their new configuration without triggering other rules (or the same rule), which could result in a\ncascade (or worse, a loop) or rules being applied. Defaults to 1; increase this if you experience unwanted repeated\ntriggering of rules due to sluggish performance.","type":"Variable"},"applyLayout":{"def":"hs.window.layout.applyLayout(rules)","desc":"Applies a layout","doc":"Applies a layout\n\nParameters:\n * rules - see `hs.window.layout.new()`\n\nReturns:\n * None\n\nNotes:\n * this is a convenience wrapper for \"passive mode\" use that creates, applies, and deletes a windowlayout object;\n   do *not* use shared windowfilters in `rules`, as they'll be deleted; you can just use constructor argument maps instead","examples":[],"file":"extensions/window/window_layout.lua","lineno":"871","name":"applyLayout","notes":[" * this is a convenience wrapper for \"passive mode\" use that creates, applies, and deletes a windowlayout object;","   do *not* use shared windowfilters in `rules`, as they'll be deleted; you can just use constructor argument maps instead"],"parameters":[" * rules - see `hs.window.layout.new()`"],"returns":[" * None"],"signature":"hs.window.layout.applyLayout(rules)","stripped_doc":"","type":"Function"},"getRules":{"def":"hs.window.layout:getRules() -> table","desc":"Return a table with all the rules (and the screen configuration, if present) defined for this windowlayout","doc":"Return a table with all the rules (and the screen configuration, if present) defined for this windowlayout\n\nParameters:\n * None\n\nReturns:\n * a table containing the rules of this windowlayout; you can pass this table (optionally\n   after performing valid manipulations) to `hs.window.layout.new()`","examples":[],"file":"extensions/window/window_layout.lua","lineno":"342","name":"getRules","notes":[],"parameters":[" * None"],"returns":[" * a table containing the rules of this windowlayout; you can pass this table (optionally","   after performing valid manipulations) to `hs.window.layout.new()`"],"signature":"hs.window.layout:getRules() -> table","stripped_doc":"","type":"Method"},"new":{"def":"hs.window.layout.new(rules[,logname[,loglevel]]) -> hs.window.layout object","desc":"Creates a new hs.window.layout instance","doc":"Creates a new hs.window.layout instance\n\nParameters:\n * rules - a table containing the rules for this windowlayout (see the module description); additionally, if a special key `screens`\n   is present, its value must be a valid screen configuration as per `hs.window.layout:setScreenConfiguration()`\n * logname - (optional) name of the `hs.logger` instance for the new windowlayout; if omitted, the class logger will be used\n * loglevel - (optional) log level for the `hs.logger` instance for the new windowlayout\n\nReturns:\n * a new windowlayout instance","examples":[],"file":"extensions/window/window_layout.lua","lineno":"311","name":"new","notes":[],"parameters":[" * rules - a table containing the rules for this windowlayout (see the module description); additionally, if a special key `screens` is present, its value must be a valid screen configuration as per `hs.window.layout:setScreenConfiguration()`"," * logname - (optional) name of the `hs.logger` instance for the new windowlayout; if omitted, the class logger will be used"," * loglevel - (optional) log level for the `hs.logger` instance for the new windowlayout"],"returns":[" * a new windowlayout instance"],"signature":"hs.window.layout.new(rules[,logname[,loglevel]]) -> hs.window.layout object","stripped_doc":"","type":"Constructor"},"pause":{"def":"hs.window.layout:pause() -> hs.window.layout object","desc":"Pauses an active windowlayout instance; while paused no automatic window management will occur","doc":"Pauses an active windowlayout instance; while paused no automatic window management will occur\n\nParameters:\n * None\n\nReturns:\n * the `hs.window.layout` object","examples":[],"file":"extensions/window/window_layout.lua","lineno":"683","name":"pause","notes":[],"parameters":[" * None"],"returns":[" * the `hs.window.layout` object"],"signature":"hs.window.layout:pause() -> hs.window.layout object","stripped_doc":"","type":"Method"},"pauseAllInstances":{"def":"hs.window.layout.pauseAllInstances()","desc":"Pauses all active windowlayout instances","doc":"Pauses all active windowlayout instances\n\nParameters:\n * None\n\nReturns:\n * None","examples":[],"file":"extensions/window/window_layout.lua","lineno":"849","name":"pauseAllInstances","notes":[],"parameters":[" * None"],"returns":[" * None"],"signature":"hs.window.layout.pauseAllInstances()","stripped_doc":"","type":"Function"},"resume":{"def":"hs.window.layout:resume() -> hs.window.layout object","desc":"Resumes an active windowlayout instance after it was paused","doc":"Resumes an active windowlayout instance after it was paused\n\nParameters:\n * None\n\nReturns:\n * the `hs.window.layout` object\n\nNotes:\n * if a screen configuration is defined for this windowfilter, and currently not satisfied, this method will do nothing","examples":[],"file":"extensions/window/window_layout.lua","lineno":"641","name":"resume","notes":[" * if a screen configuration is defined for this windowfilter, and currently not satisfied, this method will do nothing"],"parameters":[" * None"],"returns":[" * the `hs.window.layout` object"],"signature":"hs.window.layout:resume() -> hs.window.layout object","stripped_doc":"","type":"Method"},"resumeAllInstances":{"def":"hs.window.layout.resumeAllInstances()","desc":"Resumes all active windowlayout instances","doc":"Resumes all active windowlayout instances\n\nParameters:\n * None\n\nReturns:\n * None","examples":[],"file":"extensions/window/window_layout.lua","lineno":"860","name":"resumeAllInstances","notes":[],"parameters":[" * None"],"returns":[" * None"],"signature":"hs.window.layout.resumeAllInstances()","stripped_doc":"","type":"Function"},"screensChangedDelay":{"def":"hs.window.layout.screensChangedDelay","desc":"The number of seconds to wait, after a screen configuration change has been detected, before","doc":"The number of seconds to wait, after a screen configuration change has been detected, before\nresuming any active windowlayouts that are allowed in the new configuration; defaults\nto 10, to give sufficient time to OSX to do its own housekeeping","file":"extensions/window/window_layout.lua","lineno":"736","name":"screensChangedDelay","signature":"hs.window.layout.screensChangedDelay","stripped_doc":"resuming any active windowlayouts that are allowed in the new configuration; defaults\nto 10, to give sufficient time to OSX to do its own housekeeping","type":"Variable"},"setScreenConfiguration":{"def":"hs.window.layout:setScreenConfiguration(screens) -> hs.window.layout object","desc":"Determines the screen configuration that permits applying this windowlayout","doc":"Determines the screen configuration that permits applying this windowlayout\n\nParameters:\n * screens - a map, where each *key* must be a valid \"hint\" for `hs.screen.find()`, and the corresponding\n   value can be:\n   * `true` - the screen must be currently present (attached and enabled)\n   * `false` - the screen must be currently absent\n   * an `hs.geometry` point (or constructor argument) - the screen must be present and in this specific\n     position in the current arrangement (as per `hs.screen:position()`)\n\nReturns:\n * the `hs.window.layout` object\n\nNotes:\n * If `screens` is `nil`, any previous screen configuration is removed, and this windowlayout will be always allowed\n * For \"active\" windowlayouts, call this method *before* calling `hs.window.layout:start()`\n * By using `hs.geometry` size objects as hints you can define separate layouts for the same physical screen at different resolutions\n * With this method you can define different windowlayouts for different screen configurations (as per System Preferences->Displays->Arrangement).\n * For example, suppose you define two \"graphics design work\" windowlayouts, one for \"desk with dual monitors\" and one for \"laptop only mode\":\n   * \"passive mode\" use: you call `:apply()` on *both* on your chosen hotkey (via `hs.hotkey:bind()`), but only the appropriate layout for the current arrangement will be applied\n   * \"active mode\" use: you just call `:start()` on both windowlayouts; as you switch between workplaces (by attaching or detaching external screens) the correct layout \"kicks in\" automatically - this is in effect a convenience wrapper that calls `:pause()` on the no longer relevant layout, and `:resume()` on the appropriate one, at every screen configuration change\n\nExamples:\n```lua\nlocal laptop_layout,desk_layout=... -- define your layouts\n-- just the laptop screen:\nlaptop_layout:setScreenConfiguration{['Color LCD']='0,0',dell=false,['3840x2160']=false}:start()\n-- attached to a 4k primary + a Dell on the right:\ndesk_layout:setScreenConfiguration{['3840x2160']='0,0',['dell']='1,0',['Color LCD']='-1,0'}:start()\n-- as above, but in clamshell mode (laptop lid closed):\nclamshell_layout:setScreenConfiguration{['3840x2160']='0,0',['dell']='1,0',['Color LCD']=false}:start()\n```","examples":["```lua","local laptop_layout,desk_layout=... -- define your layouts","-- just the laptop screen:","laptop_layout:setScreenConfiguration{['Color LCD']='0,0',dell=false,['3840x2160']=false}:start()","-- attached to a 4k primary + a Dell on the right:","desk_layout:setScreenConfiguration{['3840x2160']='0,0',['dell']='1,0',['Color LCD']='-1,0'}:start()","-- as above, but in clamshell mode (laptop lid closed):","clamshell_layout:setScreenConfiguration{['3840x2160']='0,0',['dell']='1,0',['Color LCD']=false}:start()","```"],"file":"extensions/window/window_layout.lua","lineno":"792","name":"setScreenConfiguration","notes":[" * If `screens` is `nil`, any previous screen configuration is removed, and this windowlayout will be always allowed"," * For \"active\" windowlayouts, call this method *before* calling `hs.window.layout:start()`"," * By using `hs.geometry` size objects as hints you can define separate layouts for the same physical screen at different resolutions"," * With this method you can define different windowlayouts for different screen configurations (as per System Preferences->Displays->Arrangement)."," * For example, suppose you define two \"graphics design work\" windowlayouts, one for \"desk with dual monitors\" and one for \"laptop only mode\":","   * \"passive mode\" use: you call `:apply()` on *both* on your chosen hotkey (via `hs.hotkey:bind()`), but only the appropriate layout for the current arrangement will be applied","   * \"active mode\" use: you just call `:start()` on both windowlayouts; as you switch between workplaces (by attaching or detaching external screens) the correct layout \"kicks in\" automatically - this is in effect a convenience wrapper that calls `:pause()` on the no longer relevant layout, and `:resume()` on the appropriate one, at every screen configuration change"],"parameters":[" * screens - a map, where each *key* must be a valid \"hint\" for `hs.screen.find()`, and the corresponding value can be:\n   * `true` - the screen must be currently present (attached and enabled)\n   * `false` - the screen must be currently absent\n   * an `hs.geometry` point (or constructor argument) - the screen must be present and in this specific position in the current arrangement (as per `hs.screen:position()`)"],"returns":[" * the `hs.window.layout` object"],"signature":"hs.window.layout:setScreenConfiguration(screens) -> hs.window.layout object","stripped_doc":"","type":"Method"},"start":{"def":"hs.window.layout:start() -> hs.window.layout object","desc":"Puts a windowlayout instance in \"active mode\"","doc":"Puts a windowlayout instance in \"active mode\"\n\nParameters:\n * None\n\nReturns:\n * the `hs.window.layout` object\n\nNotes:\n * If a screen configuration is defined for this windowfilter, and currently not satisfied, this windowfilter will be put in \"active mode\" but will remain paused until the screen configuration requirements are met\n * When in active mode, a windowlayout instance will constantly monitor the windowfilters for its rules, by subscribing to all the relevant events. As soon as any change is detected (e.g. when you drag a window, switch focus, open or close apps/windows, etc.) the relative rule will be automatically re-applied. In other words, the rules you defined will remain enforced all the time, instead of waiting for manual intervention via `hs.window.layout:apply()`.","examples":[],"file":"extensions/window/window_layout.lua","lineno":"620","name":"start","notes":[" * If a screen configuration is defined for this windowfilter, and currently not satisfied, this windowfilter will be put in \"active mode\" but will remain paused until the screen configuration requirements are met"," * When in active mode, a windowlayout instance will constantly monitor the windowfilters for its rules, by subscribing to all the relevant events. As soon as any change is detected (e.g. when you drag a window, switch focus, open or close apps/windows, etc.) the relative rule will be automatically re-applied. In other words, the rules you defined will remain enforced all the time, instead of waiting for manual intervention via `hs.window.layout:apply()`."],"parameters":[" * None"],"returns":[" * the `hs.window.layout` object"],"signature":"hs.window.layout:start() -> hs.window.layout object","stripped_doc":"","type":"Method"},"stop":{"def":"hs.window.layout:stop() -> hs.window.layout object","desc":"Stops a windowlayout instance (i.e. not in \"active mode\" anymore)","doc":"Stops a windowlayout instance (i.e. not in \"active mode\" anymore)\n\nParameters:\n * None\n\nReturns:\n * the `hs.window.layout` object","examples":[],"file":"extensions/window/window_layout.lua","lineno":"705","name":"stop","notes":[],"parameters":[" * None"],"returns":[" * the `hs.window.layout` object"],"signature":"hs.window.layout:stop() -> hs.window.layout object","stripped_doc":"","type":"Method"}}
