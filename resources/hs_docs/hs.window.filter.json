{"allowApp":{"def":"hs.window.filter:allowApp(appname) -> hs.window.filter object","desc":"Sets the windowfilter to allow all visible windows belonging to a specific app","doc":"Sets the windowfilter to allow all visible windows belonging to a specific app\n\nParameters:\n * appname - app name as per `hs.application:name()`\n\nReturns:\n * the `hs.window.filter` object for method chaining\n\nNotes:\n * this is just a convenience wrapper for `windowfilter:setAppFilter(appname,{visible=true})`","examples":[],"file":"extensions/window/window_filter.lua","lineno":"342","name":"allowApp","notes":[" * this is just a convenience wrapper for `windowfilter:setAppFilter(appname,{visible=true})`"],"parameters":[" * appname - app name as per `hs.application:name()`"],"returns":[" * the `hs.window.filter` object for method chaining"],"signature":"hs.window.filter:allowApp(appname) -> hs.window.filter object","stripped_doc":"","type":"Method"},"allowedWindowRoles":{"def":"hs.window.filter.allowedWindowRoles","desc":"A table for window roles (as per `hs.window:subrole()`) that are allowed by default.","doc":"A table for window roles (as per `hs.window:subrole()`) that are allowed by default.\n\nSet the desired window roles as *keys* in this table, like this: `hs.window.filter.allowedWindowRoles = {AXStandardWindow=true,AXDialog=true}`\n\nNotes:\n * You can have fine grained control of allowed window roles via the `setAppFilter`, `setDefaultFilter`, `setOverrideFilter` methods.\n * If you know what you're doing you can override the allowed window roles globally by changing this variable, but this is discouraged.","file":"extensions/window/window_filter.lua","lineno":"179","name":"allowedWindowRoles","notes":[" * You can have fine grained control of allowed window roles via the `setAppFilter`, `setDefaultFilter`, `setOverrideFilter` methods."," * If you know what you're doing you can override the allowed window roles globally by changing this variable, but this is discouraged."],"signature":"hs.window.filter.allowedWindowRoles","stripped_doc":"Set the desired window roles as *keys* in this table, like this: `hs.window.filter.allowedWindowRoles = {AXStandardWindow=true,AXDialog=true}`","type":"Variable"},"copy":{"def":"hs.window.filter.copy(windowfilter[,logname[,loglevel]]) -> hs.window.filter object","desc":"Returns a copy of an hs.window.filter object that you can further restrict or expand","doc":"Returns a copy of an hs.window.filter object that you can further restrict or expand\n\nParameters:\n * windowfilter - an `hs.window.filter` object to copy\n * logname - (optional) name of the `hs.logger` instance for the new windowfilter; if omitted, the class logger will be used\n * loglevel - (optional) log level for the `hs.logger` instance for the new windowfilter\n\nReturns:\n * An `hs.window.filter` object","examples":[],"file":"extensions/window/window_filter.lua","lineno":"724","name":"copy","notes":[],"parameters":[" * windowfilter - an `hs.window.filter` object to copy"," * logname - (optional) name of the `hs.logger` instance for the new windowfilter; if omitted, the class logger will be used"," * loglevel - (optional) log level for the `hs.logger` instance for the new windowfilter"],"returns":[" * An `hs.window.filter` object"],"signature":"hs.window.filter.copy(windowfilter[,logname[,loglevel]]) -> hs.window.filter object","stripped_doc":"","type":"Constructor"},"default":{"def":"hs.window.filter.default","desc":"The default windowfilter; it filters apps whose windows are transient in nature so that you're unlikely (and often","doc":"The default windowfilter; it filters apps whose windows are transient in nature so that you're unlikely (and often\nunable) to do anything with them, such as launchers, menulets, preference pane apps, screensavers, etc. It also\nfilters nonstandard and invisible windows.\n\nNotes:\n * While you can customize the default windowfilter, it's usually advisable to make your customizations on a local copy via `mywf=hs.window.filter.new()`;\n   the default windowfilter can potentially be used in several Hammerspoon modules and changing it might have unintended consequences.\n   Common customizations:\n   * to exclude fullscreen windows: `nofs_wf=hs.window.filter.new():setOverrideFilter{fullscreen=false}`\n   * to include invisible windows: `inv_wf=windowfilter.new():setDefaultFilter{}`\n * If you still want to alter the default windowfilter:\n   * you should probably apply your customizations at the top of your `init.lua`, or at any rate before instantiating any other windowfilter; this\n     way copies created via `hs.window.filter.new(nil,...)` will inherit your modifications\n   * to list the known exclusions: `hs.inspect(hs.window.filter.default:getFilters())` from the console\n   * to add an exclusion: `hs.window.filter.default:rejectApp'Cool New Launcher'`\n   * to add an app-specific rule: `hs.window.filter.default:setAppFilter('My IDE',1)`; ignore tooltips/code completion (empty title) in My IDE\n   * to remove an exclusion (e.g. if you want to have access to Spotlight windows): `hs.window.filter.default:allowApp'Spotlight'`;\n     for specialized uses you can make a specific windowfilter with `myfilter=hs.window.filter.new'Spotlight'`","file":"extensions/window/window_filter.lua","lineno":"742","name":"default","notes":[" * While you can customize the default windowfilter, it's usually advisable to make your customizations on a local copy via `mywf=hs.window.filter.new()`;","   the default windowfilter can potentially be used in several Hammerspoon modules and changing it might have unintended consequences.","   Common customizations:","   * to exclude fullscreen windows: `nofs_wf=hs.window.filter.new():setOverrideFilter{fullscreen=false}`","   * to include invisible windows: `inv_wf=windowfilter.new():setDefaultFilter{}`"," * If you still want to alter the default windowfilter:","   * you should probably apply your customizations at the top of your `init.lua`, or at any rate before instantiating any other windowfilter; this","     way copies created via `hs.window.filter.new(nil,...)` will inherit your modifications","   * to list the known exclusions: `hs.inspect(hs.window.filter.default:getFilters())` from the console","   * to add an exclusion: `hs.window.filter.default:rejectApp'Cool New Launcher'`","   * to add an app-specific rule: `hs.window.filter.default:setAppFilter('My IDE',1)`; ignore tooltips/code completion (empty title) in My IDE","   * to remove an exclusion (e.g. if you want to have access to Spotlight windows): `hs.window.filter.default:allowApp'Spotlight'`;","     for specialized uses you can make a specific windowfilter with `myfilter=hs.window.filter.new'Spotlight'`"],"signature":"hs.window.filter.default","stripped_doc":"unable) to do anything with them, such as launchers, menulets, preference pane apps, screensavers, etc. It also\nfilters nonstandard and invisible windows.","type":"Constant"},"defaultCurrentSpace":{"def":"hs.window.filter.defaultCurrentSpace","desc":"A copy of the default windowfilter (see `hs.window.filter.default`) that only allows windows in the current","doc":"A copy of the default windowfilter (see `hs.window.filter.default`) that only allows windows in the current\nMission Control Space\n\nNotes:\n * This windowfilter will inherit customizations to the default windowfilter if they're performed *before* referencing this","file":"extensions/window/window_filter.lua","lineno":"763","name":"defaultCurrentSpace","notes":[" * This windowfilter will inherit customizations to the default windowfilter if they're performed *before* referencing this"],"signature":"hs.window.filter.defaultCurrentSpace","stripped_doc":"Mission Control Space","type":"Constant"},"focusEast":{"def":"hs.window.filter.focusEast()","desc":"Convenience function to focus the nearest window to the east","doc":"Convenience function to focus the nearest window to the east\n\nParameters:\n * None\n\nReturns:\n * None\n\nNotes:\n * This is a convenience wrapper that performs `hs.window.filter.defaultCurrentSpace:focusWindowEast(nil,nil,true)`","examples":[],"file":"extensions/window/window_filter.lua","lineno":"2241","name":"focusEast","notes":[" * This is a convenience wrapper that performs `hs.window.filter.defaultCurrentSpace:focusWindowEast(nil,nil,true)`"],"parameters":[" * None"],"returns":[" * None"],"signature":"hs.window.filter.focusEast()","stripped_doc":"","type":"Function"},"focusNorth":{"def":"hs.window.filter.focusNorth()","desc":"Convenience function to focus the nearest window to the north","doc":"Convenience function to focus the nearest window to the north\n\nParameters:\n * None\n\nReturns:\n * None\n\nNotes:\n * This is a convenience wrapper that performs `hs.window.filter.defaultCurrentSpace:focusWindowNorth(nil,nil,true)`","examples":[],"file":"extensions/window/window_filter.lua","lineno":"2280","name":"focusNorth","notes":[" * This is a convenience wrapper that performs `hs.window.filter.defaultCurrentSpace:focusWindowNorth(nil,nil,true)`"],"parameters":[" * None"],"returns":[" * None"],"signature":"hs.window.filter.focusNorth()","stripped_doc":"","type":"Function"},"focusSouth":{"def":"hs.window.filter.focusSouth()","desc":"Convenience function to focus the nearest window to the south","doc":"Convenience function to focus the nearest window to the south\n\nParameters:\n * None\n\nReturns:\n * None\n\nNotes:\n * This is a convenience wrapper that performs `hs.window.filter.defaultCurrentSpace:focusWindowSouth(nil,nil,true)`","examples":[],"file":"extensions/window/window_filter.lua","lineno":"2267","name":"focusSouth","notes":[" * This is a convenience wrapper that performs `hs.window.filter.defaultCurrentSpace:focusWindowSouth(nil,nil,true)`"],"parameters":[" * None"],"returns":[" * None"],"signature":"hs.window.filter.focusSouth()","stripped_doc":"","type":"Function"},"focusWest":{"def":"hs.window.filter.focusWest()","desc":"Convenience function to focus the nearest window to the west","doc":"Convenience function to focus the nearest window to the west\n\nParameters:\n * None\n\nReturns:\n * None\n\nNotes:\n * This is a convenience wrapper that performs `hs.window.filter.defaultCurrentSpace:focusWindowWest(nil,nil,true)`","examples":[],"file":"extensions/window/window_filter.lua","lineno":"2254","name":"focusWest","notes":[" * This is a convenience wrapper that performs `hs.window.filter.defaultCurrentSpace:focusWindowWest(nil,nil,true)`"],"parameters":[" * None"],"returns":[" * None"],"signature":"hs.window.filter.focusWest()","stripped_doc":"","type":"Function"},"focusWindowEast":{"def":"hs.window.filter:focusWindowEast(window, frontmost, strict)","desc":"Focuses the nearest window to the east of a given window","doc":"Focuses the nearest window to the east of a given window\n\nParameters:\n * window - (optional) an `hs.window` object; if nil, `hs.window.frontmostWindow()` will be used\n * frontmost - (optional) boolean, if true focuses the nearest window that isn't occluded by any other window in this windowfilter\n * strict - (optional) boolean, if true only consider windows at an angle between 45° and -45° on the\n   eastward axis\n\nReturns:\n * None\n\nNotes:\n * This is a convenience wrapper that performs `hs.window.focusWindowEast(window,self:getWindows(),...)`\n * You'll likely want to add `:setCurrentSpace(true)` to the windowfilter used for this method call","examples":[],"file":"extensions/window/window_filter.lua","lineno":"2173","name":"focusWindowEast","notes":[" * This is a convenience wrapper that performs `hs.window.focusWindowEast(window,self:getWindows(),...)`"," * You'll likely want to add `:setCurrentSpace(true)` to the windowfilter used for this method call"],"parameters":[" * window - (optional) an `hs.window` object; if nil, `hs.window.frontmostWindow()` will be used"," * frontmost - (optional) boolean, if true focuses the nearest window that isn't occluded by any other window in this windowfilter"," * strict - (optional) boolean, if true only consider windows at an angle between 45° and -45° on the eastward axis"],"returns":[" * None"],"signature":"hs.window.filter:focusWindowEast(window, frontmost, strict)","stripped_doc":"","type":"Method"},"focusWindowNorth":{"def":"hs.window.filter:focusWindowNorth(window, frontmost, strict)","desc":"Focuses the nearest window to the south of a given window","doc":"Focuses the nearest window to the south of a given window\n\nParameters:\n * window - (optional) an `hs.window` object; if nil, `hs.window.frontmostWindow()` will be used\n * frontmost - (optional) boolean, if true focuses the nearest window that isn't occluded by any other window in this windowfilter\n * strict - (optional) boolean, if true only consider windows at an angle between 45° and -45° on the\n   southward axis\n\nReturns:\n * None\n\nNotes:\n * This is a convenience wrapper that performs `hs.window.focusWindowNorth(window,self:getWindows(),...)`\n * You'll likely want to add `:setCurrentSpace(true)` to the windowfilter used for this method call","examples":[],"file":"extensions/window/window_filter.lua","lineno":"2223","name":"focusWindowNorth","notes":[" * This is a convenience wrapper that performs `hs.window.focusWindowNorth(window,self:getWindows(),...)`"," * You'll likely want to add `:setCurrentSpace(true)` to the windowfilter used for this method call"],"parameters":[" * window - (optional) an `hs.window` object; if nil, `hs.window.frontmostWindow()` will be used"," * frontmost - (optional) boolean, if true focuses the nearest window that isn't occluded by any other window in this windowfilter"," * strict - (optional) boolean, if true only consider windows at an angle between 45° and -45° on the southward axis"],"returns":[" * None"],"signature":"hs.window.filter:focusWindowNorth(window, frontmost, strict)","stripped_doc":"","type":"Method"},"focusWindowSouth":{"def":"hs.window.filter:focusWindowSouth(window, frontmost, strict)","desc":"Focuses the nearest window to the north of a given window","doc":"Focuses the nearest window to the north of a given window\n\nParameters:\n * window - (optional) an `hs.window` object; if nil, `hs.window.frontmostWindow()` will be used\n * frontmost - (optional) boolean, if true focuses the nearest window that isn't occluded by any other window in this windowfilter\n * strict - (optional) boolean, if true only consider windows at an angle between 45° and -45° on the\n   northward axis\n\nReturns:\n * None\n\nNotes:\n * This is a convenience wrapper that performs `hs.window.focusWindowSouth(window,self:getWindows(),...)`\n * You'll likely want to add `:setCurrentSpace(true)` to the windowfilter used for this method call","examples":[],"file":"extensions/window/window_filter.lua","lineno":"2206","name":"focusWindowSouth","notes":[" * This is a convenience wrapper that performs `hs.window.focusWindowSouth(window,self:getWindows(),...)`"," * You'll likely want to add `:setCurrentSpace(true)` to the windowfilter used for this method call"],"parameters":[" * window - (optional) an `hs.window` object; if nil, `hs.window.frontmostWindow()` will be used"," * frontmost - (optional) boolean, if true focuses the nearest window that isn't occluded by any other window in this windowfilter"," * strict - (optional) boolean, if true only consider windows at an angle between 45° and -45° on the northward axis"],"returns":[" * None"],"signature":"hs.window.filter:focusWindowSouth(window, frontmost, strict)","stripped_doc":"","type":"Method"},"focusWindowWest":{"def":"hs.window.filter:focusWindowWest(window, frontmost, strict)","desc":"Focuses the nearest window to the west of a given window","doc":"Focuses the nearest window to the west of a given window\n\nParameters:\n * window - (optional) an `hs.window` object; if nil, `hs.window.frontmostWindow()` will be used\n * frontmost - (optional) boolean, if true focuses the nearest window that isn't occluded by any other window in this windowfilter\n * strict - (optional) boolean, if true only consider windows at an angle between 45° and -45° on the westward axis\n\nReturns:\n * None\n\nNotes:\n * This is a convenience wrapper that performs `hs.window.focusWindowWest(window,self:getWindows(),...)`\n * You'll likely want to add `:setCurrentSpace(true)` to the windowfilter used for this method call","examples":[],"file":"extensions/window/window_filter.lua","lineno":"2190","name":"focusWindowWest","notes":[" * This is a convenience wrapper that performs `hs.window.focusWindowWest(window,self:getWindows(),...)`"," * You'll likely want to add `:setCurrentSpace(true)` to the windowfilter used for this method call"],"parameters":[" * window - (optional) an `hs.window` object; if nil, `hs.window.frontmostWindow()` will be used"," * frontmost - (optional) boolean, if true focuses the nearest window that isn't occluded by any other window in this windowfilter"," * strict - (optional) boolean, if true only consider windows at an angle between 45° and -45° on the westward axis"],"returns":[" * None"],"signature":"hs.window.filter:focusWindowWest(window, frontmost, strict)","stripped_doc":"","type":"Method"},"forceRefreshOnSpaceChange":{"def":"hs.window.filter.forceRefreshOnSpaceChange","desc":"Tells all windowfilters whether to refresh all windows when the user switches to a different Mission Control Space.","doc":"Tells all windowfilters whether to refresh all windows when the user switches to a different Mission Control Space.\n\nDue to OS X limitations Hammerspoon cannot directly query for windows in Spaces other than the current one;\ntherefore when a windowfilter is initially instantiated, it doesn't know about many of these windows.\n\nIf this variable is set to `true`, windowfilters will re-query applications for all their windows whenever a Space change\nby the user is detected, therefore any existing windows in that Space that were not yet being tracked will become known at that point;\nif `false` (the default) this won't happen, but the windowfilters will *eventually* learn about these windows\nanyway, as soon as they're interacted with.\n\nIf you need your windowfilters to become aware of windows across all Spaces as soon as possible, you can set this to `true`,\nbut you'll incur a modest performance penalty on every Space change. If possible, use the `hs.window.filter.switchedToSpace()`\ncallback instead.\n\nNotes:\n * If you defined one or more Spaces-aware windowfilters (i.e. when the `currentSpace` field of a filter is present), windows need refreshing at every space change anyway, so this variable is ignored","file":"extensions/window/window_filter.lua","lineno":"1510","name":"forceRefreshOnSpaceChange","notes":[" * If you defined one or more Spaces-aware windowfilters (i.e. when the `currentSpace` field of a filter is present), windows need refreshing at every space change anyway, so this variable is ignored"],"signature":"hs.window.filter.forceRefreshOnSpaceChange","stripped_doc":"Due to OS X limitations Hammerspoon cannot directly query for windows in Spaces other than the current one;\ntherefore when a windowfilter is initially instantiated, it doesn't know about many of these windows.\nIf this variable is set to `true`, windowfilters will re-query applications for all their windows whenever a Space change\nby the user is detected, therefore any existing windows in that Space that were not yet being tracked will become known at that point;\nif `false` (the default) this won't happen, but the windowfilters will *eventually* learn about these windows\nanyway, as soon as they're interacted with.\nIf you need your windowfilters to become aware of windows across all Spaces as soon as possible, you can set this to `true`,\nbut you'll incur a modest performance penalty on every Space change. If possible, use the `hs.window.filter.switchedToSpace()`\ncallback instead.","type":"Variable"},"getFilters":{"def":"hs.window.filter:getFilters() -> table","desc":"Return a table with all the filtering rules defined for this windowfilter","doc":"Return a table with all the filtering rules defined for this windowfilter\n\nParameters:\n * None\n\nReturns:\n * a table containing the filtering rules of this windowfilter; you can pass this table (optionally\n after performing valid manipulations) to `hs.window.filter:setFilters()` and `hs.window.filter.new()`","examples":[],"file":"extensions/window/window_filter.lua","lineno":"641","name":"getFilters","notes":[],"parameters":[" * None"],"returns":[" * a table containing the filtering rules of this windowfilter; you can pass this table (optionally"," after performing valid manipulations) to `hs.window.filter:setFilters()` and `hs.window.filter.new()`"],"signature":"hs.window.filter:getFilters() -> table","stripped_doc":"","type":"Method"},"getWindows":{"def":"hs.window.filter:getWindows([sortOrder]) -> list of hs.window objects","desc":"Gets the current windows allowed by this windowfilter","doc":"Gets the current windows allowed by this windowfilter\n\nParameters:\n * sortOrder - (optional) one of the `hs.window.filter.sortBy...` constants to determine the sort order\n   of the returned list; if omitted, uses the windowfilter's sort order as per `hs.window.filter:setSortOrder()`\n  (defaults to `sortByFocusedLast`)\n\nReturns:\n * a list of `hs.window` objects","examples":[],"file":"extensions/window/window_filter.lua","lineno":"1813","name":"getWindows","notes":[],"parameters":[" * sortOrder - (optional) one of the `hs.window.filter.sortBy...` constants to determine the sort order of the returned list; if omitted, uses the windowfilter's sort order as per `hs.window.filter:setSortOrder()` (defaults to `sortByFocusedLast`)"],"returns":[" * a list of `hs.window` objects"],"signature":"hs.window.filter:getWindows([sortOrder]) -> list of hs.window objects","stripped_doc":"","type":"Method"},"hasNoWindows":{"def":"hs.window.filter.hasNoWindows","desc":"Pseudo-event for `hs.window.filter:subscribe()`: the windowfilter now rejects all windows","doc":"Pseudo-event for `hs.window.filter:subscribe()`: the windowfilter now rejects all windows\n\nNotes:\n * callbacks for this event will receive (as the first argument) the last window that was allowed (and is now rejected)\n * this pseudo-event won't trigger again until after the windowfilter allows at least one window\n * this pseudo-event will be emitted *after* the *actual* event(s) (e.g. `windowDestroyed`) that caused the window to be rejected","file":"extensions/window/window_filter.lua","lineno":"915","name":"hasNoWindows","notes":[" * callbacks for this event will receive (as the first argument) the last window that was allowed (and is now rejected)"," * this pseudo-event won't trigger again until after the windowfilter allows at least one window"," * this pseudo-event will be emitted *after* the *actual* event(s) (e.g. `windowDestroyed`) that caused the window to be rejected"],"signature":"hs.window.filter.hasNoWindows","stripped_doc":"","type":"Constant"},"hasWindow":{"def":"hs.window.filter.hasWindow","desc":"Pseudo-event for `hs.window.filter:subscribe()`: the windowfilter now allows one window","doc":"Pseudo-event for `hs.window.filter:subscribe()`: the windowfilter now allows one window\n\nNotes:\n * callbacks for this event will receive (as the first argument) the window that is now allowed\n * this pseudo-event won't trigger again until after the windowfilter reverts to rejecting all windows\n * this pseudo-event will be emitted *after* the *actual* event(s) (e.g. `windowCreated`) that caused a window to be allowed","file":"extensions/window/window_filter.lua","lineno":"906","name":"hasWindow","notes":[" * callbacks for this event will receive (as the first argument) the window that is now allowed"," * this pseudo-event won't trigger again until after the windowfilter reverts to rejecting all windows"," * this pseudo-event will be emitted *after* the *actual* event(s) (e.g. `windowCreated`) that caused a window to be allowed"],"signature":"hs.window.filter.hasWindow","stripped_doc":"","type":"Constant"},"ignoreAlways":{"def":"hs.window.filter.ignoreAlways","desc":"A table of application names (as per `hs.application:name()`) that are always ignored by this module.","doc":"A table of application names (as per `hs.application:name()`) that are always ignored by this module.\nThese are apps with no windows or any visible GUI, such as system services, background daemons and \"helper\" apps.\n\nYou can add an app to this table with `hs.window.filter.ignoreAlways['Background App Title'] = true`\n\nNotes:\n * As the name implies, even the empty, \"allow all\" windowfilter will ignore these apps.\n * You don't *need* to keep this table up to date, since non GUI apps will simply never show up anywhere; this table is just used as a \"root\" filter to gain a (very small) performance improvement.","file":"extensions/window/window_filter.lua","lineno":"103","name":"ignoreAlways","notes":[" * As the name implies, even the empty, \"allow all\" windowfilter will ignore these apps."," * You don't *need* to keep this table up to date, since non GUI apps will simply never show up anywhere; this table is just used as a \"root\" filter to gain a (very small) performance improvement."],"signature":"hs.window.filter.ignoreAlways","stripped_doc":"These are apps with no windows or any visible GUI, such as system services, background daemons and \"helper\" apps.\nYou can add an app to this table with `hs.window.filter.ignoreAlways['Background App Title'] = true`","type":"Variable"},"isAppAllowed":{"def":"hs.window.filter:isAppAllowed(appname) -> boolean","desc":"Checks if an app is allowed by the windowfilter","doc":"Checks if an app is allowed by the windowfilter\n\nParameters:\n * appname - app name as per `hs.application:name()`\n\nReturns:\n * `false` if the app is rejected by the windowfilter; `true` otherwise","examples":[],"file":"extensions/window/window_filter.lua","lineno":"312","name":"isAppAllowed","notes":[],"parameters":[" * appname - app name as per `hs.application:name()`"],"returns":[" * `false` if the app is rejected by the windowfilter; `true` otherwise"],"signature":"hs.window.filter:isAppAllowed(appname) -> boolean","stripped_doc":"","type":"Method"},"isGuiApp":{"def":"hs.window.filter.isGuiApp(appname) -> boolean","desc":"Checks whether an app is a known non-GUI app, as per `hs.window.filter.ignoreAlways`","doc":"Checks whether an app is a known non-GUI app, as per `hs.window.filter.ignoreAlways`\n\nParameters:\n * appname - name of the app to check as per `hs.application:name()`\n\nReturns:\n * `false` if the app is a known non-GUI (or not accessible) app; `true` otherwise","examples":[],"file":"extensions/window/window_filter.lua","lineno":"771","name":"isGuiApp","notes":[],"parameters":[" * appname - name of the app to check as per `hs.application:name()`"],"returns":[" * `false` if the app is a known non-GUI (or not accessible) app; `true` otherwise"],"signature":"hs.window.filter.isGuiApp(appname) -> boolean","stripped_doc":"","type":"Function"},"isWindowAllowed":{"def":"hs.window.filter:isWindowAllowed(window) -> boolean","desc":"Checks if a window is allowed by the windowfilter","doc":"Checks if a window is allowed by the windowfilter\n\nParameters:\n * window - an `hs.window` object to check\n\nReturns:\n * `true` if the window is allowed by the windowfilter, `false` otherwise; `nil` if an invalid object was passed","examples":[],"file":"extensions/window/window_filter.lua","lineno":"192","name":"isWindowAllowed","notes":[],"parameters":[" * window - an `hs.window` object to check"],"returns":[" * `true` if the window is allowed by the windowfilter, `false` otherwise; `nil` if an invalid object was passed"],"signature":"hs.window.filter:isWindowAllowed(window) -> boolean","stripped_doc":"","type":"Method"},"new":{"def":"hs.window.filter.new(fn[,logname[,loglevel]]) -> hs.window.filter object","desc":"Creates a new hs.window.filter instance","doc":"Creates a new hs.window.filter instance\n\nParameters:\n * fn\n   * if `nil`, returns a copy of the default windowfilter, including any customizations you might have applied to it\n     so far; you can then further restrict or expand it\n   * if `true`, returns an empty windowfilter that allows every window\n   * if `false`, returns a windowfilter with a default rule to reject every window\n   * if a string or table of strings, returns a windowfilter that only allows visible windows of the specified apps\n     as per `hs.application:name()`\n   * if a table, you can fully define a windowfilter without having to call any methods after construction; the\n     table must be structured as per `hs.window.filter:setFilters()`; if not specified in the table, the\n     default filter in the new windowfilter will reject all windows\n   * otherwise it must be a function that accepts an `hs.window` object and returns `true` if the window is allowed\n     or `false` otherwise; this way you can define a fully custom windowfilter\n * logname - (optional) name of the `hs.logger` instance for the new windowfilter; if omitted, the class logger will be used\n * loglevel - (optional) log level for the `hs.logger` instance for the new windowfilter\n\nReturns:\n * a new windowfilter instance","examples":[],"file":"extensions/window/window_filter.lua","lineno":"672","name":"new","notes":[],"parameters":[" * fn\n   * if `nil`, returns a copy of the default windowfilter, including any customizations you might have applied to it so far; you can then further restrict or expand it\n   * if `true`, returns an empty windowfilter that allows every window\n   * if `false`, returns a windowfilter with a default rule to reject every window\n   * if a string or table of strings, returns a windowfilter that only allows visible windows of the specified apps as per `hs.application:name()`\n   * if a table, you can fully define a windowfilter without having to call any methods after construction; the table must be structured as per `hs.window.filter:setFilters()`; if not specified in the table, the default filter in the new windowfilter will reject all windows\n   * otherwise it must be a function that accepts an `hs.window` object and returns `true` if the window is allowed or `false` otherwise; this way you can define a fully custom windowfilter"," * logname - (optional) name of the `hs.logger` instance for the new windowfilter; if omitted, the class logger will be used"," * loglevel - (optional) log level for the `hs.logger` instance for the new windowfilter"],"returns":[" * a new windowfilter instance"],"signature":"hs.window.filter.new(fn[,logname[,loglevel]]) -> hs.window.filter object","stripped_doc":"","type":"Constructor"},"pause":{"def":"hs.window.filter:pause() -> hs.window.filter object","desc":"Stops the windowfilter event subscriptions; no more event callbacks will be triggered, but the subscriptions remain intact for a subsequent call to `hs.window.filter:resume()`","doc":"Stops the windowfilter event subscriptions; no more event callbacks will be triggered, but the subscriptions remain intact for a subsequent call to `hs.window.filter:resume()`\n\nParameters:\n * None\n\nReturns:\n * the `hs.window.filter` object for method chaining","examples":[],"file":"extensions/window/window_filter.lua","lineno":"2042","name":"pause","notes":[],"parameters":[" * None"],"returns":[" * the `hs.window.filter` object for method chaining"],"signature":"hs.window.filter:pause() -> hs.window.filter object","stripped_doc":"","type":"Method"},"rejectApp":{"def":"hs.window.filter:rejectApp(appname) -> hs.window.filter object","desc":"Sets the windowfilter to outright reject any windows belonging to a specific app","doc":"Sets the windowfilter to outright reject any windows belonging to a specific app\n\nParameters:\n * appname - app name as per `hs.application:name()`\n\nReturns:\n * the `hs.window.filter` object for method chaining\n\nNotes:\n * this is just a convenience wrapper for `windowfilter:setAppFilter(appname,false)`","examples":[],"file":"extensions/window/window_filter.lua","lineno":"326","name":"rejectApp","notes":[" * this is just a convenience wrapper for `windowfilter:setAppFilter(appname,false)`"],"parameters":[" * appname - app name as per `hs.application:name()`"],"returns":[" * the `hs.window.filter` object for method chaining"],"signature":"hs.window.filter:rejectApp(appname) -> hs.window.filter object","stripped_doc":"","type":"Method"},"resume":{"def":"hs.window.filter:resume() -> hs.window.filter object","desc":"Resumes the windowfilter event subscriptions","doc":"Resumes the windowfilter event subscriptions\n\nParameters:\n * None\n\nReturns:\n * the `hs.window.filter` object for method chaining","examples":[],"file":"extensions/window/window_filter.lua","lineno":"2027","name":"resume","notes":[],"parameters":[" * None"],"returns":[" * the `hs.window.filter` object for method chaining"],"signature":"hs.window.filter:resume() -> hs.window.filter object","stripped_doc":"","type":"Method"},"setAppFilter":{"def":"hs.window.filter:setAppFilter(appname, filter) -> hs.window.filter object","desc":"Sets the detailed filtering rules for the windows of a specific app","doc":"Sets the detailed filtering rules for the windows of a specific app\n\nParameters:\n * appname - app name as per `hs.application:name()`\n * filter - if `false`, reject the app; if `true`, `nil`, or omitted, allow all visible windows (in any Space) for the app; otherwise it must be a table describing the filtering rules for the app, via the following fields:\n   * visible - if `true`, only allow visible windows (in any Space); if `false`, reject visible windows; if omitted, this rule is ignored\n   * currentSpace - if `true`, only allow windows in the current Mission Control Space (minimized and hidden windows are included, as they're considered to belong to all Spaces); if `false`, reject windows in the current Space (including all minimized and hidden windows); if omitted, this rule is ignored\n   * fullscreen - if `true`, only allow fullscreen windows; if `false`, reject fullscreen windows; if omitted, this rule is ignored\n   * hasTitlebar - if `true`, only allow windows with titlebar; if `false`, reject window with titlebar; if omitted, this rule is ignored\n   * focused - if `true`, only allow a window while focused; if `false`, reject the focused window; if omitted, this rule is ignored\n   * activeApplication - only allow any of this app's windows while it is (if `true`) or it's not (if `false`) the active application; if omitted, this rule is ignored\n   * allowTitles\n     * if a number, only allow windows whose title is at least as many characters long; e.g. pass `1` to filter windows with an empty title\n     * if a string or table of strings, only allow windows whose title matches (one of) the pattern(s) as per `string.match`\n     * if omitted, this rule is ignored\n   * rejectTitles - if a string or table of strings, reject windows whose titles matches (one of) the pattern(s) as per `string.match`; if omitted, this rule is ignored\n   * allowRegions - an `hs.geometry` rect or constructor argument, or a list of them, designating (a) screen \"region(s)\" in absolute coordinates: only allow windows that \"cover\" at least 50% of (one of) the region(s), and/or windows that have at least 50% of their surface inside (one of) the region(s); if omitted, this rule is ignored\n   * rejectRegions - an `hs.geometry` rect or constructor argument, or a list of them, designating (a) screen \"region(s)\" in absolute coordinates: reject windows that \"cover\" at least 50% of (one of) the region(s), and/or windows that have at least 50% of their surface inside (one of) the region(s); if omitted, this rule is ignored\n   * allowScreens - a valid argument for `hs.screen.find()`, or a list of them, indicating one (or more) screen(s): only allow windows that (mostly) lie on (one of) the screen(s); if omitted, this rule is ignored\n   * rejectScreens - a valid argument for `hs.screen.find()`, or a list of them, indicating one (or more) screen(s): reject windows that (mostly) lie on (one of) the screen(s); if omitted, this rule is ignored\n   * allowRoles\n     * if a string or table of strings, only allow these window roles as per `hs.window:subrole()`\n     * if the special string `'*'`, this rule is ignored (i.e. all window roles, including empty ones, are allowed)\n     * if omitted, use the default allowed roles (defined in `hs.window.filter.allowedWindowRoles`)\n\nReturns:\n * the `hs.window.filter` object for method chaining\n\nNotes:\n * Passing `focused=true` in `filter` will (naturally) result in the windowfilter ever allowing 1 window at most\n * If you want to allow *all* windows for an app, including invisible ones, pass an empty table for `filter`\n * Spaces-aware windowfilters might experience a (sometimes significant) delay after every Space switch, since (due to OS X limitations) they must re-query for the list of all windows in the current Space every time.\n * If System Preferences>Mission Control>Displays have separate Spaces is *on*, the *current Space* is defined as the union of all the Spaces that are currently visible\n * This table explains the effects of different combinations of `visible` and `currentSpace`, showing which windows will be allowed:\n```\n             |visible=         nil                      |             true             |     false    |\n|currentSpace|------------------------------------------|------------------------------|--------------|\n|     nil    |all                                       |visible in ANY space          |min and hidden|\n|    true    |visible in CURRENT space+min and hidden   |visible in CURRENT space      |min and hidden|\n|    false   |visible in OTHER space only+min and hidden|visible in OTHER space only   |none          |\n```","examples":[],"file":"extensions/window/window_filter.lua","lineno":"440","name":"setAppFilter","notes":[" * Passing `focused=true` in `filter` will (naturally) result in the windowfilter ever allowing 1 window at most"," * If you want to allow *all* windows for an app, including invisible ones, pass an empty table for `filter`"," * Spaces-aware windowfilters might experience a (sometimes significant) delay after every Space switch, since (due to OS X limitations) they must re-query for the list of all windows in the current Space every time."," * If System Preferences>Mission Control>Displays have separate Spaces is *on*, the *current Space* is defined as the union of all the Spaces that are currently visible"," * This table explains the effects of different combinations of `visible` and `currentSpace`, showing which windows will be allowed:","```","             |visible=         nil                      |             true             |     false    |","|currentSpace|------------------------------------------|------------------------------|--------------|","|     nil    |all                                       |visible in ANY space          |min and hidden|","|    true    |visible in CURRENT space+min and hidden   |visible in CURRENT space      |min and hidden|","|    false   |visible in OTHER space only+min and hidden|visible in OTHER space only   |none          |","```"],"parameters":[" * appname - app name as per `hs.application:name()`"," * filter - if `false`, reject the app; if `true`, `nil`, or omitted, allow all visible windows (in any Space) for the app; otherwise it must be a table describing the filtering rules for the app, via the following fields:\n   * visible - if `true`, only allow visible windows (in any Space); if `false`, reject visible windows; if omitted, this rule is ignored\n   * currentSpace - if `true`, only allow windows in the current Mission Control Space (minimized and hidden windows are included, as they're considered to belong to all Spaces); if `false`, reject windows in the current Space (including all minimized and hidden windows); if omitted, this rule is ignored\n   * fullscreen - if `true`, only allow fullscreen windows; if `false`, reject fullscreen windows; if omitted, this rule is ignored\n   * hasTitlebar - if `true`, only allow windows with titlebar; if `false`, reject window with titlebar; if omitted, this rule is ignored\n   * focused - if `true`, only allow a window while focused; if `false`, reject the focused window; if omitted, this rule is ignored\n   * activeApplication - only allow any of this app's windows while it is (if `true`) or it's not (if `false`) the active application; if omitted, this rule is ignored\n   * allowTitles * if a number, only allow windows whose title is at least as many characters long; e.g. pass `1` to filter windows with an empty title * if a string or table of strings, only allow windows whose title matches (one of) the pattern(s) as per `string.match` * if omitted, this rule is ignored\n   * rejectTitles - if a string or table of strings, reject windows whose titles matches (one of) the pattern(s) as per `string.match`; if omitted, this rule is ignored\n   * allowRegions - an `hs.geometry` rect or constructor argument, or a list of them, designating (a) screen \"region(s)\" in absolute coordinates: only allow windows that \"cover\" at least 50% of (one of) the region(s), and/or windows that have at least 50% of their surface inside (one of) the region(s); if omitted, this rule is ignored\n   * rejectRegions - an `hs.geometry` rect or constructor argument, or a list of them, designating (a) screen \"region(s)\" in absolute coordinates: reject windows that \"cover\" at least 50% of (one of) the region(s), and/or windows that have at least 50% of their surface inside (one of) the region(s); if omitted, this rule is ignored\n   * allowScreens - a valid argument for `hs.screen.find()`, or a list of them, indicating one (or more) screen(s): only allow windows that (mostly) lie on (one of) the screen(s); if omitted, this rule is ignored\n   * rejectScreens - a valid argument for `hs.screen.find()`, or a list of them, indicating one (or more) screen(s): reject windows that (mostly) lie on (one of) the screen(s); if omitted, this rule is ignored\n   * allowRoles * if a string or table of strings, only allow these window roles as per `hs.window:subrole()` * if the special string `'*'`, this rule is ignored (i.e. all window roles, including empty ones, are allowed) * if omitted, use the default allowed roles (defined in `hs.window.filter.allowedWindowRoles`)"],"returns":[" * the `hs.window.filter` object for method chaining"],"signature":"hs.window.filter:setAppFilter(appname, filter) -> hs.window.filter object","stripped_doc":"","type":"Method"},"setCurrentSpace":{"def":"hs.window.filter:setCurrentSpace(val) -> hs.window.filter object","desc":"Sets whether the windowfilter should only allow (or reject) windows in the current Mission Control Space","doc":"Sets whether the windowfilter should only allow (or reject) windows in the current Mission Control Space\n\nParameters:\n * val - boolean; if `true`, only allow windows in the current Mission Control Space, plus minimized and hidden windows;\n   if `false`, reject them; if `nil`, ignore Mission Control Spaces\n\nReturns:\n * the `hs.window.filter` object for method chaining\n\nNotes:\n * This is just a convenience wrapper for setting the `currentSpace` field in the `override` filter (other\n   fields will be left untouched); per-app filters will maintain their `currentSpace` field, if present, as is\n * Spaces-aware windowfilters might experience a (sometimes significant) delay after every Space switch, since\n   (due to OS X limitations) they must re-query for the list of all windows in the current Space every time.","examples":[],"file":"extensions/window/window_filter.lua","lineno":"381","name":"setCurrentSpace","notes":[" * This is just a convenience wrapper for setting the `currentSpace` field in the `override` filter (other","   fields will be left untouched); per-app filters will maintain their `currentSpace` field, if present, as is"," * Spaces-aware windowfilters might experience a (sometimes significant) delay after every Space switch, since","   (due to OS X limitations) they must re-query for the list of all windows in the current Space every time."],"parameters":[" * val - boolean; if `true`, only allow windows in the current Mission Control Space, plus minimized and hidden windows; if `false`, reject them; if `nil`, ignore Mission Control Spaces"],"returns":[" * the `hs.window.filter` object for method chaining"],"signature":"hs.window.filter:setCurrentSpace(val) -> hs.window.filter object","stripped_doc":"","type":"Method"},"setDefaultFilter":{"def":"hs.window.filter:setDefaultFilter(filter) -> hs.window.filter object","desc":"Set the default filtering rules to be used for apps without app-specific rules","doc":"Set the default filtering rules to be used for apps without app-specific rules\n\nParameters:\n * filter - see `hs.window.filter:setAppFilter`\n\nReturns:\n * the `hs.window.filter` object for method chaining","examples":[],"file":"extensions/window/window_filter.lua","lineno":"357","name":"setDefaultFilter","notes":[],"parameters":[" * filter - see `hs.window.filter:setAppFilter`"],"returns":[" * the `hs.window.filter` object for method chaining"],"signature":"hs.window.filter:setDefaultFilter(filter) -> hs.window.filter object","stripped_doc":"","type":"Method"},"setFilters":{"def":"hs.window.filter:setFilters(filters) -> hs.window.filter object","desc":"Sets multiple filtering rules","doc":"Sets multiple filtering rules\n\nParameters:\n * filters - table, every element will set an application filter; these elements must:\n   - have a *key* of type string, denoting an application name as per `hs.application:name()`\n   - if the *value* is a boolean, the app will be allowed or rejected accordingly - see `hs.window.filter:allowApp()`\n     and `hs.window.filter:rejectApp()`\n   - if the *value* is a table, it must contain the accept/reject rules for the app *as key/value pairs*; valid keys\n     and values are described in `hs.window.filter:setAppFilter()`\n   - the key can be one of the special strings `\"default\"` and `\"override\"`, which will set the default and override\n     filter respectively\n   - the key can be the special string `\"sortOrder\"`; the value must be one of the `sortBy...` constants as per\n     `hs.window.filter:setSortOrder()`\n\nReturns:\n * the `hs.window.filter` object for method chaining\n\nNotes:\n * every filter definition in `filters` will overwrite the preexisting one for the relevant application, if present;\n   this also applies to the special default and override filters, if included","examples":[],"file":"extensions/window/window_filter.lua","lineno":"601","name":"setFilters","notes":[" * every filter definition in `filters` will overwrite the preexisting one for the relevant application, if present;","   this also applies to the special default and override filters, if included"],"parameters":[" * filters - table, every element will set an application filter; these elements must: - have a *key* of type string, denoting an application name as per `hs.application:name()` - if the *value* is a boolean, the app will be allowed or rejected accordingly - see `hs.window.filter:allowApp()` and `hs.window.filter:rejectApp()` - if the *value* is a table, it must contain the accept/reject rules for the app *as key/value pairs*; valid keys and values are described in `hs.window.filter:setAppFilter()` - the key can be one of the special strings `\"default\"` and `\"override\"`, which will set the default and override filter respectively - the key can be the special string `\"sortOrder\"`; the value must be one of the `sortBy...` constants as per `hs.window.filter:setSortOrder()`"],"returns":[" * the `hs.window.filter` object for method chaining"],"signature":"hs.window.filter:setFilters(filters) -> hs.window.filter object","stripped_doc":"","type":"Method"},"setOverrideFilter":{"def":"hs.window.filter:setOverrideFilter(filter) -> hs.window.filter object","desc":"Set overriding filtering rules that will be applied for all apps before any app-specific rules","doc":"Set overriding filtering rules that will be applied for all apps before any app-specific rules\n\nParameters:\n * filter - see `hs.window.filter:setAppFilter`\n\nReturns:\n * the `hs.window.filter` object for method chaining","examples":[],"file":"extensions/window/window_filter.lua","lineno":"369","name":"setOverrideFilter","notes":[],"parameters":[" * filter - see `hs.window.filter:setAppFilter`"],"returns":[" * the `hs.window.filter` object for method chaining"],"signature":"hs.window.filter:setOverrideFilter(filter) -> hs.window.filter object","stripped_doc":"","type":"Method"},"setRegions":{"def":"hs.window.filter:setRegions(regions) -> hs.window.filter object","desc":"Sets the allowed screen regions for this windowfilter","doc":"Sets the allowed screen regions for this windowfilter\n\nParameters:\n * regions - an `hs.geometry` rect or constructor argument, or a list of them, indicating the allowed region(s) for this windowfilter\n\nReturns:\n * the `hs.window.filter` object for method chaining\n\nNotes:\n * This is just a convenience wrapper for setting the `allowRegions` field in the `override` filter (other fields will be left untouched); per-app filters will maintain their `allowRegions` and `rejectRegions` fields, if present","examples":[],"file":"extensions/window/window_filter.lua","lineno":"403","name":"setRegions","notes":[" * This is just a convenience wrapper for setting the `allowRegions` field in the `override` filter (other fields will be left untouched); per-app filters will maintain their `allowRegions` and `rejectRegions` fields, if present"],"parameters":[" * regions - an `hs.geometry` rect or constructor argument, or a list of them, indicating the allowed region(s) for this windowfilter"],"returns":[" * the `hs.window.filter` object for method chaining"],"signature":"hs.window.filter:setRegions(regions) -> hs.window.filter object","stripped_doc":"","type":"Method"},"setScreens":{"def":"hs.window.filter:setScreens(screens) -> hs.window.filter object","desc":"Sets the allowed screens for this windowfilter","doc":"Sets the allowed screens for this windowfilter\n\nParameters:\n * regions - a valid argument for `hs.screen.find()`, or a list of them, indicating the allowed screen(s) for this windowfilter\n\nReturns:\n * the `hs.window.filter` object for method chaining\n\nNotes:\n * This is just a convenience wrapper for setting the `allowScreens` field in the `override` filter (other\n   fields will be left untouched); per-app filters will maintain their `allowScreens` and `rejectScreens` fields, if present","examples":[],"file":"extensions/window/window_filter.lua","lineno":"421","name":"setScreens","notes":[" * This is just a convenience wrapper for setting the `allowScreens` field in the `override` filter (other","   fields will be left untouched); per-app filters will maintain their `allowScreens` and `rejectScreens` fields, if present"],"parameters":[" * regions - a valid argument for `hs.screen.find()`, or a list of them, indicating the allowed screen(s) for this windowfilter"],"returns":[" * the `hs.window.filter` object for method chaining"],"signature":"hs.window.filter:setScreens(screens) -> hs.window.filter object","stripped_doc":"","type":"Method"},"setSortOrder":{"def":"hs.window.filter:setSortOrder(sortOrder) -> hs.window.filter object","desc":"Sets the sort order for this windowfilter's `:getWindows()` method","doc":"Sets the sort order for this windowfilter's `:getWindows()` method\n\nParameters:\n * sortOrder - one of the `hs.window.filter.sortBy...` constants\n\nReturns:\n * the `hs.window.filter` object for method chaining\n\nNotes:\n  * The default sort order for all windowfilters (that is, until changed by this method) is `hs.window.filter.sortByFocusedLast`","examples":[],"file":"extensions/window/window_filter.lua","lineno":"1773","name":"setSortOrder","notes":["  * The default sort order for all windowfilters (that is, until changed by this method) is `hs.window.filter.sortByFocusedLast`"],"parameters":[" * sortOrder - one of the `hs.window.filter.sortBy...` constants"],"returns":[" * the `hs.window.filter` object for method chaining"],"signature":"hs.window.filter:setSortOrder(sortOrder) -> hs.window.filter object","stripped_doc":"","type":"Method"},"sortByCreated":{"def":"hs.window.filter.sortByCreated","desc":"Sort order for `hs.window.filter:getWindows()`: windows are sorted in order of creation, oldest first (see also `hs.window.filter:setSortOrder()`)","doc":"Sort order for `hs.window.filter:getWindows()`: windows are sorted in order of creation, oldest first (see also `hs.window.filter:setSortOrder()`)","file":"extensions/window/window_filter.lua","lineno":"1759","name":"sortByCreated","signature":"hs.window.filter.sortByCreated","stripped_doc":"","type":"Constant"},"sortByCreatedLast":{"def":"hs.window.filter.sortByCreatedLast","desc":"Sort order for `hs.window.filter:getWindows()`: windows are sorted in order of creation, newest first (see also `hs.window.filter:setSortOrder()`)","doc":"Sort order for `hs.window.filter:getWindows()`: windows are sorted in order of creation, newest first (see also `hs.window.filter:setSortOrder()`)","file":"extensions/window/window_filter.lua","lineno":"1755","name":"sortByCreatedLast","signature":"hs.window.filter.sortByCreatedLast","stripped_doc":"","type":"Constant"},"sortByFocused":{"def":"hs.window.filter.sortByFocused","desc":"Sort order for `hs.window.filter:getWindows()`: windows are sorted in order of focus received, least recently first (see also `hs.window.filter:setSortOrder()`)","doc":"Sort order for `hs.window.filter:getWindows()`: windows are sorted in order of focus received, least recently first (see also `hs.window.filter:setSortOrder()`)","file":"extensions/window/window_filter.lua","lineno":"1751","name":"sortByFocused","signature":"hs.window.filter.sortByFocused","stripped_doc":"","type":"Constant"},"sortByFocusedLast":{"def":"hs.window.filter.sortByFocusedLast","desc":"Sort order for `hs.window.filter:getWindows()`: windows are sorted in order of focus received, most recently first (see also `hs.window.filter:setSortOrder()`)","doc":"Sort order for `hs.window.filter:getWindows()`: windows are sorted in order of focus received, most recently first (see also `hs.window.filter:setSortOrder()`)\n\nNotes:\n  * This is the default sort order for all windowfilters","file":"extensions/window/window_filter.lua","lineno":"1744","name":"sortByFocusedLast","notes":["  * This is the default sort order for all windowfilters"],"signature":"hs.window.filter.sortByFocusedLast","stripped_doc":"","type":"Constant"},"subscribe":{"def":"hs.window.filter:subscribe(event, fn[, immediate]) -> hs.window.filter object","desc":"Subscribe to one or more events on the allowed windows","doc":"Subscribe to one or more events on the allowed windows\n\nParameters:\n * event - string or list of strings, the event(s) to subscribe to (see the `hs.window.filter` constants); alternatively, this can be a map `{event1=fn1,event2=fn2,...}`: fnN will be subscribed to eventN, and the parameter `fn` will be ignored\n * fn - function or list of functions, the callback(s) to add for the event(s); each will be passed 3 parameters\n   * a `hs.window` object referring to the event's window\n   * a string containing the application name (`window:application():name()`) for convenience\n   * a string containing the event that caused the callback, i.e. (one of) the event(s) you subscribed to\n * immediate - (optional) if `true`, also call all the callbacks immediately for windows that satisfy the event(s) criteria\n\nReturns:\n * the `hs.window.filter` object for method chaining\n\nNotes:\n * Passing lists means that *all* the `fn`s will be called when *any* of the `event`s fires, so it's *not* a shortcut for subscribing distinct callbacks to distinct events; use a map or chained `:subscribe` calls for that.\n * Use caution with `immediate`: if for example you're subscribing to `hs.window.filter.windowUnfocused`, `fn`(s) will be called for *all* the windows except the currently focused one.\n * If the windowfilter was paused with `hs.window.filter:pause()`, calling this will resume it.","examples":[],"file":"extensions/window/window_filter.lua","lineno":"1867","name":"subscribe","notes":[" * Passing lists means that *all* the `fn`s will be called when *any* of the `event`s fires, so it's *not* a shortcut for subscribing distinct callbacks to distinct events; use a map or chained `:subscribe` calls for that."," * Use caution with `immediate`: if for example you're subscribing to `hs.window.filter.windowUnfocused`, `fn`(s) will be called for *all* the windows except the currently focused one."," * If the windowfilter was paused with `hs.window.filter:pause()`, calling this will resume it."],"parameters":[" * event - string or list of strings, the event(s) to subscribe to (see the `hs.window.filter` constants); alternatively, this can be a map `{event1=fn1,event2=fn2,...}`: fnN will be subscribed to eventN, and the parameter `fn` will be ignored"," * fn - function or list of functions, the callback(s) to add for the event(s); each will be passed 3 parameters\n   * a `hs.window` object referring to the event's window\n   * a string containing the application name (`window:application():name()`) for convenience\n   * a string containing the event that caused the callback, i.e. (one of) the event(s) you subscribed to"," * immediate - (optional) if `true`, also call all the callbacks immediately for windows that satisfy the event(s) criteria"],"returns":[" * the `hs.window.filter` object for method chaining"],"signature":"hs.window.filter:subscribe(event, fn[, immediate]) -> hs.window.filter object","stripped_doc":"","type":"Method"},"switchedToSpace":{"def":"hs.window.filter.switchedToSpace(space)","desc":"Callback to inform all windowfilters that the user initiated a switch to a (numbered) Mission Control Space.","doc":"Callback to inform all windowfilters that the user initiated a switch to a (numbered) Mission Control Space.\n\nParameters:\n * space - the Space number the user is switching to\n\nReturns:\n* None\n\nNotes:\n * Only use this function if \"Displays have separate Spaces\" and \"Automatically rearrange Spaces\" are OFF in System Preferences>Mission Control\n * Calling this function will set `hs.window.filter.forceRefreshOnSpaceChange` to `false`\n * If you defined one or more Spaces-aware windowfilters (i.e. when the `currentSpace` field of a filter is present), windows need refreshing at every space change anyway, so using this callback will not result in improved performance\n * See `hs.window.filter.forceRefreshOnSpaceChange` for an overview of Spaces limitations in Hammerspoon. If you often (or always) change Space via the \"numbered\" Mission Control keyboard shortcuts (by default, `ctrl-1` etc.), you can call this function from your `init.lua` when intercepting these shortcuts; for example:\n ```\n hs.hotkey.bind('ctrl','1',nil,function()hs.window.filter.switchedToSpace(1)end)\n hs.hotkey.bind('ctrl','2',nil,function()hs.window.filter.switchedToSpace(2)end)\n -- etc.\n ```\n* Using this callback results in slightly better performance than setting `forceRefreshOnSpaceChange` to `true`, since already visited Spaces are remembered and no refreshing is necessary when switching back to those.","examples":[],"file":"extensions/window/window_filter.lua","lineno":"1471","name":"switchedToSpace","notes":[" * Only use this function if \"Displays have separate Spaces\" and \"Automatically rearrange Spaces\" are OFF in System Preferences>Mission Control"," * Calling this function will set `hs.window.filter.forceRefreshOnSpaceChange` to `false`"," * If you defined one or more Spaces-aware windowfilters (i.e. when the `currentSpace` field of a filter is present), windows need refreshing at every space change anyway, so using this callback will not result in improved performance"," * See `hs.window.filter.forceRefreshOnSpaceChange` for an overview of Spaces limitations in Hammerspoon. If you often (or always) change Space via the \"numbered\" Mission Control keyboard shortcuts (by default, `ctrl-1` etc.), you can call this function from your `init.lua` when intercepting these shortcuts; for example:"," ```"," hs.hotkey.bind('ctrl','1',nil,function()hs.window.filter.switchedToSpace(1)end)"," hs.hotkey.bind('ctrl','2',nil,function()hs.window.filter.switchedToSpace(2)end)"," -- etc."," ```","* Using this callback results in slightly better performance than setting `forceRefreshOnSpaceChange` to `true`, since already visited Spaces are remembered and no refreshing is necessary when switching back to those."],"parameters":[" * space - the Space number the user is switching to"],"returns":[],"signature":"hs.window.filter.switchedToSpace(space)","stripped_doc":"","type":"Function"},"unsubscribe":{"def":"hs.window.filter:unsubscribe([event][, fn]) -> hs.window.filter object","desc":"Removes one or more event subscriptions","doc":"Removes one or more event subscriptions\n\nParameters:\n * event - string or list of strings, the event(s) to unsubscribe; if omitted, `fn`(s) will be unsubscribed from all events;\n   alternatively, this can be a map `{event1=fn1,event2=fn2,...}`: fnN will be unsubscribed from eventN, and the parameter `fn` will be ignored\n * fn - function or list of functions, the callback(s) to remove; if omitted, all callbacks will be unsubscribed from `event`(s)\n\nReturns:\n * the `hs.window.filter` object for method chaining\n\nNotes:\n * You must pass at least one of `event` or `fn`\n * If calling this on the default (or any other shared use) windowfilter, do not pass events, as that would remove\n   *all* the callbacks for the events including ones subscribed elsewhere that you might not be aware of. You should\n   instead keep references to your functions and pass in those.","examples":[],"file":"extensions/window/window_filter.lua","lineno":"1944","name":"unsubscribe","notes":[" * You must pass at least one of `event` or `fn`"," * If calling this on the default (or any other shared use) windowfilter, do not pass events, as that would remove","   *all* the callbacks for the events including ones subscribed elsewhere that you might not be aware of. You should","   instead keep references to your functions and pass in those."],"parameters":[" * event - string or list of strings, the event(s) to unsubscribe; if omitted, `fn`(s) will be unsubscribed from all events; alternatively, this can be a map `{event1=fn1,event2=fn2,...}`: fnN will be unsubscribed from eventN, and the parameter `fn` will be ignored"," * fn - function or list of functions, the callback(s) to remove; if omitted, all callbacks will be unsubscribed from `event`(s)"],"returns":[" * the `hs.window.filter` object for method chaining"],"signature":"hs.window.filter:unsubscribe([event][, fn]) -> hs.window.filter object","stripped_doc":"","type":"Method"},"unsubscribeAll":{"def":"hs.window.filter:unsubscribeAll() -> hs.window.filter object","desc":"Removes all event subscriptions","doc":"Removes all event subscriptions\n\nParameters:\n * None\n\nReturns:\n * the `hs.window.filter` object for method chaining\n\nNotes:\n * You should not use this on the default windowfilter or other shared-use windowfilters","examples":[],"file":"extensions/window/window_filter.lua","lineno":"2008","name":"unsubscribeAll","notes":[" * You should not use this on the default windowfilter or other shared-use windowfilters"],"parameters":[" * None"],"returns":[" * the `hs.window.filter` object for method chaining"],"signature":"hs.window.filter:unsubscribeAll() -> hs.window.filter object","stripped_doc":"","type":"Method"},"windowAllowed":{"def":"hs.window.filter.windowAllowed","desc":"Pseudo-event for `hs.window.filter:subscribe()`: a previously rejected window (or a newly created one) is now allowed","doc":"Pseudo-event for `hs.window.filter:subscribe()`: a previously rejected window (or a newly created one) is now allowed\n\nNotes:\n * this pseudo-event will be emitted *before* the *actual* event(s) (e.g. `windowCreated`) that caused the window to be allowed","file":"extensions/window/window_filter.lua","lineno":"892","name":"windowAllowed","notes":[" * this pseudo-event will be emitted *before* the *actual* event(s) (e.g. `windowCreated`) that caused the window to be allowed"],"signature":"hs.window.filter.windowAllowed","stripped_doc":"","type":"Constant"},"windowCreated":{"def":"hs.window.filter.windowCreated","desc":"Event for `hs.window.filter:subscribe()`: a new window was created","doc":"Event for `hs.window.filter:subscribe()`: a new window was created","file":"extensions/window/window_filter.lua","lineno":"814","name":"windowCreated","signature":"hs.window.filter.windowCreated","stripped_doc":"","type":"Constant"},"windowDestroyed":{"def":"hs.window.filter.windowDestroyed","desc":"Event for `hs.window.filter:subscribe()`: a window was destroyed","doc":"Event for `hs.window.filter:subscribe()`: a window was destroyed","file":"extensions/window/window_filter.lua","lineno":"818","name":"windowDestroyed","signature":"hs.window.filter.windowDestroyed","stripped_doc":"","type":"Constant"},"windowFocused":{"def":"hs.window.filter.windowFocused","desc":"Event for `hs.window.filter:subscribe()`: a window received focus","doc":"Event for `hs.window.filter:subscribe()`: a window received focus","file":"extensions/window/window_filter.lua","lineno":"880","name":"windowFocused","signature":"hs.window.filter.windowFocused","stripped_doc":"","type":"Constant"},"windowFullscreened":{"def":"hs.window.filter.windowFullscreened","desc":"Event for `hs.window.filter:subscribe()`: a window was expanded to fullscreen","doc":"Event for `hs.window.filter:subscribe()`: a window was expanded to fullscreen","file":"extensions/window/window_filter.lua","lineno":"826","name":"windowFullscreened","signature":"hs.window.filter.windowFullscreened","stripped_doc":"","type":"Constant"},"windowHidden":{"def":"hs.window.filter.windowHidden","desc":"Event for `hs.window.filter:subscribe()`: a window was hidden (its app was hidden, e.g. via `cmd-h`)","doc":"Event for `hs.window.filter:subscribe()`: a window was hidden (its app was hidden, e.g. via `cmd-h`)","file":"extensions/window/window_filter.lua","lineno":"846","name":"windowHidden","signature":"hs.window.filter.windowHidden","stripped_doc":"","type":"Constant"},"windowInCurrentSpace":{"def":"hs.window.filter.windowInCurrentSpace","desc":"Event for `hs.window.filter:subscribe()`: a window is now in the current Mission Control Space, due to","doc":"Event for `hs.window.filter:subscribe()`: a window is now in the current Mission Control Space, due to\na Space switch or because it was hidden or minimized (hidden and minimized windows belong to all Spaces)","file":"extensions/window/window_filter.lua","lineno":"860","name":"windowInCurrentSpace","signature":"hs.window.filter.windowInCurrentSpace","stripped_doc":"a Space switch or because it was hidden or minimized (hidden and minimized windows belong to all Spaces)","type":"Constant"},"windowMinimized":{"def":"hs.window.filter.windowMinimized","desc":"Event for `hs.window.filter:subscribe()`: a window was minimized","doc":"Event for `hs.window.filter:subscribe()`: a window was minimized","file":"extensions/window/window_filter.lua","lineno":"834","name":"windowMinimized","signature":"hs.window.filter.windowMinimized","stripped_doc":"","type":"Constant"},"windowMoved":{"def":"hs.window.filter.windowMoved","desc":"Event for `hs.window.filter:subscribe()`: a window was moved or resized, including toggling fullscreen/maximize","doc":"Event for `hs.window.filter:subscribe()`: a window was moved or resized, including toggling fullscreen/maximize","file":"extensions/window/window_filter.lua","lineno":"822","name":"windowMoved","signature":"hs.window.filter.windowMoved","stripped_doc":"","type":"Constant"},"windowNotInCurrentSpace":{"def":"hs.window.filter.windowNotInCurrentSpace","desc":"Event for `hs.window.filter:subscribe()`: a window that used to be in the current Mission Control Space isn't anymore,","doc":"Event for `hs.window.filter:subscribe()`: a window that used to be in the current Mission Control Space isn't anymore,\ndue to a Space switch or because it was unhidden or unminimized onto another Space","file":"extensions/window/window_filter.lua","lineno":"865","name":"windowNotInCurrentSpace","signature":"hs.window.filter.windowNotInCurrentSpace","stripped_doc":"due to a Space switch or because it was unhidden or unminimized onto another Space","type":"Constant"},"windowNotOnScreen":{"def":"hs.window.filter.windowNotOnScreen","desc":"Event for `hs.window.filter:subscribe()`: a window is no longer *actually* visible on any screen because it was minimized, closed,","doc":"Event for `hs.window.filter:subscribe()`: a window is no longer *actually* visible on any screen because it was minimized, closed,\nits application was hidden (e.g. via cmd-h) or closed, or because it's not in the current Mission Control Space anymore","file":"extensions/window/window_filter.lua","lineno":"875","name":"windowNotOnScreen","signature":"hs.window.filter.windowNotOnScreen","stripped_doc":"its application was hidden (e.g. via cmd-h) or closed, or because it's not in the current Mission Control Space anymore","type":"Constant"},"windowNotVisible":{"def":"hs.window.filter.windowNotVisible","desc":"Event for `hs.window.filter:subscribe()`: a window is no longer \"visible\" (in *any* Mission Control Space, as per `hs.window:isVisible()`)","doc":"Event for `hs.window.filter:subscribe()`: a window is no longer \"visible\" (in *any* Mission Control Space, as per `hs.window:isVisible()`)\nbecause it was minimized or closed, or its application was hidden (e.g. via `cmd-h`) or closed","file":"extensions/window/window_filter.lua","lineno":"855","name":"windowNotVisible","signature":"hs.window.filter.windowNotVisible","stripped_doc":"because it was minimized or closed, or its application was hidden (e.g. via `cmd-h`) or closed","type":"Constant"},"windowOnScreen":{"def":"hs.window.filter.windowOnScreen","desc":"Event for `hs.window.filter:subscribe()`: a window became *actually* visible on screen (i.e. it's \"visible\" as per `hs.window:isVisible()`","doc":"Event for `hs.window.filter:subscribe()`: a window became *actually* visible on screen (i.e. it's \"visible\" as per `hs.window:isVisible()`\n*and* in the current Mission Control Space) after having been not visible, or when created","file":"extensions/window/window_filter.lua","lineno":"870","name":"windowOnScreen","signature":"hs.window.filter.windowOnScreen","stripped_doc":"*and* in the current Mission Control Space) after having been not visible, or when created","type":"Constant"},"windowRejected":{"def":"hs.window.filter.windowRejected","desc":"Pseudo-event for `hs.window.filter:subscribe()`: a previously allowed window (or a window that's been destroyed) is now rejected","doc":"Pseudo-event for `hs.window.filter:subscribe()`: a previously allowed window (or a window that's been destroyed) is now rejected\n\nNotes:\n * this pseudo-event will be emitted *after* the *actual* event(s) (e.g. `windowDestroyed`) that caused the window to be rejected","file":"extensions/window/window_filter.lua","lineno":"899","name":"windowRejected","notes":[" * this pseudo-event will be emitted *after* the *actual* event(s) (e.g. `windowDestroyed`) that caused the window to be rejected"],"signature":"hs.window.filter.windowRejected","stripped_doc":"","type":"Constant"},"windowsChanged":{"def":"hs.window.filter.windowsChanged","desc":"Pseudo-event for `hs.window.filter:subscribe()`: the list of allowed windows (as per `windowfilter:getWindows()`) has changed","doc":"Pseudo-event for `hs.window.filter:subscribe()`: the list of allowed windows (as per `windowfilter:getWindows()`) has changed\n\nNotes:\n * callbacks for this event will receive (as the first argument) either a random window among the currently allowed ones,\n   or nil if the windowfilter is rejecting all windows\n * similarly, the second argument passed to callbacks (window's app name) will be nil if the windowfilter is rejecting all windows\n * this pseudo-event will be emitted *after* the *actual* event(s) that caused the list of allowed windows to change","file":"extensions/window/window_filter.lua","lineno":"924","name":"windowsChanged","notes":[" * callbacks for this event will receive (as the first argument) either a random window among the currently allowed ones,","   or nil if the windowfilter is rejecting all windows"," * similarly, the second argument passed to callbacks (window's app name) will be nil if the windowfilter is rejecting all windows"," * this pseudo-event will be emitted *after* the *actual* event(s) that caused the list of allowed windows to change"],"signature":"hs.window.filter.windowsChanged","stripped_doc":"","type":"Constant"},"windowsToEast":{"def":"hs.window.filter:windowsToEast(window, frontmost, strict) -> list of `hs.window` objects","desc":"Gets all visible windows allowed by this windowfilter that lie to the east a given window","doc":"Gets all visible windows allowed by this windowfilter that lie to the east a given window\n\nParameters:\n * window - (optional) an `hs.window` object; if nil, `hs.window.frontmostWindow()` will be used\n * frontmost - (optional) boolean, if true unoccluded windows will be placed before occluded ones in the result list\n * strict - (optional) boolean, if true only consider windows at an angle between 45° and -45° on the\n   eastward axis\n\nReturns:\n * A list of `hs.window` objects representing all windows positioned east (i.e. right) of the window, in ascending order of distance\n\nNotes:\n * This is a convenience wrapper that returns `hs.window.windowsToEast(window,self:getWindows(),...)`\n * You'll likely want to add `:setCurrentSpace(true)` to the windowfilter used for this method call (or just use\n   `hs.window.filter.defaultCurrentSpace`)","examples":[],"file":"extensions/window/window_filter.lua","lineno":"2102","name":"windowsToEast","notes":[" * This is a convenience wrapper that returns `hs.window.windowsToEast(window,self:getWindows(),...)`"," * You'll likely want to add `:setCurrentSpace(true)` to the windowfilter used for this method call (or just use","   `hs.window.filter.defaultCurrentSpace`)"],"parameters":[" * window - (optional) an `hs.window` object; if nil, `hs.window.frontmostWindow()` will be used"," * frontmost - (optional) boolean, if true unoccluded windows will be placed before occluded ones in the result list"," * strict - (optional) boolean, if true only consider windows at an angle between 45° and -45° on the eastward axis"],"returns":[" * A list of `hs.window` objects representing all windows positioned east (i.e. right) of the window, in ascending order of distance"],"signature":"hs.window.filter:windowsToEast(window, frontmost, strict) -> list of `hs.window` objects","stripped_doc":"","type":"Method"},"windowsToNorth":{"def":"hs.window.filter:windowsToNorth(window, frontmost, strict) -> list of `hs.window` objects","desc":"Gets all visible windows allowed by this windowfilter that lie to the north a given window","doc":"Gets all visible windows allowed by this windowfilter that lie to the north a given window\n\nParameters:\n * window - (optional) an `hs.window` object; if nil, `hs.window.frontmostWindow()` will be used\n * frontmost - (optional) boolean, if true unoccluded windows will be placed before occluded ones in the result list\n * strict - (optional) boolean, if true only consider windows at an angle between 45° and -45° on the\n   northward axis\n\nReturns:\n * A list of `hs.window` objects representing all windows positioned north (i.e. up) of the window, in ascending order of distance\n\nNotes:\n * This is a convenience wrapper that returns `hs.window.windowsToNorth(window,self:getWindows(),...)`\n * You'll likely want to add `:setCurrentSpace(true)` to the windowfilter used for this method call (or just use\n   `hs.window.filter.defaultCurrentSpace`)","examples":[],"file":"extensions/window/window_filter.lua","lineno":"2136","name":"windowsToNorth","notes":[" * This is a convenience wrapper that returns `hs.window.windowsToNorth(window,self:getWindows(),...)`"," * You'll likely want to add `:setCurrentSpace(true)` to the windowfilter used for this method call (or just use","   `hs.window.filter.defaultCurrentSpace`)"],"parameters":[" * window - (optional) an `hs.window` object; if nil, `hs.window.frontmostWindow()` will be used"," * frontmost - (optional) boolean, if true unoccluded windows will be placed before occluded ones in the result list"," * strict - (optional) boolean, if true only consider windows at an angle between 45° and -45° on the northward axis"],"returns":[" * A list of `hs.window` objects representing all windows positioned north (i.e. up) of the window, in ascending order of distance"],"signature":"hs.window.filter:windowsToNorth(window, frontmost, strict) -> list of `hs.window` objects","stripped_doc":"","type":"Method"},"windowsToSouth":{"def":"hs.window.filter:windowsToSouth(window, frontmost, strict) -> list of `hs.window` objects","desc":"Gets all visible windows allowed by this windowfilter that lie to the south a given window","doc":"Gets all visible windows allowed by this windowfilter that lie to the south a given window\n\nParameters:\n * window - (optional) an `hs.window` object; if nil, `hs.window.frontmostWindow()` will be used\n * frontmost - (optional) boolean, if true unoccluded windows will be placed before occluded ones in the result list\n * strict - (optional) boolean, if true only consider windows at an angle between 45° and -45° on the\n   southward axis\n\nReturns:\n * A list of `hs.window` objects representing all windows positioned south (i.e. down) of the window, in ascending order of distance\n\nNotes:\n * This is a convenience wrapper that returns `hs.window.windowsToSouth(window,self:getWindows(),...)`\n * You'll likely want to add `:setCurrentSpace(true)` to the windowfilter used for this method call (or just use\n   `hs.window.filter.defaultCurrentSpace`)","examples":[],"file":"extensions/window/window_filter.lua","lineno":"2154","name":"windowsToSouth","notes":[" * This is a convenience wrapper that returns `hs.window.windowsToSouth(window,self:getWindows(),...)`"," * You'll likely want to add `:setCurrentSpace(true)` to the windowfilter used for this method call (or just use","   `hs.window.filter.defaultCurrentSpace`)"],"parameters":[" * window - (optional) an `hs.window` object; if nil, `hs.window.frontmostWindow()` will be used"," * frontmost - (optional) boolean, if true unoccluded windows will be placed before occluded ones in the result list"," * strict - (optional) boolean, if true only consider windows at an angle between 45° and -45° on the southward axis"],"returns":[" * A list of `hs.window` objects representing all windows positioned south (i.e. down) of the window, in ascending order of distance"],"signature":"hs.window.filter:windowsToSouth(window, frontmost, strict) -> list of `hs.window` objects","stripped_doc":"","type":"Method"},"windowsToWest":{"def":"hs.window.filter:windowsToWest(window, frontmost, strict) -> list of `hs.window` objects","desc":"Gets all visible windows allowed by this windowfilter that lie to the west a given window","doc":"Gets all visible windows allowed by this windowfilter that lie to the west a given window\n\nParameters:\n * window - (optional) an `hs.window` object; if nil, `hs.window.frontmostWindow()` will be used\n * frontmost - (optional) boolean, if true unoccluded windows will be placed before occluded ones in the result list\n * strict - (optional) boolean, if true only consider windows at an angle between 45° and -45° on the westward axis\n\nReturns:\n * A list of `hs.window` objects representing all windows positioned west (i.e. left) of the window, in ascending order of distance\n\nNotes:\n * This is a convenience wrapper that returns `hs.window.windowsToWest(window,self:getWindows(),...)`\n * You'll likely want to add `:setCurrentSpace(true)` to the windowfilter used for this method call (or just use `hs.window.filter.defaultCurrentSpace`)","examples":[],"file":"extensions/window/window_filter.lua","lineno":"2120","name":"windowsToWest","notes":[" * This is a convenience wrapper that returns `hs.window.windowsToWest(window,self:getWindows(),...)`"," * You'll likely want to add `:setCurrentSpace(true)` to the windowfilter used for this method call (or just use `hs.window.filter.defaultCurrentSpace`)"],"parameters":[" * window - (optional) an `hs.window` object; if nil, `hs.window.frontmostWindow()` will be used"," * frontmost - (optional) boolean, if true unoccluded windows will be placed before occluded ones in the result list"," * strict - (optional) boolean, if true only consider windows at an angle between 45° and -45° on the westward axis"],"returns":[" * A list of `hs.window` objects representing all windows positioned west (i.e. left) of the window, in ascending order of distance"],"signature":"hs.window.filter:windowsToWest(window, frontmost, strict) -> list of `hs.window` objects","stripped_doc":"","type":"Method"},"windowTitleChanged":{"def":"hs.window.filter.windowTitleChanged","desc":"Event for `hs.window.filter:subscribe()`: a window's title changed","doc":"Event for `hs.window.filter:subscribe()`: a window's title changed","file":"extensions/window/window_filter.lua","lineno":"888","name":"windowTitleChanged","signature":"hs.window.filter.windowTitleChanged","stripped_doc":"","type":"Constant"},"windowUnfocused":{"def":"hs.window.filter.windowUnfocused","desc":"Event for `hs.window.filter:subscribe()`: a window lost focus","doc":"Event for `hs.window.filter:subscribe()`: a window lost focus","file":"extensions/window/window_filter.lua","lineno":"884","name":"windowUnfocused","signature":"hs.window.filter.windowUnfocused","stripped_doc":"","type":"Constant"},"windowUnfullscreened":{"def":"hs.window.filter.windowUnfullscreened","desc":"Event for `hs.window.filter:subscribe()`: a window was reverted back from fullscreen","doc":"Event for `hs.window.filter:subscribe()`: a window was reverted back from fullscreen","file":"extensions/window/window_filter.lua","lineno":"830","name":"windowUnfullscreened","signature":"hs.window.filter.windowUnfullscreened","stripped_doc":"","type":"Constant"},"windowUnhidden":{"def":"hs.window.filter.windowUnhidden","desc":"Event for `hs.window.filter:subscribe()`: a window was unhidden (its app was unhidden, e.g. via `cmd-h`)","doc":"Event for `hs.window.filter:subscribe()`: a window was unhidden (its app was unhidden, e.g. via `cmd-h`)","file":"extensions/window/window_filter.lua","lineno":"842","name":"windowUnhidden","signature":"hs.window.filter.windowUnhidden","stripped_doc":"","type":"Constant"},"windowUnminimized":{"def":"hs.window.filter.windowUnminimized","desc":"Event for `hs.window.filter:subscribe()`: a window was unminimized","doc":"Event for `hs.window.filter:subscribe()`: a window was unminimized","file":"extensions/window/window_filter.lua","lineno":"838","name":"windowUnminimized","signature":"hs.window.filter.windowUnminimized","stripped_doc":"","type":"Constant"},"windowVisible":{"def":"hs.window.filter.windowVisible","desc":"Event for `hs.window.filter:subscribe()`: a window became \"visible\" (in *any* Mission Control Space, as per `hs.window:isVisible()`)","doc":"Event for `hs.window.filter:subscribe()`: a window became \"visible\" (in *any* Mission Control Space, as per `hs.window:isVisible()`)\nafter having been hidden or minimized, or if it was just created","file":"extensions/window/window_filter.lua","lineno":"850","name":"windowVisible","signature":"hs.window.filter.windowVisible","stripped_doc":"after having been hidden or minimized, or if it was just created","type":"Constant"}}
