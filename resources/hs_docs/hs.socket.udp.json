{"broadcast":{"def":"hs.socket.udp:broadcast([flag]) -> self or nil","desc":"Enables broadcasting on the underlying socket.","doc":"Enables broadcasting on the underlying socket.\n\nParameters:\n * `flag` - An optional boolean: `true` to enable broadcasting, `false` to disable it. Defaults to `true`.\n\nReturns:\n * The [`hs.socket.udp`](#new) object, or `nil` if an error occurred.\n\nNotes:\n * By default, the underlying socket in the OS will not allow you to send broadcast messages.\n * In order to send broadcast messages, you need to enable this functionality in the socket.\n * A broadcast is a UDP message to addresses like \"192.168.255.255\" or \"255.255.255.255\" that is delivered to every host on the network.\n * The reason this is generally disabled by default (by the OS) is to prevent accidental broadcast messages from flooding the network.\n","examples":[],"file":"extensions/socket/libsocket_udp.m","lineno":"418","name":"broadcast","notes":[" * By default, the underlying socket in the OS will not allow you to send broadcast messages."," * In order to send broadcast messages, you need to enable this functionality in the socket."," * A broadcast is a UDP message to addresses like \"192.168.255.255\" or \"255.255.255.255\" that is delivered to every host on the network."," * The reason this is generally disabled by default (by the OS) is to prevent accidental broadcast messages from flooding the network."],"parameters":[" * `flag` - An optional boolean: `true` to enable broadcasting, `false` to disable it. Defaults to `true`."],"returns":[" * The [`hs.socket.udp`](#new) object, or `nil` if an error occurred."],"signature":"hs.socket.udp:broadcast([flag]) -> self or nil","stripped_doc":"","type":"Method"},"close":{"def":"hs.socket.udp:close() -> self","desc":"Immediately closes the socket, freeing it for reuse. Any pending send operations are discarded.","doc":"Immediately closes the socket, freeing it for reuse. Any pending send operations are discarded.\n\nParameters:\n * None\n\nReturns:\n * The [`hs.socket.udp`](#new) object.\n","examples":[],"file":"extensions/socket/libsocket_udp.m","lineno":"222","name":"close","notes":[],"parameters":[" * None"],"returns":[" * The [`hs.socket.udp`](#new) object."],"signature":"hs.socket.udp:close() -> self","stripped_doc":"","type":"Method"},"closed":{"def":"hs.socket.udp:closed() -> bool","desc":"Returns the closed status of the socket.","doc":"Returns the closed status of the socket.\n\nParameters:\n * None\n\nReturns:\n * `true` if the socket is closed, otherwise `false`.\n\nNotes:\n * UDP sockets are typically meant to be connectionless.\n * Sending a packet anywhere, regardless of whether or not the destination receives it, opens the socket until it is explicitly closed.\n * An active listening socket will not be closed, but will not be 'connected' unless the [`hs.socket.udp:connect`](#connect) method has been called.\n","examples":[],"file":"extensions/socket/libsocket_udp.m","lineno":"675","name":"closed","notes":[" * UDP sockets are typically meant to be connectionless."," * Sending a packet anywhere, regardless of whether or not the destination receives it, opens the socket until it is explicitly closed."," * An active listening socket will not be closed, but will not be 'connected' unless the [`hs.socket.udp:connect`](#connect) method has been called."],"parameters":[" * None"],"returns":[" * `true` if the socket is closed, otherwise `false`."],"signature":"hs.socket.udp:closed() -> bool","stripped_doc":"","type":"Method"},"connect":{"def":"hs.socket.udp:connect(host, port[, fn]) -> self or nil","desc":"Connects an unconnected socket.","doc":"Connects an unconnected socket.\n\nParameters:\n * `host` - A string containing the hostname or IP address.\n * `port` - A port number [1-65535].\n * `fn` - An optional single-use callback function to execute after establishing the connection. The callback receives no parameters.\n\nReturns:\n * The [`hs.socket.udp`](#new) object, or `nil` if an error occurred.\n\nNotes:\n* By design, UDP is a connectionless protocol, and connecting is not needed.\n* Choosing to connect to a specific host/port has the following effect:\n  * You will only be able to send data to the connected host/port;\n  * You will only be able to receive data from the connected host/port;\n  * You will receive ICMP messages that come from the connected host/port, such as \"connection refused\".\n* The actual process of connecting a UDP socket does not result in any communication on the socket, it simply changes the internal state of the socket.\n* You cannot bind a socket for listening after it has been connected.\n* You can only connect a socket once.\n","examples":[],"file":"extensions/socket/libsocket_udp.m","lineno":"145","name":"connect","notes":["* By design, UDP is a connectionless protocol, and connecting is not needed.","* Choosing to connect to a specific host/port has the following effect:","  * You will only be able to send data to the connected host/port;","  * You will only be able to receive data from the connected host/port;","  * You will receive ICMP messages that come from the connected host/port, such as \"connection refused\".","* The actual process of connecting a UDP socket does not result in any communication on the socket, it simply changes the internal state of the socket.","* You cannot bind a socket for listening after it has been connected.","* You can only connect a socket once."],"parameters":[" * `host` - A string containing the hostname or IP address."," * `port` - A port number [1-65535]."," * `fn` - An optional single-use callback function to execute after establishing the connection. The callback receives no parameters."],"returns":[" * The [`hs.socket.udp`](#new) object, or `nil` if an error occurred."],"signature":"hs.socket.udp:connect(host, port[, fn]) -> self or nil","stripped_doc":"","type":"Method"},"connected":{"def":"hs.socket.udp:connected() -> bool","desc":"Returns the connection status of the socket.","doc":"Returns the connection status of the socket.\n\nParameters:\n * None\n\nReturns:\n * `true` if connected, otherwise `false`.\n\nNotes:\n * UDP sockets are typically meant to be connectionless.\n * This method will only return `true` if the [`hs.socket.udp:connect`](#connect) method has been explicitly called.\n","examples":[],"file":"extensions/socket/libsocket_udp.m","lineno":"652","name":"connected","notes":[" * UDP sockets are typically meant to be connectionless."," * This method will only return `true` if the [`hs.socket.udp:connect`](#connect) method has been explicitly called."],"parameters":[" * None"],"returns":[" * `true` if connected, otherwise `false`."],"signature":"hs.socket.udp:connected() -> bool","stripped_doc":"","type":"Method"},"enableIPv":{"def":"hs.socket.udp:enableIPv(version[, flag]) -> self or nil","desc":"Enables or disables IPv4 or IPv6 on the underlying socket. By default, both are enabled.","doc":"Enables or disables IPv4 or IPv6 on the underlying socket. By default, both are enabled.\n\nParameters:\n * `version` - A number containing the IP version (4 or 6) to enable or disable.\n * `flag` - A boolean: `true` to enable the chosen IP version, `false` to disable it. Defaults to `true`.\n\nReturns:\n * The [`hs.socket.udp`](#new) object, or `nil` if an error occurred.\n\nNotes:\n * Must be called before binding the socket. If you want to create an IPv6-only server, do something like:\n   * `hs.socket.udp.new(callback):enableIPv(4, false):listen(port):receive()`\n * The convenience constructor [`hs.socket.server`](#server) will automatically bind the socket and requires closing and relistening to use this method.\n","examples":[],"file":"extensions/socket/libsocket_udp.m","lineno":"486","name":"enableIPv","notes":[" * Must be called before binding the socket. If you want to create an IPv6-only server, do something like:","   * `hs.socket.udp.new(callback):enableIPv(4, false):listen(port):receive()`"," * The convenience constructor [`hs.socket.server`](#server) will automatically bind the socket and requires closing and relistening to use this method."],"parameters":[" * `version` - A number containing the IP version (4 or 6) to enable or disable."," * `flag` - A boolean: `true` to enable the chosen IP version, `false` to disable it. Defaults to `true`."],"returns":[" * The [`hs.socket.udp`](#new) object, or `nil` if an error occurred."],"signature":"hs.socket.udp:enableIPv(version[, flag]) -> self or nil","stripped_doc":"","type":"Method"},"info":{"def":"hs.socket.udp:info() -> table","desc":"Returns information about the socket.","doc":"Returns information about the socket.\n\nParameters:\n * None\n\nReturns:\n * A table containing the following keys:\n   * connectedAddress - `string` (`sockaddr` struct)\n   * connectedHost - `string`\n   * connectedPort - `number`\n   * isClosed - `boolean`\n   * isConnected - `boolean`\n   * isIPv4 - `boolean`\n   * isIPv4Enabled - `boolean`\n   * isIPv4Preferred - `boolean`\n   * isIPv6 - `boolean`\n   * isIPv6Enabled - `boolean`\n   * isIPv6Preferred - `boolean`\n   * isIPVersionNeutral - `boolean`\n   * localAddress - `string` (`sockaddr` struct)\n   * localAddress_IPv4 - `string` (`sockaddr` struct)\n   * localAddress_IPv6 - `string` (`sockaddr` struct)\n   * localHost - `string`\n   * localHost_IPv4 - `string`\n   * localHost_IPv6 - `string`\n   * localPort - `number`\n   * localPort_IPv4 - `number`\n   * localPort_IPv6 - `number`\n   * maxReceiveIPv4BufferSize - `number`\n   * maxReceiveIPv6BufferSize - `number`\n   * timeout - `number`\n   * userData - `string`\n","examples":[],"file":"extensions/socket/libsocket_udp.m","lineno":"699","name":"info","notes":[],"parameters":[" * None"],"returns":[" * A table containing the following keys:","   * connectedAddress - `string` (`sockaddr` struct)","   * connectedHost - `string`","   * connectedPort - `number`","   * isClosed - `boolean`","   * isConnected - `boolean`","   * isIPv4 - `boolean`","   * isIPv4Enabled - `boolean`","   * isIPv4Preferred - `boolean`","   * isIPv6 - `boolean`","   * isIPv6Enabled - `boolean`","   * isIPv6Preferred - `boolean`","   * isIPVersionNeutral - `boolean`","   * localAddress - `string` (`sockaddr` struct)","   * localAddress_IPv4 - `string` (`sockaddr` struct)","   * localAddress_IPv6 - `string` (`sockaddr` struct)","   * localHost - `string`","   * localHost_IPv4 - `string`","   * localHost_IPv6 - `string`","   * localPort - `number`","   * localPort_IPv4 - `number`","   * localPort_IPv6 - `number`","   * maxReceiveIPv4BufferSize - `number`","   * maxReceiveIPv6BufferSize - `number`","   * timeout - `number`","   * userData - `string`"],"signature":"hs.socket.udp:info() -> table","stripped_doc":"","type":"Method"},"listen":{"def":"hs.socket.udp:listen(port) -> self or nil","desc":"Binds an unconnected socket to a port for listening.","doc":"Binds an unconnected socket to a port for listening.\n\nParameters:\n * `port` - A port number [0-65535]. Ports [1-1023] are privileged. Port 0 allows the OS to select any available port.\n\nReturns:\n * The [`hs.socket.udp`](#new) object, or `nil` if an error occurred.\n","examples":[],"file":"extensions/socket/libsocket_udp.m","lineno":"192","name":"listen","notes":[],"parameters":[" * `port` - A port number [0-65535]. Ports [1-1023] are privileged. Port 0 allows the OS to select any available port."],"returns":[" * The [`hs.socket.udp`](#new) object, or `nil` if an error occurred."],"signature":"hs.socket.udp:listen(port) -> self or nil","stripped_doc":"","type":"Method"},"new":{"def":"hs.socket.udp.new([fn]) -> hs.socket.udp object","desc":"Creates an unconnected asynchronous UDP socket object.","doc":"Creates an unconnected asynchronous UDP socket object.\n\nParameters:\n * `fn` - An optional [callback function](#setCallback) for reading data from the socket, settable here for convenience.\n\nReturns:\n * An [`hs.socket.udp`](#new) object.\n","examples":[],"file":"extensions/socket/libsocket_udp.m","lineno":"111","name":"new","notes":[],"parameters":[" * `fn` - An optional [callback function](#setCallback) for reading data from the socket, settable here for convenience."],"returns":[" * An [`hs.socket.udp`](#new) object."],"signature":"hs.socket.udp.new([fn]) -> hs.socket.udp object","stripped_doc":"","type":"Constructor"},"parseAddress":{"def":"hs.socket.udp.parseAddress(sockaddr) -> table or nil","desc":"Alias for [`hs.socket.parseAddress`](./hs.socket.html#parseAddress)","doc":"Alias for [`hs.socket.parseAddress`](./hs.socket.html#parseAddress)\n","file":"extensions/socket/socket.lua","lineno":"184","name":"parseAddress","notes":[],"parameters":[],"returns":[],"signature":"hs.socket.udp.parseAddress(sockaddr) -> table or nil","stripped_doc":"","type":"Function"},"pause":{"def":"hs.socket.udp:pause() -> self","desc":"Suspends reading of packets from the socket.","doc":"Suspends reading of packets from the socket.\n\nParameters:\n * None\n\nReturns:\n * The [`hs.socket.udp`](#new) object\n\nNotes:\n * Call one of the receive methods to resume.\n","examples":[],"file":"extensions/socket/libsocket_udp.m","lineno":"243","name":"pause","notes":[" * Call one of the receive methods to resume."],"parameters":[" * None"],"returns":[" * The [`hs.socket.udp`](#new) object"],"signature":"hs.socket.udp:pause() -> self","stripped_doc":"","type":"Method"},"preferIPv":{"def":"hs.socket.udp:preferIPv([version]) -> self","desc":"Sets the preferred IP version: IPv4, IPv6, or neutral (first to resolve).","doc":"Sets the preferred IP version: IPv4, IPv6, or neutral (first to resolve).\n\nParameters:\n * `version` - An optional number containing the IP version to prefer. Anything but 4 or 6 else sets the default neutral behavior.\n\nReturns:\n * The [`hs.socket.udp`](#new) object.\n\nNotes:\n * If a DNS lookup returns only IPv4 results, the socket will automatically use IPv4.\n * If a DNS lookup returns only IPv6 results, the socket will automatically use IPv6.\n * If a DNS lookup returns both IPv4 and IPv6 results, then the protocol used depends on the configured preference.\n","examples":[],"file":"extensions/socket/libsocket_udp.m","lineno":"523","name":"preferIPv","notes":[" * If a DNS lookup returns only IPv4 results, the socket will automatically use IPv4."," * If a DNS lookup returns only IPv6 results, the socket will automatically use IPv6."," * If a DNS lookup returns both IPv4 and IPv6 results, then the protocol used depends on the configured preference."],"parameters":[" * `version` - An optional number containing the IP version to prefer. Anything but 4 or 6 else sets the default neutral behavior."],"returns":[" * The [`hs.socket.udp`](#new) object."],"signature":"hs.socket.udp:preferIPv([version]) -> self","stripped_doc":"","type":"Method"},"read":{"def":"hs.socket.udp:read(delimiter[, tag]) -> self","desc":"Alias for [`hs.socket.udp:receive`](#receive)","doc":"Alias for [`hs.socket.udp:receive`](#receive)\n","file":"extensions/socket/socket.lua","lineno":"237","name":"read","notes":[],"parameters":[],"returns":[],"signature":"hs.socket.udp:read(delimiter[, tag]) -> self","stripped_doc":"","type":"Method"},"readOne":{"def":"hs.socket.udp:readOne(delimiter[, tag]) -> self","desc":"Alias for [`hs.socket.udp:receiveOne`](#receiveOne)","doc":"Alias for [`hs.socket.udp:receiveOne`](#receiveOne)\n","file":"extensions/socket/socket.lua","lineno":"243","name":"readOne","notes":[],"parameters":[],"returns":[],"signature":"hs.socket.udp:readOne(delimiter[, tag]) -> self","stripped_doc":"","type":"Method"},"receive":{"def":"hs.socket.udp:receive([fn]) -> self or nil","desc":"Reads packets from the socket as they arrive.","doc":"Reads packets from the socket as they arrive.\n\nParameters:\n * `fn` - Optionally supply the [read callback](#setCallback) here.\n\nReturns:\n * The [`hs.socket.udp`](#new) object, or `nil` if an error occurred.\n\nNotes:\n * Results are passed to the [callback function](#setCallback), which must be set to use this method.\n * There are two modes of operation for receiving packets: one-at-a-time & continuous.\n * In one-at-a-time mode, you call receiveOne every time you are ready process an incoming UDP packet.\n * Receiving packets one-at-a-time may be better suited for implementing certain state machine code where your state machine may not always be ready to process incoming packets.\n * In continuous mode, the callback is invoked immediately every time incoming udp packets are received.\n * Receiving packets continuously is better suited to real-time streaming applications.\n * You may switch back and forth between one-at-a-time mode and continuous mode.\n * If the socket is currently in one-at-a-time mode, calling this method will switch it to continuous mode.\n","examples":[],"file":"extensions/socket/libsocket_udp.m","lineno":"295","name":"receive","notes":[" * Results are passed to the [callback function](#setCallback), which must be set to use this method."," * There are two modes of operation for receiving packets: one-at-a-time & continuous."," * In one-at-a-time mode, you call receiveOne every time you are ready process an incoming UDP packet."," * Receiving packets one-at-a-time may be better suited for implementing certain state machine code where your state machine may not always be ready to process incoming packets."," * In continuous mode, the callback is invoked immediately every time incoming udp packets are received."," * Receiving packets continuously is better suited to real-time streaming applications."," * You may switch back and forth between one-at-a-time mode and continuous mode."," * If the socket is currently in one-at-a-time mode, calling this method will switch it to continuous mode."],"parameters":[" * `fn` - Optionally supply the [read callback](#setCallback) here."],"returns":[" * The [`hs.socket.udp`](#new) object, or `nil` if an error occurred."],"signature":"hs.socket.udp:receive([fn]) -> self or nil","stripped_doc":"","type":"Method"},"receiveOne":{"def":"hs.socket.udp:receiveOne([fn]) -> self or nil","desc":"Reads a single packet from the socket.","doc":"Reads a single packet from the socket.\n\nParameters:\n * `fn` - Optionally supply the [read callback](#setCallback) here.\n\nReturns:\n * The [`hs.socket.udp`](#new) object, or `nil` if an error occurred.\n\nNotes:\n * Results are passed to the [callback function](#setCallback), which must be set to use this method.\n * There are two modes of operation for receiving packets: one-at-a-time & continuous.\n * In one-at-a-time mode, you call receiveOne every time you are ready process an incoming UDP packet.\n * Receiving packets one-at-a-time may be better suited for implementing certain state machine code where your state machine may not always be ready to process incoming packets.\n * In continuous mode, the callback is invoked immediately every time incoming udp packets are received.\n * Receiving packets continuously is better suited to real-time streaming applications.\n * You may switch back and forth between one-at-a-time mode and continuous mode.\n * If the socket is currently in continuous mode, calling this method will switch it to one-at-a-time mode\n","examples":[],"file":"extensions/socket/libsocket_udp.m","lineno":"321","name":"receiveOne","notes":[" * Results are passed to the [callback function](#setCallback), which must be set to use this method."," * There are two modes of operation for receiving packets: one-at-a-time & continuous."," * In one-at-a-time mode, you call receiveOne every time you are ready process an incoming UDP packet."," * Receiving packets one-at-a-time may be better suited for implementing certain state machine code where your state machine may not always be ready to process incoming packets."," * In continuous mode, the callback is invoked immediately every time incoming udp packets are received."," * Receiving packets continuously is better suited to real-time streaming applications."," * You may switch back and forth between one-at-a-time mode and continuous mode."," * If the socket is currently in continuous mode, calling this method will switch it to one-at-a-time mode"],"parameters":[" * `fn` - Optionally supply the [read callback](#setCallback) here."],"returns":[" * The [`hs.socket.udp`](#new) object, or `nil` if an error occurred."],"signature":"hs.socket.udp:receiveOne([fn]) -> self or nil","stripped_doc":"","type":"Method"},"reusePort":{"def":"hs.socket.udp:reusePort([flag]) -> self or nil","desc":"Enables port reuse on the socket.","doc":"Enables port reuse on the socket.\n\nParameters:\n * `flag` - An optional boolean: `true` to enable port reuse, `false` to disable it. Defaults to `true`.\n\nReturns:\n * The [`hs.socket.udp`](#new) object, or `nil` if an error occurred.\n\nNotes:\n * By default, only one socket can be bound to a given IP address & port at a time.\n * To enable multiple processes to simultaneously bind to the same address & port, you need to enable this functionality in the socket.\n * All processes that wish to use the address & port simultaneously must all enable reuse port on the socket bound to that port.\n * Must be called before binding the socket.\n","examples":[],"file":"extensions/socket/libsocket_udp.m","lineno":"452","name":"reusePort","notes":[" * By default, only one socket can be bound to a given IP address & port at a time."," * To enable multiple processes to simultaneously bind to the same address & port, you need to enable this functionality in the socket."," * All processes that wish to use the address & port simultaneously must all enable reuse port on the socket bound to that port."," * Must be called before binding the socket."],"parameters":[" * `flag` - An optional boolean: `true` to enable port reuse, `false` to disable it. Defaults to `true`."],"returns":[" * The [`hs.socket.udp`](#new) object, or `nil` if an error occurred."],"signature":"hs.socket.udp:reusePort([flag]) -> self or nil","stripped_doc":"","type":"Method"},"send":{"def":"hs.socket.udp:send(message[, host, port][, tag, fn]) -> self","desc":"Sends a packet to the destination address.","doc":"Sends a packet to the destination address.\n\nParameters:\n * `message` - A string containing data to be sent on the socket.\n * `host` - A string containing the hostname or IP address.\n * `port` - A port number [1-65535].\n * `tag` - An optional integer to assist with labeling writes.\n * `fn` - An optional single-use callback function to execute after sending the packet. The callback receives the tag parameter provided here.\n\nReturns:\n * The [`hs.socket.udp`](#new) object.\n\nNotes:\n * For non-connected sockets, the remote destination is specified for each packet.\n * If the socket has been explicitly connected with [`connect`](#connect), only the message parameter and an optional tag and/or write callback can be supplied.\n * Recall that connecting is optional for a UDP socket.\n * For connected sockets, data can only be sent to the connected address.\n","examples":[],"file":"extensions/socket/libsocket_udp.m","lineno":"347","name":"send","notes":[" * For non-connected sockets, the remote destination is specified for each packet."," * If the socket has been explicitly connected with [`connect`](#connect), only the message parameter and an optional tag and/or write callback can be supplied."," * Recall that connecting is optional for a UDP socket."," * For connected sockets, data can only be sent to the connected address."],"parameters":[" * `message` - A string containing data to be sent on the socket."," * `host` - A string containing the hostname or IP address."," * `port` - A port number [1-65535]."," * `tag` - An optional integer to assist with labeling writes."," * `fn` - An optional single-use callback function to execute after sending the packet. The callback receives the tag parameter provided here."],"returns":[" * The [`hs.socket.udp`](#new) object."],"signature":"hs.socket.udp:send(message[, host, port][, tag, fn]) -> self","stripped_doc":"","type":"Method"},"server":{"def":"hs.socket.udp.server(port[, fn]) -> hs.socket.udp object","desc":"Creates a UDP socket, and binds it to a port for listening.","doc":"Creates a UDP socket, and binds it to a port for listening.\n\nParameters:\n * `port` - A port number [0-65535]. Ports [1-1023] are privileged. Port 0 allows the OS to select any available port.\n * `fn` - An optional [callback function](#setCallback) for reading data from the socket, settable here for convenience.\n\nReturns:\n * An [`hs.socket.udp`](#new) object.\n","examples":[],"file":"extensions/socket/socket.lua","lineno":"208","name":"server","notes":[],"parameters":[" * `port` - A port number [0-65535]. Ports [1-1023] are privileged. Port 0 allows the OS to select any available port."," * `fn` - An optional [callback function](#setCallback) for reading data from the socket, settable here for convenience."],"returns":[" * An [`hs.socket.udp`](#new) object."],"signature":"hs.socket.udp.server(port[, fn]) -> hs.socket.udp object","stripped_doc":"","type":"Constructor"},"setBufferSize":{"def":"hs.socket.udp:setBufferSize(size[, version]) -> self","desc":"Sets the maximum size of the buffer that will be allocated for receive operations.","doc":"Sets the maximum size of the buffer that will be allocated for receive operations.\n\nParameters:\n * `size` - An number containing the receive buffer size in bytes.\n * `version` - An optional number containing the IP version for which to set the buffer size. Anything but 4 or 6 else sets the same size for both.\n\nReturns:\n * The [`hs.socket.udp`](#new) object.\n\nNotes:\n * The default maximum size is 9216 bytes.\n * The theoretical maximum size of any IPv4 UDP packet is `UINT16_MAX = 65535`.\n * The theoretical maximum size of any IPv6 UDP packet is `UINT32_MAX = 4294967295`.\n * Since the OS notifies us of the size of each received UDP packet, the actual allocated buffer size for each packet is exact.\n * In practice the size of UDP packets is generally much smaller than the max. Most protocols will send and receive packets of only a few bytes, or will set a limit on the size of packets to prevent fragmentation in the IP layer.\n * If you set the buffer size too small, the sockets API in the OS will silently discard any extra data.\n","examples":[],"file":"extensions/socket/libsocket_udp.m","lineno":"555","name":"setBufferSize","notes":[" * The default maximum size is 9216 bytes."," * The theoretical maximum size of any IPv4 UDP packet is `UINT16_MAX = 65535`."," * The theoretical maximum size of any IPv6 UDP packet is `UINT32_MAX = 4294967295`."," * Since the OS notifies us of the size of each received UDP packet, the actual allocated buffer size for each packet is exact."," * In practice the size of UDP packets is generally much smaller than the max. Most protocols will send and receive packets of only a few bytes, or will set a limit on the size of packets to prevent fragmentation in the IP layer."," * If you set the buffer size too small, the sockets API in the OS will silently discard any extra data."],"parameters":[" * `size` - An number containing the receive buffer size in bytes."," * `version` - An optional number containing the IP version for which to set the buffer size. Anything but 4 or 6 else sets the same size for both."],"returns":[" * The [`hs.socket.udp`](#new) object."],"signature":"hs.socket.udp:setBufferSize(size[, version]) -> self","stripped_doc":"","type":"Method"},"setCallback":{"def":"hs.socket.udp:setCallback([fn]) -> self","desc":"Sets the read callback for the socket.","doc":"Sets the read callback for the socket.\n\nParameters:\n * `fn` - An optional callback function to process data read from the socket. `nil` or no argument clears the callback. The callback receives 2 parameters:\n   * `data` - The data read from the socket as a string.\n   * `sockaddr` - The sending address as a binary socket address structure. See [`parseAddress`](#parseAddress).\n\nReturns:\n * The [`hs.socket.udp`](#new) object.\n\nNotes:\n * A callback must be set in order to read data from the socket.\n","examples":[],"file":"extensions/socket/libsocket_udp.m","lineno":"597","name":"setCallback","notes":[" * A callback must be set in order to read data from the socket."],"parameters":[" * `fn` - An optional callback function to process data read from the socket. `nil` or no argument clears the callback. The callback receives 2 parameters:\n   * `data` - The data read from the socket as a string.\n   * `sockaddr` - The sending address as a binary socket address structure. See [`parseAddress`](#parseAddress)."],"returns":[" * The [`hs.socket.udp`](#new) object."],"signature":"hs.socket.udp:setCallback([fn]) -> self","stripped_doc":"","type":"Method"},"setTimeout":{"def":"hs.socket.udp:setTimeout(timeout) -> self","desc":"Sets the timeout for the socket operations.","doc":"Sets the timeout for the socket operations.\n\nParameters:\n * `timeout` - A number containing the timeout duration, in seconds.\n\nReturns:\n * The [`hs.socket.udp`](#new) object.\n\nNotes:\n *  If the timeout value is negative, the operations will not use a timeout, which is the default.\n","examples":[],"file":"extensions/socket/libsocket_udp.m","lineno":"628","name":"setTimeout","notes":[" *  If the timeout value is negative, the operations will not use a timeout, which is the default."],"parameters":[" * `timeout` - A number containing the timeout duration, in seconds."],"returns":[" * The [`hs.socket.udp`](#new) object."],"signature":"hs.socket.udp:setTimeout(timeout) -> self","stripped_doc":"","type":"Method"},"timeout":{"def":"hs.socket.udp.timeout","desc":"Timeout for the socket operations, in seconds.","doc":"Timeout for the socket operations, in seconds.\n\nNotes:\n * New [`hs.socket.udp`](#new) objects will be created with this timeout value, but can individually change it with the [`hs.socket.udp:setTimeout`](#setTimeout) method.\n\n * If the timeout value is negative, the operations will not use a timeout. The default value is `-1`.\n","file":"extensions/socket/socket.lua","lineno":"173","name":"timeout","notes":[" * New [`hs.socket.udp`](#new) objects will be created with this timeout value, but can individually change it with the [`hs.socket.udp:setTimeout`](#setTimeout) method.",""," * If the timeout value is negative, the operations will not use a timeout. The default value is `-1`."],"signature":"hs.socket.udp.timeout","stripped_doc":" * If the timeout value is negative, the operations will not use a timeout. The default value is `-1`.","type":"Variable"},"write":{"def":"hs.socket.udp:write(message[, tag]) -> self","desc":"Alias for [`hs.socket.udp:send`](#send)","doc":"Alias for [`hs.socket.udp:send`](#send)\n","file":"extensions/socket/socket.lua","lineno":"249","name":"write","notes":[],"parameters":[],"returns":[],"signature":"hs.socket.udp:write(message[, tag]) -> self","stripped_doc":"","type":"Method"}}
